<?xml version="1.0"?>
<!--This file was created automatically by html2xhtml-->
<!--from the HTML stylesheets.-->
<xsl:stylesheet xmlns="http://www.w3.org/1999/xhtml"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:ng="http://docbook.org/docbook-ng"
  xmlns:db="http://docbook.org/ns/docbook"
  xmlns:exsl="http://exslt.org/common"
  xmlns:exslt="http://exslt.org/common"
  xmlns:fm="http://freshmeat.net/projects/freshmeat-submit/"
  xmlns:sf="http://sourceforge.net/"
  xmlns:dyn="http://exslt.org/dynamic"
  xmlns:saxon="http://icl.com/saxon"
  xmlns:doc="http://nwalsh.com/xsl/documentation/1.0"
  xmlns:stbl="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.Table"
  xmlns:xtbl="xalan://com.nwalsh.xalan.Table"
  xmlns:lxslt="http://xml.apache.org/xslt"
  xmlns:ptbl="http://nwalsh.com/xslt/ext/xsltproc/python/Table"
  xmlns:sverb="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.Verbatim"
  xmlns:xverb="xalan://com.nwalsh.xalan.Verbatim"
  xmlns:suwl="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.UnwrapLinks"
  xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:stext="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.TextFactory"
  xmlns:simg="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.ImageIntrinsics"
  xmlns:ximg="xalan://com.nwalsh.xalan.ImageIntrinsics"
  xmlns:xtext="xalan://com.nwalsh.xalan.Text"
  xmlns:date="http://exslt.org/dates-and-times"
  xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0"
  xmlns:mml="http://www.w3.org/1998/Math/MathML"
  xmlns:set="http://exslt.org/sets"
  xmlns:NodeInfo="http://org.apache.xalan.lib.NodeInfo"
  xmlns:redirect="http://xml.apache.org/xalan/redirect"
  xmlns:perl="urn:perl"
  exclude-result-prefixes="db doc dyn saxon ng exsl exslt stbl xtbl lxslt ptbl fm sf sverb xlink suwl xverb stext xtext simg l date mml set NodeInfo redirect ximg"
  extension-element-prefixes="perl stext xtext ptbl xtbl stbl"
  version="1.0">

<xsl:output method="xml" indent="yes" encoding="UTF-8"/>

<!-- ********************************************************************
     $Id: docbook.xsl 9605 2012-09-18 10:48:54Z tom_schr $
     ********************************************************************

     This file is part of the XSL DocBook Stylesheet distribution.
     See ../README or http://docbook.sf.net/release/xsl/current/ for
     copyright and other information.

     ******************************************************************** -->

<!-- ==================================================================== -->

<xsl:param name="publican.version">3.1.5</xsl:param>
<xsl:param name="body.only" select="1"/>
<xsl:param name="book.type" select="'book'"/>
<xsl:param name="web.type" select="''"/>
<xsl:param name="confidential" select="0"/>
<xsl:param name="confidential.text">CONFIDENTIAL</xsl:param>
<xsl:param name="embedtoc" select="'0'"/>
<xsl:param name="tocpath" select="''"/>
<xsl:param name="pop_prod" select="''"/>
<xsl:param name="pop_ver" select="''"/>
<xsl:param name="pop_name" select="''"/>
<xsl:param name="brand" select="''"/>
<xsl:param name="langpath" select="''"/>
<xsl:param name="desktop" select="0"/>
<xsl:param name="refentry.pagebreak">0</xsl:param>
<xsl:param name="svg.object">1</xsl:param>
<xsl:param name="package" select="''"/>
<xsl:param name="html.longdesc.embed" select="1"/>
<xsl:param name="chunker.output.quiet" select="0"/>

<xsl:param name="get"/>
<xsl:param name="VERSION">1.78.1</xsl:param>
<xsl:param name="Tag" select="concat('V',translate('1.78.1','.',''))"/>
<xsl:param name="DistroTitle">XSL Stylesheets</xsl:param>
<xsl:param name="sf-relid" select="0"/>
<xsl:param name="DistroName">docbook-xsl</xsl:param>
<xsl:param name="PreviousRelease">1.78.0</xsl:param>
<xsl:param name="PreviousReleaseRevision">9696</xsl:param>
<xsl:param name="Revision">$Revision: 9731 $</xsl:param>
<xsl:param name="VersionFileURL">$URL: https://docbook.svn.sourceforge.net/svnroot/docbook/trunk/xsl/VERSION $</xsl:param>
<xsl:strip-space elements="fm:*"/>
<fm:project xmlns:fm="http://freshmeat.net/projects/freshmeat-submit/">
  <fm:Project>DocBook</fm:Project>
  <fm:Branch>XSL Stylesheets</fm:Branch>
  <!-- * set/keep fm:version as N.NN.N-pre except for official releases, -->
  <!-- * then after the release, revert it to N.NN.N-pre & check back in -->
  <fm:Version>1.78.1</fm:Version>
<!--
  <fm:License>MIT/X Consortium License</fm:License>
-->
  <fm:Release-Focus>
<!-- * Initial freshmeat announcement -->
<!-- * Documentation -->
<!-- * Code cleanup -->
<!-- * Minor feature enhancements  -->
* Major feature enhancements 
<!-- * Minor bugfixes  -->
<!-- * Major bugfixes -->
<!-- * Minor security fixes -->
<!-- * Major security fixes -->
  </fm:Release-Focus>
  <fm:Home-Page-URL>http://sourceforge.net/projects/docbook/</fm:Home-Page-URL>
  <fm:Gzipped-Tar-URL>http://prdownloads.sourceforge.net/docbook/{DISTRONAME-VERSION}.tar.gz?download</fm:Gzipped-Tar-URL>
  <fm:Zipped-Tar-URL>http://prdownloads.sourceforge.net/docbook/{DISTRONAME-VERSION}.zip?download</fm:Zipped-Tar-URL>
  <fm:Bzipped-Tar-URL>http://prdownloads.sourceforge.net/docbook/{DISTRONAME-VERSION}.bz2?download</fm:Bzipped-Tar-URL>
  <fm:Changelog-URL>http://sourceforge.net/project/shownotes.php?release_id={SFRELID}</fm:Changelog-URL>
  <fm:CVS-URL>http://docbook.svn.sourceforge.net/viewvc/docbook/</fm:CVS-URL>
  <fm:Mailing-List-URL>http://lists.oasis-open.org/archives/docbook-apps/</fm:Mailing-List-URL>
  <fm:Changes>This is a release with bugfixes and some enhancements.</fm:Changes>
</fm:project><xsl:template match="/" priority="-100">
  <xsl:choose>
    <xsl:when test="$get = 'Tag'">
      <xsl:value-of select="$Tag"/>
    </xsl:when>
    <xsl:when test="$get = 'PreviousRelease'">
      <xsl:value-of select="$PreviousRelease"/>
    </xsl:when>
    <xsl:when test="$get = 'PreviousReleaseRevision'">
      <xsl:value-of select="$PreviousReleaseRevision"/>
    </xsl:when>
    <xsl:when test="$get = 'DistroTitle'">
      <xsl:value-of select="$DistroTitle"/>
    </xsl:when>
    <xsl:when test="$get = 'VERSION'">
      <xsl:value-of select="$VERSION"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:if test="$sf-relid = 0">
        <xsl:message terminate="yes">
         <xsl:text>You must specify the sf-relid as a parameter.</xsl:text>
        </xsl:message>
      </xsl:if>
      <xsl:apply-templates select="//fm:project"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="fm:project">
  <xsl:apply-templates/>
  <xsl:text>
</xsl:text>
  <xsl:apply-templates select="fm:Changes" mode="text"/>
</xsl:template><xsl:template match="fm:Changes"/><xsl:template match="fm:Gzipped-Tar-URL|fm:Zipped-Tar-URL|fm:Bzipped-Tar-URL">
  <xsl:value-of select="local-name(.)"/>
  <xsl:text>: </xsl:text>
  <xsl:value-of select="substring-before(., '{DISTRONAME-VERSION}')"/>
  <xsl:value-of select="concat($DistroName, '-', $VERSION)"/>
  <xsl:value-of select="substring-after(., '{DISTRONAME-VERSION}')"/>
  <xsl:text>
</xsl:text>
</xsl:template><xsl:template match="fm:Changelog-URL">
  <xsl:value-of select="local-name(.)"/>
  <xsl:text>: </xsl:text>
  <xsl:value-of select="substring-before(., '{SFRELID}')"/>
  <xsl:value-of select="$sf-relid"/>
  <xsl:value-of select="substring-after(., '{SFRELID}')"/>
  <xsl:text>
</xsl:text>
</xsl:template><xsl:template match="fm:*">
  <xsl:value-of select="local-name(.)"/>
  <xsl:text>: </xsl:text>
  <xsl:value-of select="normalize-space(.)"/>
  <xsl:text>
</xsl:text>
</xsl:template>
<xsl:param name="abstract.notitle.enabled" select="0"/>
<xsl:param name="activate.external.olinks" select="1"/>
<xsl:param name="admon.graphics.extension">.png</xsl:param>
<xsl:param name="admon.graphics" select="1"/>
<xsl:param name="admon.graphics.path">
    <xsl:choose>
      <xsl:when test="$embedtoc != 0">
        <xsl:value-of select="concat($tocpath, '/../', $brand, '/', $langpath, '/images')"/>
      </xsl:when>
      <xsl:otherwise>
		<xsl:text>images/</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
</xsl:param>
<xsl:param name="admon.style" select="''"/>
<xsl:param name="admon.textlabel" select="1"/>
<xsl:param name="annotate.toc" select="1"/>
<xsl:param name="annotation.css">
/* ======================================================================
   Annotations
*/

div.annotation-list  { visibility: hidden;
                     }

div.annotation-nocss { position: absolute;
                       visibility: hidden;
                     }

div.annotation-popup { position: absolute;
                       z-index: 4;
                       visibility: hidden;
                       padding: 0px;
                       margin: 2px;
                       border-style: solid;
                       border-width: 1px;
                       width: 200px;
		       background-color: white;
                     }

div.annotation-title { padding: 1px;
                       font-weight: bold;
                       border-bottom-style: solid;
                       border-bottom-width: 1px;
		       color: white;
		       background-color: black;
                     }

div.annotation-body  { padding: 2px;
                     }

div.annotation-body p { margin-top: 0px;
                        padding-top: 0px;
                      }

div.annotation-close { position: absolute;
                       top: 2px;
                       right: 2px;
                     }
</xsl:param>
<xsl:param name="annotation.graphic.close">
http://docbook.sourceforge.net/release/images/annot-close.png</xsl:param>
<xsl:param name="annotation.graphic.open">http://docbook.sourceforge.net/release/images/annot-open.png</xsl:param>
<xsl:param name="annotation.js">
<xsl:text>http://docbook.sourceforge.net/release/script/AnchorPosition.js http://docbook.sourceforge.net/release/script/PopupWindow.js</xsl:text></xsl:param>
<xsl:param name="annotation.support" select="0"/>
<xsl:param name="appendix.autolabel">A</xsl:param>
<xsl:param name="author.othername.in.middle" select="1"/>
<xsl:param name="autotoc.label.in.hyperlink" select="1"/>
<xsl:param name="autotoc.label.separator">. </xsl:param>
<xsl:param name="base.dir"/>
<xsl:param name="biblioentry.item.separator">. </xsl:param>
<xsl:param name="bibliography.collection">http://docbook.sourceforge.net/release/bibliography/bibliography.xml</xsl:param><xsl:param name="bibliography.numbered" select="0"/>
<xsl:param name="bibliography.style">normal</xsl:param>
<xsl:param name="blurb.on.titlepage.enabled" select="0"/>
<xsl:param name="bridgehead.in.toc" select="0"/>
<xsl:param name="callout.defaultcolumn">60</xsl:param>
<xsl:param name="callout.graphics.extension">.png</xsl:param>
<xsl:param name="callout.graphics" select="1"/>
<xsl:param name="callout.graphics.number.limit">15</xsl:param>
<xsl:param name="callout.graphics.path">
  <xsl:value-of select="$admon.graphics.path"/>
</xsl:param>
<xsl:param name="callout.list.table" select="1"/>
<xsl:param name="callout.unicode" select="0"/>
<xsl:param name="callout.unicode.number.limit">10</xsl:param>
<xsl:param name="callout.unicode.start.character">10102</xsl:param>
<xsl:param name="callouts.extension" select="1"/>
<xsl:param name="chapter.autolabel" select="1"/>
<xsl:param name="chunk.append"/>
<xsl:param name="chunk.first.sections" select="1"/>
<xsl:param name="chunk.quietly" select="0"/>
<xsl:param name="chunk.section.depth" select="4"/>
<xsl:param name="chunk.separate.lots" select="0"/>
<xsl:param name="chunk.toc" select="''"/>
<xsl:param name="chunk.tocs.and.lots" select="0"/>
<xsl:param name="chunk.tocs.and.lots.has.title" select="1"/>
<xsl:param name="chunked.filename.prefix"/>
<xsl:param name="citerefentry.link" select="0"/>
<xsl:param name="collect.xref.targets">no</xsl:param>
<xsl:param name="component.label.includes.part.label" select="0"/>
<xsl:param name="contrib.inline.enabled">1</xsl:param>
<xsl:param name="css.decoration" select="0"/>
<xsl:param name="current.docid"/>
<xsl:param name="custom.css"/>
<xsl:param name="custom.css.filename"/>
<xsl:param name="default.float.class">
  <xsl:choose>
    <xsl:when test="contains($stylesheet.result.type,'html')">left</xsl:when>
    <xsl:otherwise>before</xsl:otherwise>
  </xsl:choose>
</xsl:param>
<xsl:param name="default.image.width"/>
<xsl:param name="default.table.frame">all</xsl:param>
<xsl:param name="default.table.width"/>
<xsl:param name="docbook.css.link" select="1"/>
<xsl:param name="docbook.css">
/********************************/
/* start of styles in block.xsl */

.formalpara-title {
  font-weight: bold;
}

div.blockquote-title {
  font-weight: bold;
  margin-top: 1em;
  margin-bottom: 1em;
}

span.msgmain-title {
  font-weight: bold;
}

span.msgsub-title {
  font-weight: bold;
}

span.msgrel-title {
  font-weight: bold;
}

div.msglevel, div.msgorig, div.msgaud {
  margin-top: 1em;
  margin-bottom: 1em;
}

span.msglevel-title, span.msgorig-title, span.msgaud-title {
  font-weight: bold;
}

div.msgexplan {
  margin-top: 1em;
  margin-bottom: 1em;
}

span.msgexplan-title {
  font-weight: bold;
}

/* end of styles in block.xsl */
/********************************/

/********************************/
/* start of styles in autotoc.xsl */


/* end of styles in autotoc.xsl */
/********************************/

/********************************/
/* start of styles in formal.xsl */

div.figure-title {
  font-weight: bold;
}

div.example-title {
  font-weight: bold;
}

div.equation-title {
  font-weight: bold;
}

div.table-title {
  font-weight: bold;
}

div.sidebar-title {
  font-weight: bold;
}


/* end of styles in formal.xsl */
/********************************/

/********************************/
/* start of styles in verbatim.xsl */

div.programlisting {
  white-space: pre;
  font-family: monospace;
}

div.screen {
  white-space: pre;
  font-family: monospace;
}
</xsl:param>
<xsl:param name="docbook.css.filename">docbook.css</xsl:param>
<xsl:param name="draft.mode">maybe</xsl:param>
<xsl:param name="draft.watermark.image">images/draft.png</xsl:param>
<xsl:param name="ebnf.assignment">
<code>::=</code>
</xsl:param>
<xsl:param name="ebnf.statement.terminator"/>
<xsl:param name="ebnf.table.bgcolor">#F5DCB3</xsl:param>
<xsl:param name="ebnf.table.border" select="1"/>
<xsl:param name="eclipse.autolabel" select="0"/>
<xsl:param name="eclipse.plugin.id">com.example.help</xsl:param>
<xsl:param name="eclipse.plugin.name">DocBook Online Help Sample</xsl:param>
<xsl:param name="eclipse.plugin.provider">Example provider</xsl:param>
<xsl:param name="editedby.enabled">1</xsl:param>
<xsl:param name="email.delimiters.enabled" select="0"/>
<xsl:param name="emphasis.propagates.style" select="1"/>
<xsl:param name="entry.propagates.style" select="1"/>
<xsl:param name="exsl.node.set.available"> 
  <xsl:choose>
    <xsl:when exsl:foo="" test="function-available('exsl:node-set') or                        contains(system-property('xsl:vendor'),                          'Apache Software Foundation')">1</xsl:when>
    <xsl:otherwise>0</xsl:otherwise>
  </xsl:choose>
</xsl:param>
<xsl:param name="firstterm.only.link" select="0"/>
<xsl:param name="footer.rule" select="0"/>
<xsl:param name="footnote.number.format">1</xsl:param>
<xsl:param name="footnote.number.symbols"/>
<xsl:param name="formal.procedures" select="1"/>
<xsl:param name="formal.title.placement">
figure after
example before
equation before
table before
procedure before 
</xsl:param>
<xsl:param name="funcsynopsis.decoration" select="1"/>
<xsl:param name="funcsynopsis.style">ansi</xsl:param>
<xsl:param name="function.parens" select="0"/>
<xsl:param name="generate.consistent.ids" select="0"/>
<xsl:param name="generate.css.header" select="0"/>
<xsl:param name="generate.id.attributes" select="0"/>
<xsl:param name="generate.index" select="1"/>
<xsl:param name="generate.legalnotice.link" select="0"/>
<xsl:param name="generate.manifest" select="0"/>
<xsl:param name="generate.meta.abstract" select="1"/>
<xsl:param name="generate.revhistory.link" select="0"/>
<xsl:param name="generate.section.toc.level" select="0"/>
<xsl:param name="generate.toc">
set toc
book toc
article nop
chapter toc
qandadiv toc
qandaset toc
sect1 nop
sect2 nop
sect3 nop
sect4 nop
sect5 nop
section toc
part toc
</xsl:param>
<xsl:param name="glossary.collection"/>
<xsl:param name="glossary.sort" select="1"/>
<xsl:param name="glossentry.show.acronym">no</xsl:param>
<xsl:param name="glossterm.auto.link" select="0"/>
<xsl:param name="graphic.default.extension"/>
<xsl:param name="graphicsize.extension" select="1"/>
<xsl:param name="graphicsize.use.img.src.path" select="0"/>
<xsl:param name="header.rule" select="0"/>
<xsl:param name="highlight.default.language"/>
<xsl:param name="highlight.source" select="1"/>
<xsl:param name="highlight.xslthl.config"/>
<xsl:param name="html.append"/>
<xsl:param name="html.base"/>
<xsl:param name="html.cellpadding"/>
<xsl:param name="html.cellspacing"/>
<xsl:param name="html.cleanup" select="0"/>
<xsl:param name="html.ext">.html</xsl:param>
<xsl:param name="html.extra.head.links" select="0"/>
<xsl:param name="html.head.legalnotice.link.multiple" select="1"/>
<xsl:param name="html.head.legalnotice.link.types">copyright</xsl:param>
<xsl:param name="html.longdesc" select="0"/>
<xsl:param name="html.longdesc.link" select="0"/>
<xsl:param name="html.script"/>
<xsl:param name="html.script.type">text/javascript</xsl:param>
<xsl:param name="html.stylesheet">
  <xsl:if test="$embedtoc = 0 ">css/default.css</xsl:if>
</xsl:param>
<xsl:param name="html.stylesheet.type">text/css</xsl:param>
<xsl:param name="html.stylesheet.print">
  <xsl:if test="$embedtoc = 0 ">css/print.css</xsl:if>
</xsl:param>
<xsl:param name="htmlhelp.alias.file">alias.h</xsl:param>
<xsl:param name="htmlhelp.autolabel" select="0"/>
<xsl:param name="htmlhelp.button.back" select="1"/>
<xsl:param name="htmlhelp.button.forward" select="0"/>
<xsl:param name="htmlhelp.button.hideshow" select="1"/>
<xsl:param name="htmlhelp.button.home" select="0"/>
<xsl:param name="htmlhelp.button.home.url"/>
<xsl:param name="htmlhelp.button.jump1" select="0"/>
<xsl:param name="htmlhelp.button.jump1.title">User1</xsl:param>
<xsl:param name="htmlhelp.button.jump1.url"/>
<xsl:param name="htmlhelp.button.jump2" select="0"/>
<xsl:param name="htmlhelp.button.jump2.title">User2</xsl:param>
<xsl:param name="htmlhelp.button.jump2.url"/>
<xsl:param name="htmlhelp.button.locate" select="0"/>
<xsl:param name="htmlhelp.button.next" select="1"/>
<xsl:param name="htmlhelp.button.options" select="1"/>
<xsl:param name="htmlhelp.button.prev" select="1"/>
<xsl:param name="htmlhelp.button.print" select="1"/>
<xsl:param name="htmlhelp.button.refresh" select="0"/>
<xsl:param name="htmlhelp.button.stop" select="0"/>
<xsl:param name="htmlhelp.button.zoom" select="0"/>
<xsl:param name="htmlhelp.chm">htmlhelp.chm</xsl:param>
<xsl:param name="htmlhelp.default.topic"/>
<xsl:param name="htmlhelp.display.progress" select="1"/>
<xsl:param name="htmlhelp.encoding">iso-8859-1</xsl:param>
<xsl:param name="htmlhelp.enhanced.decompilation" select="0"/>
<xsl:param name="htmlhelp.enumerate.images" select="0"/>
<xsl:param name="htmlhelp.force.map.and.alias" select="0"/>
<xsl:param name="htmlhelp.hhc.binary" select="1"/>
<xsl:param name="htmlhelp.hhc.folders.instead.books" select="1"/>
<xsl:param name="htmlhelp.hhc">toc.hhc</xsl:param>
<xsl:param name="htmlhelp.hhc.section.depth">5</xsl:param>
<xsl:param name="htmlhelp.hhc.show.root" select="1"/>
<xsl:param name="htmlhelp.hhc.width"/>
<xsl:param name="htmlhelp.hhk">index.hhk</xsl:param>
<xsl:param name="htmlhelp.hhp">htmlhelp.hhp</xsl:param>
<xsl:param name="htmlhelp.hhp.tail"/>
<xsl:param name="htmlhelp.hhp.window">Main</xsl:param>
<xsl:param name="htmlhelp.hhp.windows"/>
<xsl:param name="htmlhelp.map.file">context.h</xsl:param>
<xsl:param name="htmlhelp.only" select="0"/>
<xsl:param name="htmlhelp.remember.window.position" select="0"/>
<xsl:param name="htmlhelp.show.advanced.search" select="0"/>
<xsl:param name="htmlhelp.show.favorities" select="0"/>
<xsl:param name="htmlhelp.show.menu" select="0"/>
<xsl:param name="htmlhelp.show.toolbar.text" select="1"/>
<xsl:param name="htmlhelp.title"/>
<xsl:param name="htmlhelp.use.hhk" select="0"/>
<xsl:param name="htmlhelp.window.geometry"/>
<xsl:param name="id.warnings" select="0"/>
<xsl:param name="ignore.image.scaling" select="0"/>
<xsl:param name="img.src.path"/>
<xsl:param name="index.links.to.section" select="1"/>
<xsl:param name="index.method">basic</xsl:param>
<xsl:param name="index.number.separator"/>
<xsl:param name="index.on.role" select="0"/>
<xsl:param name="index.on.type" select="0"/>
<xsl:param name="index.prefer.titleabbrev" select="0"/>
<xsl:param name="index.range.separator"/>
<xsl:param name="index.term.separator"/>
<xsl:param name="inherit.keywords" select="1"/>
<xsl:param name="insert.olink.page.number">no</xsl:param>
<xsl:param name="insert.olink.pdf.frag" select="0"/>
<xsl:param name="insert.xref.page.number">no</xsl:param>
<xsl:param name="javahelp.encoding">iso-8859-1</xsl:param>
<xsl:param name="keep.relative.image.uris" select="1"/>
<xsl:param name="l10n.gentext.default.language">en</xsl:param>
<xsl:param name="l10n.gentext.language"/>
<xsl:param name="l10n.gentext.use.xref.language" select="0"/>
<xsl:param name="l10n.lang.value.rfc.compliant" select="1"/>
<xsl:param name="label.from.part" select="0"/>
<xsl:param name="linenumbering.everyNth">5</xsl:param>
<xsl:param name="linenumbering.extension" select="1"/>
<xsl:param name="linenumbering.separator"><xsl:text> </xsl:text></xsl:param>
<xsl:param name="linenumbering.width">3</xsl:param>
<xsl:param name="link.mailto.url"/>
<xsl:param name="make.clean.html" select="0"/>
<xsl:param name="make.graphic.viewport" select="0"/>
<xsl:param name="make.single.year.ranges" select="0"/>
<xsl:param name="make.valid.html" select="1"/>
<xsl:param name="make.year.ranges" select="0"/>
<xsl:param name="manifest">HTML.manifest</xsl:param>
<xsl:param name="manifest.in.base.dir" select="0"/>
<xsl:param name="manual.toc"/>
<xsl:param name="menuchoice.menu.separator"> â†’ </xsl:param>
<xsl:param name="menuchoice.separator">+</xsl:param>
<xsl:param name="navig.graphics.extension">.gif</xsl:param>
<xsl:param name="navig.graphics" select="0"/>
<xsl:param name="navig.graphics.path">images/</xsl:param>
<xsl:param name="navig.showtitles">1</xsl:param>
<xsl:param name="nominal.image.depth" select="4 * $pixels.per.inch"/>
<xsl:param name="nominal.image.width" select="6 * $pixels.per.inch"/>
<xsl:param name="nominal.table.width">6in</xsl:param>
<xsl:param name="olink.base.uri"/>
<xsl:param name="olink.debug" select="0"/>
<xsl:param name="olink.doctitle">no</xsl:param>
<xsl:param name="olink.lang.fallback.sequence"/>
<xsl:attribute-set name="olink.properties">
  <xsl:attribute name="show-destination">replace</xsl:attribute>
</xsl:attribute-set>
<xsl:param name="othercredit.like.author.enabled">0</xsl:param>
<xsl:param name="para.propagates.style" select="1"/>
<xsl:param name="part.autolabel">I</xsl:param>
<xsl:param name="phrase.propagates.style" select="1"/>
<xsl:param name="pixels.per.inch">90</xsl:param>
<xsl:param name="points.per.em">10</xsl:param>
<xsl:param name="preface.autolabel" select="0"/>
<xsl:param name="prefer.internal.olink" select="0"/>
<xsl:param name="preferred.mediaobject.role"/>
<xsl:param name="process.empty.source.toc" select="0"/>
<xsl:param name="process.source.toc" select="0"/>
<xsl:param name="profile.arch"/>
<xsl:param name="profile.attribute"/>
<xsl:param name="profile.audience"/>
<xsl:param name="profile.condition"/>
<xsl:param name="profile.conformance"/>
<xsl:param name="profile.lang"/>
<xsl:param name="profile.os"/>
<xsl:param name="profile.revision"/>
<xsl:param name="profile.revisionflag"/>
<xsl:param name="profile.role"/>
<xsl:param name="profile.security"/>
<xsl:param name="profile.separator">;</xsl:param>
<xsl:param name="profile.status"/>
<xsl:param name="profile.userlevel"/>
<xsl:param name="profile.value"/>
<xsl:param name="profile.vendor"/>
<xsl:param name="profile.wordsize"/>
<xsl:param name="punct.honorific">.</xsl:param>
<xsl:param name="qanda.defaultlabel">qanda</xsl:param>
<xsl:param name="qanda.in.toc" select="0"/>
<xsl:param name="qanda.inherit.numeration" select="1"/>
<xsl:param name="qanda.nested.in.toc" select="0"/>
<xsl:param name="qandadiv.autolabel" select="1"/>
<xsl:param name="refclass.suppress" select="0"/>
<xsl:param name="refentry.generate.name" select="1"/>
<xsl:param name="refentry.generate.title" select="0"/>
<xsl:param name="refentry.separator" select="1"/>
<xsl:param name="refentry.xref.manvolnum" select="1"/>
<xsl:param name="reference.autolabel">I</xsl:param>
<xsl:param name="root.filename">index</xsl:param>
<xsl:param name="rootid"/>
<xsl:param name="runinhead.default.title.end.punct">.</xsl:param>
<xsl:param name="runinhead.title.end.punct">.!?:</xsl:param>
<xsl:param name="section.autolabel" select="1"/>
<xsl:param name="section.autolabel.max.depth">8</xsl:param>
<xsl:param name="section.label.includes.component.label" select="1"/>
<xsl:param name="segmentedlist.as.table" select="1"/>
<xsl:param name="shade.verbatim" select="0"/>
<xsl:attribute-set name="shade.verbatim.style">
  <xsl:attribute name="border">0</xsl:attribute>
  <xsl:attribute name="bgcolor">#E0E0E0</xsl:attribute>
</xsl:attribute-set>
<xsl:param name="show.comments" select="0"/>
<xsl:param name="show.revisionflag" select="0"/>
<xsl:param name="simplesect.in.toc" select="0"/>
<xsl:param name="spacing.paras" select="0"/>
<xsl:param name="suppress.footer.navigation"><xsl:value-of select="$embedtoc"/></xsl:param>
<xsl:param name="suppress.header.navigation" select="0"/>
<xsl:param name="suppress.navigation" select="0"/>
<xsl:param name="table.borders.with.css" select="0"/>
<xsl:param name="table.cell.border.color"/>
<xsl:param name="table.cell.border.style"/>
<xsl:param name="table.cell.border.thickness">0.5pt</xsl:param>
<xsl:param name="table.footnote.number.format">a</xsl:param>
<xsl:param name="table.footnote.number.symbols"/>
<xsl:param name="table.frame.border.color"/>
<xsl:param name="table.frame.border.style">solid</xsl:param>
<xsl:param name="table.frame.border.thickness">0.5pt</xsl:param>
<xsl:param name="tablecolumns.extension" select="0"/>
<xsl:param name="target.database.document">olinkdb.xml</xsl:param>
<xsl:param name="targets.filename">target.db</xsl:param>
<xsl:param name="tex.math.delims" select="1"/>
<xsl:param name="tex.math.file">tex-math-equations.tex</xsl:param>
<xsl:param name="tex.math.in.alt"/>
<xsl:param name="textdata.default.encoding"/>
<xsl:param name="textinsert.extension" select="1"/>
<xsl:param name="toc.list.type">dl</xsl:param>
<xsl:param name="toc.max.depth">8</xsl:param>
<xsl:param name="toc.section.depth">2</xsl:param>
<xsl:param name="ulink.target"/>
<xsl:param name="use.embed.for.svg" select="0"/>
<xsl:param name="use.extensions" select="1"/>
<xsl:param name="use.id.as.filename" select="1"/>
<xsl:param name="use.local.olink.style" select="0"/>
<xsl:param name="use.role.as.xrefstyle" select="1"/>
<xsl:param name="use.role.for.mediaobject" select="1"/>
<xsl:param name="use.svg" select="1"/>
<xsl:param name="variablelist.as.table" select="0"/>
<xsl:param name="variablelist.term.break.after">0</xsl:param>
<xsl:param name="variablelist.term.separator">, </xsl:param>
<xsl:param name="webhelp.autolabel">0</xsl:param>
<xsl:param name="webhelp.base.dir">docs</xsl:param>
<xsl:param name="webhelp.common.dir">../common/</xsl:param>
<xsl:param name="webhelp.default.topic">index.html</xsl:param>
<xsl:param name="webhelp.include.search.tab">1</xsl:param>
<xsl:param name="webhelp.indexer.language">en</xsl:param>
<xsl:param name="webhelp.start.filename">index.html</xsl:param>
<xsl:param name="webhelp.tree.cookie.id" select="concat( 'treeview-', count(//node()) )"/>
<xsl:param name="writing.mode">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key">writing-mode</xsl:with-param>
    <xsl:with-param name="lang">
      <xsl:call-template name="l10n.language">
        <xsl:with-param name="target" select="/*[1]"/>
      </xsl:call-template>
    </xsl:with-param>
  </xsl:call-template>
</xsl:param><xsl:param name="xref.label-page.separator"><xsl:text> </xsl:text></xsl:param><xsl:param name="xref.label-title.separator">: </xsl:param><xsl:param name="xref.title-page.separator"><xsl:text> </xsl:text></xsl:param><xsl:param name="xref.with.number.and.title" select="1"/>
<xsl:template name="dot.count">
  <!-- Returns the number of "." characters in a string -->
  <xsl:param name="string"/>
  <xsl:param name="count" select="0"/>
  <xsl:choose>
    <xsl:when test="contains($string, '.')">
      <xsl:call-template name="dot.count">
        <xsl:with-param name="string" select="substring-after($string, '.')"/>
        <xsl:with-param name="count" select="$count+1"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$count"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="copy-string">
  <!-- returns 'count' copies of 'string' -->
  <xsl:param name="string"/>
  <xsl:param name="count" select="0"/>
  <xsl:param name="result"/>

  <xsl:choose>
    <xsl:when test="$count&gt;0">
      <xsl:call-template name="copy-string">
        <xsl:with-param name="string" select="$string"/>
        <xsl:with-param name="count" select="$count - 1"/>
        <xsl:with-param name="result">
          <xsl:value-of select="$result"/>
          <xsl:value-of select="$string"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$result"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="string.subst">
  <xsl:param name="string"/>
  <xsl:param name="target"/>
  <xsl:param name="replacement"/>

  <xsl:choose>
    <xsl:when test="contains($string, $target)">
      <xsl:variable name="rest">
        <xsl:call-template name="string.subst">
          <xsl:with-param name="string" select="substring-after($string, $target)"/>
          <xsl:with-param name="target" select="$target"/>
          <xsl:with-param name="replacement" select="$replacement"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:value-of select="concat(substring-before($string, $target),                                    $replacement,                                    $rest)"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$string"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="xpointer.idref">
  <xsl:param name="xpointer">http://...</xsl:param>
  <xsl:choose>
    <xsl:when test="starts-with($xpointer, '#xpointer(id(')">
      <xsl:variable name="rest" select="substring-after($xpointer, '#xpointer(id(')"/>
      <xsl:variable name="quote" select="substring($rest, 1, 1)"/>
      <xsl:value-of select="substring-before(substring-after($xpointer, $quote), $quote)"/>
    </xsl:when>
    <xsl:when test="starts-with($xpointer, '#')">
      <xsl:value-of select="substring-after($xpointer, '#')"/>
    </xsl:when>
    <!-- otherwise it's a pointer to some other document -->
  </xsl:choose>
</xsl:template><xsl:template name="length-magnitude">
  <xsl:param name="length" select="'0pt'"/>

  <xsl:choose>
    <xsl:when test="string-length($length) = 0"/>
    <xsl:when test="substring($length,1,1) = '0'                     or substring($length,1,1) = '1'                     or substring($length,1,1) = '2'                     or substring($length,1,1) = '3'                     or substring($length,1,1) = '4'                     or substring($length,1,1) = '5'                     or substring($length,1,1) = '6'                     or substring($length,1,1) = '7'                     or substring($length,1,1) = '8'                     or substring($length,1,1) = '9'                     or substring($length,1,1) = '.'">
      <xsl:value-of select="substring($length,1,1)"/>
      <xsl:call-template name="length-magnitude">
        <xsl:with-param name="length" select="substring($length,2)"/>
      </xsl:call-template>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template name="length-units">
  <xsl:param name="length" select="'0pt'"/>
  <xsl:param name="default.units" select="'px'"/>
  <xsl:variable name="magnitude">
    <xsl:call-template name="length-magnitude">
      <xsl:with-param name="length" select="$length"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="units">
    <xsl:value-of select="substring($length, string-length($magnitude)+1)"/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$units = ''">
      <xsl:value-of select="$default.units"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$units"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="length-spec">
  <xsl:param name="length" select="'0pt'"/>
  <xsl:param name="default.units" select="'px'"/>

  <xsl:variable name="magnitude">
    <xsl:call-template name="length-magnitude">
      <xsl:with-param name="length" select="$length"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="units">
    <xsl:value-of select="substring($length, string-length($magnitude)+1)"/>
  </xsl:variable>

  <xsl:value-of select="$magnitude"/>
  <xsl:choose>
    <xsl:when test="$units='cm'                     or $units='mm'                     or $units='in'                     or $units='pt'                     or $units='pc'                     or $units='px'                     or $units='em'">
      <xsl:value-of select="$units"/>
    </xsl:when>
    <xsl:when test="$units = ''">
      <xsl:value-of select="$default.units"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:message>
        <xsl:text>Unrecognized unit of measure: </xsl:text>
        <xsl:value-of select="$units"/>
        <xsl:text>.</xsl:text>
      </xsl:message>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="length-in-points">
  <xsl:param name="length" select="'0pt'"/>
  <xsl:param name="em.size" select="10"/>
  <xsl:param name="pixels.per.inch" select="90"/>

  <xsl:variable name="magnitude">
    <xsl:call-template name="length-magnitude">
      <xsl:with-param name="length" select="$length"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="units">
    <xsl:value-of select="substring($length, string-length($magnitude)+1)"/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$units = 'pt'">
      <xsl:value-of select="$magnitude"/>
    </xsl:when>
    <xsl:when test="$units = 'cm'">
      <xsl:value-of select="$magnitude div 2.54 * 72.0"/>
    </xsl:when>
    <xsl:when test="$units = 'mm'">
      <xsl:value-of select="$magnitude div 25.4 * 72.0"/>
    </xsl:when>
    <xsl:when test="$units = 'in'">
      <xsl:value-of select="$magnitude * 72.0"/>
    </xsl:when>
    <xsl:when test="$units = 'pc'">
      <xsl:value-of select="$magnitude * 12.0"/>
    </xsl:when>
    <xsl:when test="$units = 'px'">
      <xsl:value-of select="$magnitude div $pixels.per.inch * 72.0"/>
    </xsl:when>
    <xsl:when test="$units = 'em'">
      <xsl:value-of select="$magnitude * $em.size"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:message>
        <xsl:text>Unrecognized unit of measure: </xsl:text>
        <xsl:value-of select="$units"/>
        <xsl:text>.</xsl:text>
      </xsl:message>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="pi-attribute">
  <xsl:param name="pis" select="processing-instruction('BOGUS_PI')"/>
  <xsl:param name="attribute">filename</xsl:param>
  <xsl:param name="count">1</xsl:param>

  <xsl:choose>
    <xsl:when test="$count&gt;count($pis)">
      <!-- not found -->
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="pi">
        <xsl:value-of select="$pis[$count]"/>
      </xsl:variable>
      <xsl:variable name="pivalue">
        <xsl:value-of select="concat(' ', normalize-space($pi))"/>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="contains($pivalue,concat(' ', $attribute, '='))">
          <xsl:variable name="rest" select="substring-after($pivalue,concat(' ', $attribute,'='))"/>
          <xsl:variable name="quote" select="substring($rest,1,1)"/>
          <xsl:value-of select="substring-before(substring($rest,2),$quote)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="pi-attribute">
            <xsl:with-param name="pis" select="$pis"/>
            <xsl:with-param name="attribute" select="$attribute"/>
            <xsl:with-param name="count" select="$count + 1"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="lookup.key">
  <xsl:param name="key" select="''"/>
  <xsl:param name="table" select="''"/>

  <xsl:if test="contains($table, ' ')">
    <xsl:choose>
      <xsl:when test="substring-before($table, ' ') = $key">
        <xsl:variable name="rest" select="substring-after($table, ' ')"/>
        <xsl:choose>
          <xsl:when test="contains($rest, ' ')">
            <xsl:value-of select="substring-before($rest, ' ')"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$rest"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="lookup.key">
          <xsl:with-param name="key" select="$key"/>
          <xsl:with-param name="table" select="substring-after(substring-after($table,' '), ' ')"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
</xsl:template><xsl:template name="xpath.location">
  <xsl:param name="node" select="."/>
  <xsl:param name="path" select="''"/>

  <xsl:variable name="next.path">
    <xsl:value-of select="local-name($node)"/>
    <xsl:if test="$path != ''">/</xsl:if>
    <xsl:value-of select="$path"/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$node/parent::*">
      <xsl:call-template name="xpath.location">
        <xsl:with-param name="node" select="$node/parent::*"/>
        <xsl:with-param name="path" select="$next.path"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>/</xsl:text>
      <xsl:value-of select="$next.path"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="comment-escape-string">
  <xsl:param name="string" select="''"/>

  <xsl:if test="starts-with($string, '-')">
    <xsl:text> </xsl:text>
  </xsl:if>

  <xsl:call-template name="comment-escape-string.recursive">
    <xsl:with-param name="string" select="$string"/>
  </xsl:call-template>

  <xsl:if test="substring($string, string-length($string), 1) = '-'">
    <xsl:text> </xsl:text>
  </xsl:if>
</xsl:template><xsl:template name="comment-escape-string.recursive">
  <xsl:param name="string" select="''"/>
  <xsl:choose>
    <xsl:when test="contains($string, '--')">
      <xsl:value-of select="substring-before($string, '--')"/>
      <xsl:value-of select="'- -'"/>
      <xsl:call-template name="comment-escape-string.recursive">
        <xsl:with-param name="string" select="substring-after($string, '--')"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$string"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="str.tokenize.keep.delimiters">
    <xsl:param name="string" select="''"/>
    <xsl:param name="delimiters" select="' '"/>
    <xsl:choose>
      <xsl:when test="not($string)"/>
      <xsl:when test="not($delimiters)">
        <xsl:call-template name="str.tokenize.keep.delimiters-characters">
          <xsl:with-param name="string" select="$string"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="str.tokenize.keep.delimiters-delimiters">
          <xsl:with-param name="string" select="$string"/>
          <xsl:with-param name="delimiters" select="$delimiters"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template><xsl:template name="str.tokenize.keep.delimiters-characters">
    <xsl:param name="string"/>
    <xsl:if test="$string">
      <ssb:token xmlns:ssb="http://sideshowbarker.net/ns"><xsl:value-of select="substring($string, 1, 1)"/></ssb:token>
      <xsl:call-template name="str.tokenize.keep.delimiters-characters">
        <xsl:with-param name="string" select="substring($string, 2)"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:template><xsl:template name="str.tokenize.keep.delimiters-delimiters">
    <xsl:param name="string"/>
    <xsl:param name="delimiters"/>
    <xsl:variable name="delimiter" select="substring($delimiters, 1, 1)"/>
    <xsl:choose>
      <xsl:when test="not($delimiter)">
        <ssb:token xmlns:ssb="http://sideshowbarker.net/ns"><xsl:value-of select="$string"/></ssb:token>
      </xsl:when>
      <xsl:when test="contains($string, $delimiter)">
        <xsl:if test="not(starts-with($string, $delimiter))">
          <xsl:call-template name="str.tokenize.keep.delimiters-delimiters">
            <xsl:with-param name="string" select="substring-before($string, $delimiter)"/>
            <xsl:with-param name="delimiters" select="substring($delimiters, 2)"/>
          </xsl:call-template>
        </xsl:if>
        <!-- output each delimiter -->
        <xsl:value-of select="$delimiter"/>
        <xsl:call-template name="str.tokenize.keep.delimiters-delimiters">
          <xsl:with-param name="string" select="substring-after($string, $delimiter)"/>
          <xsl:with-param name="delimiters" select="$delimiters"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="str.tokenize.keep.delimiters-delimiters">
          <xsl:with-param name="string" select="$string"/>
          <xsl:with-param name="delimiters" select="substring($delimiters, 2)"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template><xsl:template name="apply-string-subst-map">
      <xsl:param name="content"/>
      <xsl:param name="map.contents"/>
      <xsl:variable name="replaced_text">
        <xsl:call-template name="string.subst">
          <xsl:with-param name="string" select="$content"/>
          <xsl:with-param name="target" select="$map.contents[1]/@oldstring"/>
          <xsl:with-param name="replacement" select="$map.contents[1]/@newstring"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="$map.contents[2]">
          <xsl:call-template name="apply-string-subst-map">
            <xsl:with-param name="content" select="$replaced_text"/>
            <xsl:with-param name="map.contents" select="$map.contents[position() &gt; 1]"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$replaced_text"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:template><xsl:template name="count.uri.path.depth">
  <xsl:param name="filename" select="''"/>
  <xsl:param name="count" select="0"/>

  <xsl:choose>
    <xsl:when test="contains($filename, '/')">
      <xsl:call-template name="count.uri.path.depth">
        <xsl:with-param name="filename" select="substring-after($filename, '/')"/>
        <xsl:with-param name="count" select="$count + 1"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$count"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="trim.common.uri.paths">
  <xsl:param name="uriA" select="''"/>
  <xsl:param name="uriB" select="''"/>
  <xsl:param name="return" select="'A'"/>

  <!-- Resolve any ../ in the path -->
  <xsl:variable name="trimmed.uriA">
    <xsl:call-template name="resolve.path">
      <xsl:with-param name="filename" select="$uriA"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="trimmed.uriB">
    <xsl:call-template name="resolve.path">
      <xsl:with-param name="filename" select="$uriB"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="contains($trimmed.uriA, '/') and contains($trimmed.uriB, '/')                     and substring-before($trimmed.uriA, '/') = substring-before($trimmed.uriB, '/')">
      <xsl:call-template name="trim.common.uri.paths">
        <xsl:with-param name="uriA" select="substring-after($trimmed.uriA, '/')"/>
        <xsl:with-param name="uriB" select="substring-after($trimmed.uriB, '/')"/>
        <xsl:with-param name="return" select="$return"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="$return = 'A'">
          <xsl:value-of select="$trimmed.uriA"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$trimmed.uriB"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="resolve.path">
  <xsl:param name="filename" select="''"/>
  <xsl:choose>
    <!-- Leading .. are not eliminated -->
    <xsl:when test="starts-with($filename, '../')">
      <xsl:value-of select="'../'"/>
      <xsl:call-template name="resolve.path">
        <xsl:with-param name="filename" select="substring-after($filename, '../')"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="contains($filename, '/../')">
      <xsl:call-template name="resolve.path">
        <xsl:with-param name="filename">
          <xsl:call-template name="dirname">
            <xsl:with-param name="filename" select="substring-before($filename, '/../')"/>
          </xsl:call-template>
          <xsl:value-of select="substring-after($filename, '/../')"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$filename"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="dirname">
  <xsl:param name="filename" select="''"/>
  <xsl:if test="contains($filename, '/')">
    <xsl:value-of select="substring-before($filename, '/')"/>
    <xsl:text>/</xsl:text>
    <xsl:call-template name="dirname">
      <xsl:with-param name="filename" select="substring-after($filename, '/')"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template name="trim.text">
    <xsl:param name="contents" select="."/>
    <xsl:variable name="contents-left-trimmed">
      <xsl:call-template name="trim-left">
        <xsl:with-param name="contents" select="$contents"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="contents-trimmed">
      <xsl:call-template name="trim-right">
        <xsl:with-param name="contents" select="$contents-left-trimmed"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:value-of select="$contents-trimmed"/>
  </xsl:template><xsl:template name="trim-left">
    <xsl:param name="contents"/>
    <xsl:choose>
      <xsl:when test="starts-with($contents,'&#10;') or                       starts-with($contents,'&#13;') or                       starts-with($contents,' ') or                       starts-with($contents,'&#9;')">
        <xsl:call-template name="trim-left">
          <xsl:with-param name="contents" select="substring($contents, 2)"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$contents"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template><xsl:template name="trim-right">
    <xsl:param name="contents"/>
    <xsl:variable name="last-char">
      <xsl:value-of select="substring($contents, string-length($contents), 1)"/>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="($last-char = '&#10;') or                       ($last-char = '&#13;') or                       ($last-char = ' ') or                       ($last-char = '&#9;')">
        <xsl:call-template name="trim-right">
          <xsl:with-param name="contents" select="substring($contents, 1, string-length($contents) - 1)"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$contents"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
<xsl:template name="l10n.language">
  <xsl:param name="target" select="."/>
  <xsl:param name="xref-context" select="false()"/>

  <xsl:variable name="mc-language">
    <xsl:choose>
      <xsl:when test="$l10n.gentext.language != ''">
        <xsl:value-of select="$l10n.gentext.language"/>
      </xsl:when>

      <xsl:when test="$xref-context or $l10n.gentext.use.xref.language != 0">
        <!-- can't do this one step: attributes are unordered! -->
        <xsl:variable name="lang-scope" select="$target/ancestor-or-self::*                               [@lang or @xml:lang][1]"/>
        <xsl:variable name="lang-attr" select="($lang-scope/@lang | $lang-scope/@xml:lang)[1]"/>
        <xsl:choose>
          <xsl:when test="string($lang-attr) = ''">
            <xsl:value-of select="$l10n.gentext.default.language"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$lang-attr"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>

      <xsl:otherwise>
        <!-- can't do this one step: attributes are unordered! -->
        <xsl:variable name="lang-scope" select="$target/ancestor-or-self::*                               [@lang or @xml:lang][1]"/>
        <xsl:variable name="lang-attr" select="($lang-scope/@lang | $lang-scope/@xml:lang)[1]"/>

        <xsl:choose>
          <xsl:when test="string($lang-attr) = ''">
            <xsl:value-of select="$l10n.gentext.default.language"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$lang-attr"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="language" select="translate($mc-language,                                         'ABCDEFGHIJKLMNOPQRSTUVWXYZ-',                                         'abcdefghijklmnopqrstuvwxyz_')"/>
</xsl:template>

<xsl:template name="l10n.language.name">
  <xsl:text>English</xsl:text>
</xsl:template>

<xsl:template name="language.attribute">
  <xsl:param name="node" select="."/>

  <xsl:variable name="language">
    <xsl:choose>
      <xsl:when test="$l10n.gentext.language != ''">
        <xsl:value-of select="$l10n.gentext.language"/>
      </xsl:when>

      <xsl:otherwise>
        <!-- can't do this one step: attributes are unordered! -->
        <xsl:variable name="lang-scope" select="$node/ancestor-or-self::*                               [@lang or @xml:lang][1]"/>
        <xsl:variable name="lang-attr" select="($lang-scope/@lang | $lang-scope/@xml:lang)[1]"/>

        <xsl:choose>
          <xsl:when test="string($lang-attr) = ''">
            <xsl:value-of select="$l10n.gentext.default.language"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$lang-attr"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:if test="$language != ''">
    <xsl:attribute name="lang">
      <xsl:choose>
        <xsl:when test="$l10n.lang.value.rfc.compliant != 0">
          <xsl:value-of select="translate($language, '_', '-')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$language"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:attribute>
  </xsl:if>

  <!-- FIXME: This is sort of hack, but it was the easiest way to add at least partial support for dir attribute -->
  <xsl:copy-of select="ancestor-or-self::*[@dir][1]/@dir"/>
</xsl:template>

<xsl:template name="xml.language.attribute">
  <xsl:param name="node" select="."/>

  <xsl:variable name="language">
    <xsl:choose>
      <xsl:when test="$l10n.gentext.language != ''">
        <xsl:value-of select="$l10n.gentext.language"/>
      </xsl:when>

      <xsl:otherwise>
        <!-- can't do this one step: attributes are unordered! -->
        <xsl:variable name="lang-scope" select="$node/ancestor-or-self::*                               [@lang or @xml:lang][1]"/>
        <xsl:variable name="lang-attr" select="($lang-scope/@lang | $lang-scope/@xml:lang)[1]"/>

        <xsl:choose>
          <xsl:when test="string($lang-attr) = ''">
            <xsl:value-of select="$l10n.gentext.default.language"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$lang-attr"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:if test="$language != ''">
    <xsl:attribute name="xml:lang">
      <xsl:choose>
        <xsl:when test="$l10n.lang.value.rfc.compliant != 0">
          <xsl:value-of select="translate($language, '_', '-')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$language"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:attribute>
  </xsl:if>

  <!-- FIXME: This is sort of hack, but it was the easiest way to add at least partial support for dir attribute -->
  <xsl:copy-of select="ancestor-or-self::*[@dir][1]/@dir"/>
</xsl:template>

<xsl:template name="gentext">
  <xsl:param name="key" select="local-name(.)"/>
  <xsl:param name="lang">
    <xsl:call-template name="l10n.language"/>
  </xsl:param>

  <xsl:choose>
    <xsl:when test="$key = 'Abstract'">
      <xsl:text>Abstract</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'abstract'">
      <xsl:text>Abstract</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Acknowledgements'">
      <xsl:text>Acknowledgements</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'acknowledgements'">
      <xsl:text>Acknowledgements</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Answer'">
      <xsl:text>A:</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'answer'">
      <xsl:text>A:</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Appendix'">
      <xsl:text>Appendix</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'appendix'">
      <xsl:text>Appendix</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Article'">
      <xsl:text>Article</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'article'">
      <xsl:text>Article</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Author'">
      <xsl:text>Author</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Bibliography'">
      <xsl:text>Bibliography</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'bibliography'">
      <xsl:text>Bibliography</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Book'">
      <xsl:text>Book</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'book'">
      <xsl:text>Book</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'CAUTION'">
      <xsl:text>CAUTION</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Caution'">
      <xsl:text>Caution</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'caution'">
      <xsl:text>Caution</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Chapter'">
      <xsl:text>Chapter</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'chapter'">
      <xsl:text>Chapter</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Colophon'">
      <xsl:text>Colophon</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'colophon'">
      <xsl:text>Colophon</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Copyright'">
      <xsl:text>Copyright</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'copyright'">
      <xsl:text>Copyright</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Dedication'">
      <xsl:text>Dedication</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'dedication'">
      <xsl:text>Dedication</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Edition'">
      <xsl:text>Edition</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'edition'">
      <xsl:text>Edition</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Editor'">
      <xsl:text>Editor</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Equation'">
      <xsl:text>Equation</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'equation'">
      <xsl:text>Equation</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Example'">
      <xsl:text>Example</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'example'">
      <xsl:text>Example</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Figure'">
      <xsl:text>Figure</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'figure'">
      <xsl:text>Figure</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Glossary'">
      <xsl:text>Glossary</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'glossary'">
      <xsl:text>Glossary</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'GlossSee'">
      <xsl:text>See</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'glosssee'">
      <xsl:text>See</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'GlossSeeAlso'">
      <xsl:text>See Also</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'glossseealso'">
      <xsl:text>See Also</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'IMPORTANT'">
      <xsl:text>IMPORTANT</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'important'">
      <xsl:text>Important</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Important'">
      <xsl:text>Important</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Index'">
      <xsl:text>Index</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'index'">
      <xsl:text>Index</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'ISBN'">
      <xsl:text>ISBN</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'isbn'">
      <xsl:text>ISBN</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'LegalNotice'">
      <xsl:text>Legal Notice</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'legalnotice'">
      <xsl:text>Legal Notice</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'MsgAud'">
      <xsl:text>Audience</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'msgaud'">
      <xsl:text>Audience</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'MsgLevel'">
      <xsl:text>Level</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'msglevel'">
      <xsl:text>Level</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'MsgOrig'">
      <xsl:text>Origin</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'msgorig'">
      <xsl:text>Origin</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'NOTE'">
      <xsl:text>NOTE</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Note'">
      <xsl:text>Note</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'note'">
      <xsl:text>Note</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Part'">
      <xsl:text>Part</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'part'">
      <xsl:text>Part</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Preface'">
      <xsl:text>Preface</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'preface'">
      <xsl:text>Preface</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Procedure'">
      <xsl:text>Procedure</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'procedure'">
      <xsl:text>Procedure</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'ProductionSet'">
      <xsl:text>Production</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'PubDate'">
      <xsl:text>Publication Date</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'pubdate'">
      <xsl:text>Publication date</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Published'">
      <xsl:text>Published</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'published'">
      <xsl:text>Published</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Publisher'">
      <xsl:text>Publisher</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Qandadiv'">
      <xsl:text>Q &amp; A</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'qandadiv'">
      <xsl:text>Q &amp; A</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'QandASet'">
      <xsl:text>Frequently Asked Questions</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Question'">
      <xsl:text>Q:</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'question'">
      <xsl:text>Q:</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'RefEntry'">
      <xsl:text></xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'refentry'">
      <xsl:text></xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Reference'">
      <xsl:text>Reference</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'reference'">
      <xsl:text>Reference</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'References'">
      <xsl:text>References</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'RefName'">
      <xsl:text>Name</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'refname'">
      <xsl:text>Name</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'RefSection'">
      <xsl:text></xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'refsection'">
      <xsl:text></xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'RefSynopsisDiv'">
      <xsl:text>Synopsis</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'refsynopsisdiv'">
      <xsl:text>Synopsis</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'RevHistory'">
      <xsl:text>Revision History</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'revhistory'">
      <xsl:text>Revision History</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'revision'">
      <xsl:text>Revision</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Revision'">
      <xsl:text>Revision</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'sect1'">
      <xsl:text>Section</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'sect2'">
      <xsl:text>Section</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'sect3'">
      <xsl:text>Section</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'sect4'">
      <xsl:text>Section</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'sect5'">
      <xsl:text>Section</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'section'">
      <xsl:text>Section</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Section'">
      <xsl:text>Section</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'see'">
      <xsl:text>see</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'See'">
      <xsl:text>See</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'seealso'">
      <xsl:text>see also</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Seealso'">
      <xsl:text>See also</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'SeeAlso'">
      <xsl:text>See Also</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'set'">
      <xsl:text>Set</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Set'">
      <xsl:text>Set</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'setindex'">
      <xsl:text>Set Index</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'SetIndex'">
      <xsl:text>Set Index</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Sidebar'">
      <xsl:text></xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'sidebar'">
      <xsl:text>sidebar</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'step'">
      <xsl:text>step</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Step'">
      <xsl:text>Step</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'table'">
      <xsl:text>Table</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Table'">
      <xsl:text>Table</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'task'">
      <xsl:text>Task</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Task'">
      <xsl:text>Task</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'tip'">
      <xsl:text>Tip</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'TIP'">
      <xsl:text>TIP</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Tip'">
      <xsl:text>Tip</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Warning'">
      <xsl:text>Warning</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'warning'">
      <xsl:text>Warning</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'WARNING'">
      <xsl:text>WARNING</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'and'">
      <xsl:text>and</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'or'">
      <xsl:text>or</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'by'">
      <xsl:text>by</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Edited'">
      <xsl:text>Edited</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'edited'">
      <xsl:text>Edited</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Editedby'">
      <xsl:text>Edited by</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'editedby'">
      <xsl:text>Edited by</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'in'">
      <xsl:text>in</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'lastlistcomma'">
      <xsl:text>,</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'listcomma'">
      <xsl:text>,</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'notes'">
      <xsl:text>Notes</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Notes'">
      <xsl:text>Notes</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Pgs'">
      <xsl:text>Pgs.</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'pgs'">
      <xsl:text>Pgs.</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Revisedby'">
      <xsl:text>Revised by: </xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'revisedby'">
      <xsl:text>Revised by: </xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'TableNotes'">
      <xsl:text>Notes</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'tablenotes'">
      <xsl:text>Notes</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'TableofContents'">
      <xsl:text>Table of Contents</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'tableofcontents'">
      <xsl:text>Table of Contents</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'unexpectedelementname'">
      <xsl:text>Unexpected element name</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'unsupported'">
      <xsl:text>unsupported</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'xrefto'">
      <xsl:text>xref to</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Authors'">
      <xsl:text>Authors</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'copyeditor'">
      <xsl:text>Copy Editor</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'graphicdesigner'">
      <xsl:text>Graphic Designer</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'productioneditor'">
      <xsl:text>Production Editor</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'technicaleditor'">
      <xsl:text>Technical Editor</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'translator'">
      <xsl:text>Translator</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'listofequations'">
      <xsl:text>List of Equations</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'ListofEquations'">
      <xsl:text>List of Equations</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'ListofExamples'">
      <xsl:text>List of Examples</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'listofexamples'">
      <xsl:text>List of Examples</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'ListofFigures'">
      <xsl:text>List of Figures</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'listoffigures'">
      <xsl:text>List of Figures</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'ListofProcedures'">
      <xsl:text>List of Procedures</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'listofprocedures'">
      <xsl:text>List of Procedures</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'listoftables'">
      <xsl:text>List of Tables</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'ListofTables'">
      <xsl:text>List of Tables</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'ListofUnknown'">
      <xsl:text>List of Unknown</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'listofunknown'">
      <xsl:text>List of Unknown</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'nav-home'">
      <xsl:text>Home</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'nav-next'">
      <xsl:text>Next</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'nav-next-sibling'">
      <xsl:text>Fast Forward</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'nav-prev'">
      <xsl:text>Prev</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'nav-prev-sibling'">
      <xsl:text>Fast Backward</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'nav-up'">
      <xsl:text>Up</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'nav-toc'">
      <xsl:text>ToC</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'Draft'">
      <xsl:text>Draft</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'above'">
      <xsl:text>above</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'below'">
      <xsl:text>below</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'sectioncalled'">
      <xsl:text>the section called</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'index symbols'">
      <xsl:text>Symbols</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'writing-mode'">
      <xsl:text>lr-tb</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'lowercase.alpha'">
      <xsl:text>abcdefghijklmnopqrstuvwxyz</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'uppercase.alpha'">
      <xsl:text>ABCDEFGHIJKLMNOPQRSTUVWXYZ</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'normalize.sort.input'">
       <xsl:text>AaÃ€Ã ÃÃ¡Ã‚Ã¢ÃƒÃ£Ã„Ã¤Ã…Ã¥Ä€ÄÄ‚ÄƒÄ„Ä…ÇÇŽÇžÇŸÇ Ç¡ÇºÇ»È€ÈÈ‚ÈƒÈ¦È§á¸€á¸áºšáº áº¡áº¢áº£áº¤áº¥áº¦áº§áº¨áº©áºªáº«áº¬áº­áº®áº¯áº°áº±áº²áº³áº´áºµáº¶áº·BbÆ€ÆÉ“Æ‚Æƒá¸‚á¸ƒá¸„á¸…á¸†á¸‡CcÃ‡Ã§Ä†Ä‡ÄˆÄ‰ÄŠÄ‹ÄŒÄÆ‡ÆˆÉ•á¸ˆá¸‰DdÄŽÄÄÄ‘ÆŠÉ—Æ‹ÆŒÇ…Ç²È¡É–á¸Šá¸‹á¸Œá¸á¸Žá¸á¸á¸‘á¸’á¸“EeÃˆÃ¨Ã‰Ã©ÃŠÃªÃ‹Ã«Ä’Ä“Ä”Ä•Ä–Ä—Ä˜Ä™ÄšÄ›È„È…È†È‡È¨È©á¸”á¸•á¸–á¸—á¸˜á¸™á¸šá¸›á¸œá¸áº¸áº¹áººáº»áº¼áº½áº¾áº¿á»€á»á»‚á»ƒá»„á»…á»†á»‡FfÆ‘Æ’á¸žá¸ŸGgÄœÄÄžÄŸÄ Ä¡Ä¢Ä£Æ“É Ç¤Ç¥Ç¦Ç§Ç´Çµá¸ á¸¡HhÄ¤Ä¥Ä¦Ä§ÈžÈŸÉ¦á¸¢á¸£á¸¤á¸¥á¸¦á¸§á¸¨á¸©á¸ªá¸«áº–IiÃŒÃ¬ÃÃ­ÃŽÃ®ÃÃ¯Ä¨Ä©ÄªÄ«Ä¬Ä­Ä®Ä¯Ä°Æ—É¨ÇÇÈˆÈ‰ÈŠÈ‹á¸¬á¸­á¸®á¸¯á»ˆá»‰á»Šá»‹JjÄ´ÄµÇ°ÊKkÄ¶Ä·Æ˜Æ™Ç¨Ç©á¸°á¸±á¸²á¸³á¸´á¸µLlÄ¹ÄºÄ»Ä¼Ä½Ä¾Ä¿Å€ÅÅ‚ÆšÇˆÈ´É«É¬É­á¸¶á¸·á¸¸á¸¹á¸ºá¸»á¸¼á¸½MmÉ±á¸¾á¸¿á¹€á¹á¹‚á¹ƒNnÃ‘Ã±ÅƒÅ„Å…Å†Å‡ÅˆÆÉ²ÆžÈ Ç‹Ç¸Ç¹ÈµÉ³á¹„á¹…á¹†á¹‡á¹ˆá¹‰á¹Šá¹‹OoÃ’Ã²Ã“Ã³Ã”Ã´Ã•ÃµÃ–Ã¶Ã˜Ã¸ÅŒÅÅŽÅÅÅ‘ÆŸÆ Æ¡Ç‘Ç’ÇªÇ«Ç¬Ç­Ç¾Ç¿ÈŒÈÈŽÈÈªÈ«È¬È­È®È¯È°È±á¹Œá¹á¹Žá¹á¹á¹‘á¹’á¹“á»Œá»á»Žá»á»á»‘á»’á»“á»”á»•á»–á»—á»˜á»™á»šá»›á»œá»á»žá»Ÿá» á»¡á»¢á»£PpÆ¤Æ¥á¹”á¹•á¹–á¹—QqÊ RrÅ”Å•Å–Å—Å˜Å™ÈÈ‘È’È“É¼É½É¾á¹˜á¹™á¹šá¹›á¹œá¹á¹žá¹ŸSsÅšÅ›ÅœÅÅžÅŸÅ Å¡È˜È™Ê‚á¹ á¹¡á¹¢á¹£á¹¤á¹¥á¹¦á¹§á¹¨á¹©TtÅ¢Å£Å¤Å¥Å¦Å§Æ«Æ¬Æ­Æ®ÊˆÈšÈ›È¶á¹ªá¹«á¹¬á¹­á¹®á¹¯á¹°á¹±áº—UuÃ™Ã¹ÃšÃºÃ›Ã»ÃœÃ¼Å¨Å©ÅªÅ«Å¬Å­Å®Å¯Å°Å±Å²Å³Æ¯Æ°Ç“Ç”Ç•Ç–Ç—Ç˜Ç™ÇšÇ›ÇœÈ”È•È–È—á¹²á¹³á¹´á¹µá¹¶á¹·á¹¸á¹¹á¹ºá¹»á»¤á»¥á»¦á»§á»¨á»©á»ªá»«á»¬á»­á»®á»¯á»°á»±VvÆ²Ê‹á¹¼á¹½á¹¾á¹¿WwÅ´Åµáº€áºáº‚áºƒáº„áº…áº†áº‡áºˆáº‰áº˜XxáºŠáº‹áºŒáºYyÃÃ½Ã¿Å¸Å¶Å·Æ³Æ´È²È³áºŽáºáº™á»²á»³á»´á»µá»¶á»·á»¸á»¹ZzÅ¹ÅºÅ»Å¼Å½Å¾ÆµÆ¶È¤È¥ÊÊ‘áºáº‘áº’áº“áº”áº•áº•</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'normalize.sort.output'">
      <xsl:text>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'hyphenation-character'">
      <xsl:text>-</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'hyphenation-push-character-count'">2</xsl:when>
    <xsl:when test="$key = 'hyphenation-remain-character-count'">2</xsl:when>
    <xsl:otherwise />
  </xsl:choose>
</xsl:template>

<xsl:template name="gentext.element.name">
  <xsl:param name="element.name" select="local-name(.)"/>
  <xsl:param name="lang">
    <xsl:call-template name="l10n.language"/>
  </xsl:param>

  <xsl:call-template name="gentext">
    <xsl:with-param name="key" select="$element.name"/>
    <xsl:with-param name="lang" select="$lang"/>
  </xsl:call-template>
</xsl:template>

<xsl:template name="gentext.space">
  <xsl:text> </xsl:text>
</xsl:template>

<xsl:template name="gentext.edited.by">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key" select="'Editedby'"/>
  </xsl:call-template>
</xsl:template>

<xsl:template name="gentext.by">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key" select="'by'"/>
  </xsl:call-template>
</xsl:template>

<xsl:template name="gentext.dingbat">
  <xsl:param name="dingbat">bullet</xsl:param>
  <xsl:param name="lang">
    <xsl:call-template name="l10n.language"/>
  </xsl:param>

  <xsl:choose>
    <xsl:when test="$key = 'startquote'">
      <xsl:text>â€œ</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'endquote'">
      <xsl:text>â€</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'nestedstartquote'">
      <xsl:text>â€˜</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'nestedendquote'">
      <xsl:text>â€™</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'singlestartquote'">
      <xsl:text>â€˜</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'singleendquote'">
      <xsl:text>â€™</xsl:text>
    </xsl:when>
    <xsl:when test="$key = 'bullet'">
      <xsl:text>â€¢</xsl:text>
    </xsl:when>
    <xsl:otherwise />
  </xsl:choose>
</xsl:template>

<xsl:template name="gentext.startquote">
  <xsl:call-template name="gentext.dingbat">
    <xsl:with-param name="dingbat">startquote</xsl:with-param>
  </xsl:call-template>
</xsl:template>

<xsl:template name="gentext.endquote">
  <xsl:call-template name="gentext.dingbat">
    <xsl:with-param name="dingbat">endquote</xsl:with-param>
  </xsl:call-template>
</xsl:template>

<xsl:template name="gentext.nestedstartquote">
  <xsl:call-template name="gentext.dingbat">
    <xsl:with-param name="dingbat">nestedstartquote</xsl:with-param>
  </xsl:call-template>
</xsl:template>

<xsl:template name="gentext.nestedendquote">
  <xsl:call-template name="gentext.dingbat">
    <xsl:with-param name="dingbat">nestedendquote</xsl:with-param>
  </xsl:call-template>
</xsl:template>

<xsl:template name="gentext.nav.prev">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key" select="'nav-prev'"/>
  </xsl:call-template>
</xsl:template>

<xsl:template name="gentext.nav.next">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key" select="'nav-next'"/>
  </xsl:call-template>
</xsl:template>

<xsl:template name="gentext.nav.home">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key" select="'nav-home'"/>
  </xsl:call-template>
</xsl:template>

<xsl:template name="gentext.nav.up">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key" select="'nav-up'"/>
  </xsl:call-template>
</xsl:template>

<xsl:template name="gentext.template">
  <xsl:param name="context" select="'default'"/>
  <xsl:param name="name" select="'default'"/>
  <xsl:param name="origname" select="$name"/>
  <xsl:param name="purpose"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="referrer"/>
  <xsl:param name="lang">
    <xsl:call-template name="l10n.language"/>
  </xsl:param>
  <xsl:param name="verbose" select="1"/>

  <xsl:choose>
    <!-- keycap context -->
    <xsl:when test="$context = 'keycap' and $name = 'alt'">Alt</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'backspace'">&lt;â€”</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'command'">âŒ˜</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'control'">Ctrl</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'delete'">Del</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'down'">â†“</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'end'">End</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'enter'">Enter</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'escape'">Esc</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'home'">Home</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'insert'">Ins</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'left'">â†</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'meta'">Meta</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'option'">???</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'pagedown'">Page â†“</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'pageup'">Page â†‘</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'right'">â†’</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'shift'">Shift</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'space'">Space</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'tab'">â†’|</xsl:when>
    <xsl:when test="$context = 'keycap' and $name = 'up'">â†‘</xsl:when>

    <!-- webhelp context -->
    <xsl:when test="$context = 'webhelp' and $name = 'Search'">Search</xsl:when>
    <xsl:when test="$context = 'webhelp' and $name = 'Enter_a_term_and_click'">Enter a term and click </xsl:when>
    <xsl:when test="$context = 'webhelp' and $name = 'Go'">Go</xsl:when>
    <xsl:when test="$context = 'webhelp' and $name = 'to_perform_a_search'"> to perform a search.</xsl:when>
    <xsl:when test="$context = 'webhelp' and $name = 'txt_filesfound'">Results</xsl:when>
    <xsl:when test="$context = 'webhelp' and $name = 'txt_enter_at_least_1_char'">You must enter at least one character.</xsl:when>
    <xsl:when test="$context = 'webhelp' and $name = 'txt_browser_not_supported'">JavaScript is disabled on your browser. Please enable JavaScript to enjoy all the features of this site.</xsl:when>
    <xsl:when test="$context = 'webhelp' and $name = 'txt_please_wait'">Please wait. Search in progress...</xsl:when>
    <xsl:when test="$context = 'webhelp' and $name = 'txt_results_for'">Results for: </xsl:when>
    <xsl:when test="$context = 'webhelp' and $name = 'TableofContents'">Contents</xsl:when>
    <xsl:when test="$context = 'webhelp' and $name = 'HighlightButton'">Toggle search result highlighting</xsl:when>
    <xsl:when test="$context = 'webhelp' and $name = 'Your_search_returned_no_results'">Your search returned no results.</xsl:when>

    <!-- styles context -->
    <xsl:when test="$context = 'styles' and $name = 'person-name'">first-last</xsl:when>

    <!-- title context -->
    <xsl:when test="$context = 'title' and $name = 'abstract'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'acknowledgements'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'answer'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'appendix'">AppendixÂ %n.Â %t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'article'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'authorblurb'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'bibliodiv'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'biblioentry'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'bibliography'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'bibliolist'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'bibliomixed'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'bibliomset'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'biblioset'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'blockquote'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'book'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'calloutlist'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'caution'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'chapter'">ChapterÂ %n.Â %t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'colophon'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'dedication'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'equation'">EquationÂ %n.Â %t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'example'">ExampleÂ %n.Â %t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'figure'">FigureÂ %n.Â %t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'foil'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'foilgroup'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'formalpara'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'glossary'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'glossdiv'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'glosslist'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'glossentry'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'important'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'index'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'indexdiv'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'itemizedlist'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'legalnotice'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'listitem'"></xsl:when>
    <xsl:when test="$context = 'title' and $name = 'lot'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'msg'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'msgexplan'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'msgmain'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'msgrel'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'msgset'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'msgsub'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'note'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'orderedlist'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'part'">PartÂ %n.Â %t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'partintro'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'preface'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'procedure'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'procedure.formal'">ProcedureÂ %n.Â %t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'productionset'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'productionset.formal'">ProductionÂ %n</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'qandadiv'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'qandaentry'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'qandaset'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'question'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'refentry'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'reference'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'refsection'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'refsect1'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'refsect2'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'refsect3'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'refsynopsisdiv'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'refsynopsisdivinfo'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'screenshot'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'segmentedlist'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'set'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'setindex'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'sidebar'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'step'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'table'">TableÂ %n.Â %t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'task'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'tasksummary'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'taskprerequisites'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'taskrelated'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'tip'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'toc'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'variablelist'">%t</xsl:when>
    <xsl:when test="$context = 'title' and $name = 'varlistentry'"></xsl:when>
    <xsl:when test="$context = 'title' and $name = 'warning'">%t</xsl:when>

    <!-- title-unnumbered context -->
    <xsl:when test="$context = 'title-unnumbered' and $name = 'appendix'">%t</xsl:when>
    <xsl:when test="$context = 'title-unnumbered' and $name = 'article/appendix'">%t</xsl:when>
    <xsl:when test="$context = 'title-unnumbered' and $name = 'bridgehead'">%t</xsl:when>
    <xsl:when test="$context = 'title-unnumbered' and $name = 'chapter'">%t</xsl:when>
    <xsl:when test="$context = 'title-unnumbered' and $name = 'sect1'">%t</xsl:when>
    <xsl:when test="$context = 'title-unnumbered' and $name = 'sect2'">%t</xsl:when>
    <xsl:when test="$context = 'title-unnumbered' and $name = 'sect3'">%t</xsl:when>
    <xsl:when test="$context = 'title-unnumbered' and $name = 'sect4'">%t</xsl:when>
    <xsl:when test="$context = 'title-unnumbered' and $name = 'sect5'">%t</xsl:when>
    <xsl:when test="$context = 'title-unnumbered' and $name = 'section'">%t</xsl:when>
    <xsl:when test="$context = 'title-unnumbered' and $name = 'simplesect'">%t</xsl:when>
    <xsl:when test="$context = 'title-unnumbered' and $name = 'topic'">%t</xsl:when>
    <xsl:when test="$context = 'title-unnumbered' and $name = 'part'">%t</xsl:when>

    <!-- title-numbered context -->
    <xsl:when test="$context = 'title-numbered' and $name = 'appendix'">AppendixÂ %n.Â %t</xsl:when>
    <xsl:when test="$context = 'title-numbered' and $name = 'article/appendix'">%n.Â %t</xsl:when>
    <xsl:when test="$context = 'title-numbered' and $name = 'bridgehead'">%n.Â %t</xsl:when>
    <xsl:when test="$context = 'title-numbered' and $name = 'chapter'">ChapterÂ %n.Â %t</xsl:when>
    <xsl:when test="$context = 'title-numbered' and $name = 'part'">PartÂ %n.Â %t</xsl:when>
    <xsl:when test="$context = 'title-numbered' and $name = 'sect1'">%n.Â %t</xsl:when>
    <xsl:when test="$context = 'title-numbered' and $name = 'sect2'">%n.Â %t</xsl:when>
    <xsl:when test="$context = 'title-numbered' and $name = 'sect3'">%n.Â %t</xsl:when>
    <xsl:when test="$context = 'title-numbered' and $name = 'sect4'">%n.Â %t</xsl:when>
    <xsl:when test="$context = 'title-numbered' and $name = 'sect5'">%n.Â %t</xsl:when>
    <xsl:when test="$context = 'title-numbered' and $name = 'section'">%n.Â %t</xsl:when>
    <xsl:when test="$context = 'title-numbered' and $name = 'simplesect'">%t</xsl:when>
    <xsl:when test="$context = 'title-numbered' and $name = 'topic'">%t</xsl:when>

    <!-- subtitle context-->
    <xsl:when test="$context = 'subtitle' and $name = 'appendix'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'acknowledgements'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'article'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'bibliodiv'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'biblioentry'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'bibliography'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'bibliomixed'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'bibliomset'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'biblioset'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'book'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'chapter'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'colophon'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'dedication'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'glossary'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'glossdiv'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'index'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'indexdiv'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'lot'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'part'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'partintro'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'preface'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'refentry'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'reference'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'refsection'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'refsect1'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'refsect2'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'refsect3'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'refsynopsisdiv'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'sect1'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'sect2'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'sect3'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'sect4'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'sect5'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'section'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'set'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'setindex'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'sidebar'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'simplesect'">%s</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'topic'">%t</xsl:when>
    <xsl:when test="$context = 'subtitle' and $name = 'toc'">%s</xsl:when>

    <!-- xref context -->
    <xsl:when test="$context = 'xref' and $name = 'abstract'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'acknowledgements'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'answer'">A:Â %n</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'appendix'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'article'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'authorblurb'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'bibliodiv'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'bibliography'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'bibliomset'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'biblioset'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'blockquote'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'book'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'calloutlist'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'caution'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'chapter'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'colophon'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'constraintdef'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'dedication'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'equation'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'example'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'figure'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'foil'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'foilgroup'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'formalpara'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'glossary'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'glossdiv'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'important'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'index'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'indexdiv'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'itemizedlist'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'legalnotice'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'listitem'">%n</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'lot'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'msg'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'msgexplan'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'msgmain'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'msgrel'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'msgset'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'msgsub'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'note'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'orderedlist'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'part'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'partintro'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'preface'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'procedure'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'productionset'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'qandadiv'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'qandaentry'">Q:Â %n</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'qandaset'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'question'">Q:Â %n</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'reference'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'refsynopsisdiv'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'screenshot'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'segmentedlist'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'set'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'setindex'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'sidebar'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'table'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'task'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'tip'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'toc'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'variablelist'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'varlistentry'">%n</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'warning'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'olink.document.citation'"> in %o</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'olink.page.citation'"> (page %p)</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'page.citation'"> [%p]</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'page'">(page %p)</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'docname'"> in %o</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'docnamelong'"> in the document titled %o</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'pageabbrev'">(p. %p)</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'Page'">Page %p</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'topic'">%t</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'bridgehead'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'refsection'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'refsect1'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'refsect2'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'refsect3'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'sect1'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'sect2'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'sect3'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'sect4'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'sect5'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'section'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref' and $name = 'simplesect'">the section called â€œ%tâ€</xsl:when>

    <!-- xref-number context -->
    <xsl:when test="$context = 'xref-number' and $name = 'answer'">A:Â %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'appendix'">AppendixÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'bridgehead'">SectionÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'chapter'">ChapterÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'equation'">EquationÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'example'">ExampleÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'figure'">FigureÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'part'">PartÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'procedure'">ProcedureÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'productionset'">ProductionÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'qandadiv'">Q &amp; AÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'qandaentry'">Q:Â %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'question'">Q:Â %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'sect1'">SectionÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'sect2'">SectionÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'sect3'">SectionÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'sect4'">SectionÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'sect5'">SectionÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'section'">SectionÂ %n</xsl:when>
    <xsl:when test="$context = 'xref-number' and $name = 'table'">TableÂ %n</xsl:when>

    <!-- xref-number-and-title context -->
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'appendix'">AppendixÂ %n, %t</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'bridgehead'">SectionÂ %n, â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'chapter'">ChapterÂ %n, %t</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'equation'">EquationÂ %n, â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'example'">ExampleÂ %n, â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'figure'">FigureÂ %n, â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'part'">PartÂ %n, â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'procedure'">ProcedureÂ %n, â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'productionset'">ProductionÂ %n, â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'qandadiv'">Q &amp; AÂ %n, â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'refsect1'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'refsect2'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'refsect3'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'refsection'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'sect1'">SectionÂ %n, â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'sect2'">SectionÂ %n, â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'sect3'">SectionÂ %n, â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'sect4'">SectionÂ %n, â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'sect5'">SectionÂ %n, â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'section'">SectionÂ %n, â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'simplesect'">the section called â€œ%tâ€</xsl:when>
    <xsl:when test="$context = 'xref-number-and-title' and $name = 'table'">TableÂ %n, â€œ%tâ€</xsl:when>

    <!-- authorgroup context -->
    <xsl:when test="$context = 'authorgroup' and $name = 'sep'">, </xsl:when>
    <xsl:when test="$context = 'authorgroup' and $name = 'sep2'"> and </xsl:when>
    <xsl:when test="$context = 'authorgroup' and $name = 'seplast'">, and </xsl:when>

    <!-- glossary context -->
    <xsl:when test="$context = 'glossary' and $name = 'see'">See %t.</xsl:when>
    <xsl:when test="$context = 'glossary' and $name = 'seealso'">See Also %t.</xsl:when>
    <xsl:when test="$context = 'glossary' and $name = 'seealso-separator'">, </xsl:when>

    <!-- msgset context -->
    <xsl:when test="$context = 'msgset' and $name = 'MsgAud'">Audience: </xsl:when>
    <xsl:when test="$context = 'msgset' and $name = 'MsgLevel'">Level: </xsl:when>
    <xsl:when test="$context = 'msgset' and $name = 'MsgOrig'">Origin: </xsl:when>

    <!-- datetime context -->
    <xsl:when test="$context = 'datetime' and $name = 'format'">m/d/Y</xsl:when>

    <!-- termdef context -->
    <xsl:when test="$context = 'termdef' and $name = 'prefix'">[Definition: </xsl:when>
    <xsl:when test="$context = 'termdef' and $name = 'suffix'">]</xsl:when>

    <!-- datetime-full context -->
    <xsl:when test="$context = 'datetime-full' and $name = 'January'">January</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'February'">February</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'March'">March</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'April'">April</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'May'">May</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'June'">June</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'July'">July</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'August'">August</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'September'">September</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'October'">October</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'November'">November</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'December'">December</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'Monday'">Monday</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'Tuesday'">Tuesday</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'Wednesday'">Wednesday</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'Thursday'">Thursday</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'Friday'">Friday</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'Saturday'">Saturday</xsl:when>
    <xsl:when test="$context = 'datetime-full' and $name = 'Sunday'">Sunday</xsl:when>

    <!-- datetime-abbrev context -->
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Jan'">Jan</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Feb'">Feb</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Mar'">Mar</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Apr'">Apr</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'May'">May</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Jun'">Jun</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Jul'">Jul</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Aug'">Aug</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Sep'">Sep</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Oct'">Oct</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Nov'">Nov</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Dec'">Dec</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Mon'">Mon</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Tue'">Tue</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Wed'">Wed</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Thu'">Thu</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Fri'">Fri</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Sat'">Sat</xsl:when>
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'Sun'">Sun</xsl:when>

    <!-- htmlhelp context -->
    <xsl:when test="$context = 'datetime-abbrev' and $name = 'langcode'">0x0409 English (UNITED STATES)</xsl:when>

    <!-- index context -->
    <xsl:when test="$context = 'index' and $name = 'term-separator'">, </xsl:when>
    <xsl:when test="$context = 'index' and $name = 'number-separator'">, </xsl:when>
    <xsl:when test="$context = 'index' and $name = 'range-separator'">-</xsl:when>

    <!-- iso690 context -->
        <xsl:when test="$context = 'iso960' and $name = 'lastfirst.sep'">, </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'alt.person.two.sep'"> â€“ </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'alt.person.last.sep'"> â€“ </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'alt.person.more.sep'"> â€“ </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'primary.editor'"> (ed.)</xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'primary.many'">, et al.</xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'primary.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'submaintitle.sep'">: </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'title.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'othertitle.sep'">, </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'medium1'"> [</xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'medium2'">]</xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'secondary.person.sep'">; </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'secondary.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'respons.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'edition.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'edition.serial.sep'">, </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'issuing.range'">-</xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'issuing.div'">, </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'issuing.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'partnr.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'placepubl.sep'">: </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'publyear.sep'">, </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'pubinfo.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'spec.pubinfo.sep'">, </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'upd.sep'">, </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'datecit1'"> [cited </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'datecit2'">]</xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'extent.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'locs.sep'">, </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'location.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'serie.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'notice.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'access'">Available </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'acctoo'">Also available </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'onwww'">from World Wide Web</xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'oninet'">from Internet</xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'access.end'">: </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'link1'">&lt;</xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'link2'">&gt;</xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'access.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'isbn'">ISBN </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'issn'">ISSN </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'stdnum.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'patcountry.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'pattype.sep'">, </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'patnum.sep'">. </xsl:when>
    <xsl:when test="$context = 'iso960' and $name = 'patdate.sep'">. </xsl:when>

    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="contains($name, '/')">
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="$context"/>
            <xsl:with-param name="name" select="substring-after($name, '/')"/>
            <xsl:with-param name="origname" select="$origname"/>
            <xsl:with-param name="purpose" select="$purpose"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="lang" select="$lang"/>
            <xsl:with-param name="verbose" select="$verbose"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="$verbose = 0">
          <!-- silence -->
        </xsl:when>
        <xsl:otherwise>
          <xsl:message>
            <xsl:text>No template for "</xsl:text>
            <xsl:value-of select="$origname"/>
            <xsl:text>" (or any of its leaves) exists in the context named "</xsl:text>
            <xsl:value-of select="$context"/>
            <xsl:text>" in the "</xsl:text>
            <xsl:value-of select="$lang"/>
            <xsl:text>" localization.</xsl:text>
          </xsl:message>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="gentext.template.exists">
  <xsl:param name="context" select="'default'"/>
  <xsl:param name="name" select="'default'"/>
  <xsl:param name="origname" select="$name"/>
  <xsl:param name="purpose"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="referrer"/>
  <xsl:param name="lang">
    <xsl:call-template name="l10n.language"/>
  </xsl:param>

  <xsl:variable name="template">
    <xsl:call-template name="gentext.template">
      <xsl:with-param name="context" select="$context"/>
      <xsl:with-param name="name" select="$name"/>
      <xsl:with-param name="origname" select="$origname"/>
      <xsl:with-param name="purpose" select="$purpose"/>
      <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
      <xsl:with-param name="referrer" select="$referrer"/>
      <xsl:with-param name="lang" select="$lang"/>
      <xsl:with-param name="verbose" select="0"/>
    </xsl:call-template>
  </xsl:variable>
  
  <xsl:choose>
    <xsl:when test="string-length($template) != 0">1</xsl:when>
    <xsl:otherwise>0</xsl:otherwise>
  </xsl:choose>
</xsl:template>
<doc:reference xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" xml:id="base">
  <info>
    <title>Common Â» Base Template Reference</title>
    <releaseinfo role="meta">
      $Id: common.xsl 9347 2012-05-11 03:49:49Z bobstayton $
    </releaseinfo>
  </info>
  <!-- * yes, partintro is a valid child of a reference... -->
  <partintro xml:id="partintro">
    <title>Introduction</title>
    <para>This is technical reference documentation for the â€œbaseâ€
      set of common templates in the DocBook XSL Stylesheets.</para>
    <para>This is not intended to be user documentation. It is
      provided for developers writing customization layers for the
      stylesheets.</para>
  </partintro>
</doc:reference><xsl:preserve-space elements="*"/><xsl:strip-space elements=" abstract affiliation anchor answer appendix area areaset areaspec artheader article audiodata audioobject author authorblurb authorgroup beginpage bibliodiv biblioentry bibliography biblioset blockquote book bookinfo callout calloutlist caption caution chapter citerefentry cmdsynopsis co collab colophon colspec confgroup copyright dedication docinfo editor entrytbl epigraph equation example figure footnote footnoteref formalpara funcprototype funcsynopsis glossary glossdef glossdiv glossentry glosslist graphicco group highlights imagedata imageobject imageobjectco important index indexdiv indexentry indexterm info informalequation informalexample informalfigure informaltable inlineequation inlinemediaobject itemizedlist itermset keycombo keywordset legalnotice listitem lot mediaobject mediaobjectco menuchoice msg msgentry msgexplan msginfo msgmain msgrel msgset msgsub msgtext note objectinfo orderedlist othercredit part partintro preface printhistory procedure programlistingco publisher qandadiv qandaentry qandaset question refentry reference refmeta refnamediv refsection refsect1 refsect1info refsect2 refsect2info refsect3 refsect3info refsynopsisdiv refsynopsisdivinfo revhistory revision row sbr screenco screenshot sect1 sect1info sect2 sect2info sect3 sect3info sect4 sect4info sect5 sect5info section sectioninfo seglistitem segmentedlist seriesinfo set setindex setinfo shortcut sidebar simplelist simplesect spanspec step subject subjectset substeps synopfragment table tbody textobject tfoot tgroup thead tip toc tocchap toclevel1 toclevel2 toclevel3 toclevel4 toclevel5 tocpart topic varargs variablelist varlistentry videodata videoobject void warning subjectset  classsynopsis constructorsynopsis destructorsynopsis fieldsynopsis methodparam methodsynopsis ooclass ooexception oointerface simplemsgentry manvolnum "/><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="is.component">
<refpurpose>Tests if a given node is a component-level element</refpurpose>

<refdescription id="is.component-desc">
<para>This template returns '1' if the specified node is a component
(Chapter, Appendix, etc.), and '0' otherwise.</para>
</refdescription>

<refparameter id="is.component-params">
<variablelist>
<varlistentry><term>node</term>
<listitem>
<para>The node which is to be tested.</para>
</listitem>
</varlistentry>
</variablelist>
</refparameter>

<refreturn id="is.component-returns">
<para>This template returns '1' if the specified node is a component
(Chapter, Appendix, etc.), and '0' otherwise.</para>
</refreturn>
</doc:template><xsl:template name="is.component">
  <xsl:param name="node" select="."/>
  <xsl:choose>
    <xsl:when test="local-name($node) = 'appendix'                     or local-name($node) = 'article'                     or local-name($node) = 'chapter'                     or local-name($node) = 'preface'                     or local-name($node) = 'bibliography'                     or local-name($node) = 'glossary'                     or local-name($node) = 'index'">1</xsl:when>
    <xsl:otherwise>0</xsl:otherwise>
  </xsl:choose>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="is.section">
<refpurpose>Tests if a given node is a section-level element</refpurpose>

<refdescription id="is.section-desc">
<para>This template returns '1' if the specified node is a section
(Section, Sect1, Sect2, etc.), and '0' otherwise.</para>
</refdescription>

<refparameter id="is.section-params">
<variablelist>
<varlistentry><term>node</term>
<listitem>
<para>The node which is to be tested.</para>
</listitem>
</varlistentry>
</variablelist>
</refparameter>

<refreturn id="is.section-returns">
<para>This template returns '1' if the specified node is a section
(Section, Sect1, Sect2, etc.), and '0' otherwise.</para>
</refreturn>
</doc:template><xsl:template name="is.section">
  <xsl:param name="node" select="."/>
  <xsl:choose>
    <xsl:when test="local-name($node) = 'section'                     or local-name($node) = 'sect1'                     or local-name($node) = 'sect2'                     or local-name($node) = 'sect3'                     or local-name($node) = 'sect4'                     or local-name($node) = 'sect5'                     or local-name($node) = 'refsect1'                     or local-name($node) = 'refsect2'                     or local-name($node) = 'refsect3'                     or local-name($node) = 'simplesect'">1</xsl:when>
    <xsl:otherwise>0</xsl:otherwise>
  </xsl:choose>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="section.level">
<refpurpose>Returns the hierarchical level of a section</refpurpose>

<refdescription id="section.level-desc">
<para>This template calculates the hierarchical level of a section.
The element <tag>sect1</tag> is at level 1, <tag>sect2</tag> is
at level 2, etc.</para>

<para>Recursive sections are calculated down to the fifth level.</para>
</refdescription>

<refparameter id="section.level-params">
<variablelist>
<varlistentry><term>node</term>
<listitem>
<para>The section node for which the level should be calculated.
Defaults to the context node.</para>
</listitem>
</varlistentry>
</variablelist>
</refparameter>

<refreturn id="section.level-returns">
<para>The section level, <quote>1</quote>, <quote>2</quote>, etc.
</para>
</refreturn>
</doc:template><xsl:template name="section.level">
  <xsl:param name="node" select="."/>
  <xsl:choose>
    <xsl:when test="local-name($node)='sect1'">1</xsl:when>
    <xsl:when test="local-name($node)='sect2'">2</xsl:when>
    <xsl:when test="local-name($node)='sect3'">3</xsl:when>
    <xsl:when test="local-name($node)='sect4'">4</xsl:when>
    <xsl:when test="local-name($node)='sect5'">5</xsl:when>
    <xsl:when test="local-name($node)='section'">
      <xsl:choose>
        <xsl:when test="$node/../../../../../../section">6</xsl:when>
        <xsl:when test="$node/../../../../../section">5</xsl:when>
        <xsl:when test="$node/../../../../section">4</xsl:when>
        <xsl:when test="$node/../../../section">3</xsl:when>
        <xsl:when test="$node/../../section">2</xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:when test="local-name($node)='refsect1' or                     local-name($node)='refsect2' or                     local-name($node)='refsect3' or                     local-name($node)='refsection' or                     local-name($node)='refsynopsisdiv'">
      <xsl:call-template name="refentry.section.level">
        <xsl:with-param name="node" select="$node"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="local-name($node)='simplesect'">
      <xsl:choose>
        <xsl:when test="$node/../../sect1">2</xsl:when>
        <xsl:when test="$node/../../sect2">3</xsl:when>
        <xsl:when test="$node/../../sect3">4</xsl:when>
        <xsl:when test="$node/../../sect4">5</xsl:when>
        <xsl:when test="$node/../../sect5">5</xsl:when>
        <xsl:when test="$node/../../section">
          <xsl:choose>
            <xsl:when test="$node/../../../../../section">5</xsl:when>
            <xsl:when test="$node/../../../../section">4</xsl:when>
            <xsl:when test="$node/../../../section">3</xsl:when>
            <xsl:otherwise>2</xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>1</xsl:otherwise>
  </xsl:choose>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="qanda.section.level">
<refpurpose>Returns the hierarchical level of a QandASet</refpurpose>

<refdescription id="qanda.section.level-desc">
<para>This template calculates the hierarchical level of a QandASet.
</para>
</refdescription>

<refreturn id="qanda.section.level-returns">
<para>The level, <quote>1</quote>, <quote>2</quote>, etc.
</para>
</refreturn>
</doc:template><xsl:template name="qanda.section.level">
  <xsl:variable name="section" select="(ancestor::section                          |ancestor::simplesect                          |ancestor::sect5                          |ancestor::sect4                          |ancestor::sect3                          |ancestor::sect2                          |ancestor::sect1                          |ancestor::refsect3                          |ancestor::refsect2                          |ancestor::refsect1)[last()]"/>

  <xsl:choose>
    <xsl:when test="count($section) = '0'">1</xsl:when>
    <xsl:otherwise>
      <xsl:variable name="slevel">
        <xsl:call-template name="section.level">
          <xsl:with-param name="node" select="$section"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:value-of select="$slevel + 1"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="refentry.section.level">
  <xsl:param name="node" select="."/>

  <xsl:variable name="RElevel">
    <xsl:call-template name="refentry.level">
      <xsl:with-param name="node" select="$node/ancestor::refentry[1]"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="levelinRE">
    <xsl:choose>
      <xsl:when test="local-name($node)='refsynopsisdiv'">1</xsl:when>
      <xsl:when test="local-name($node)='refsect1'">1</xsl:when>
      <xsl:when test="local-name($node)='refsect2'">2</xsl:when>
      <xsl:when test="local-name($node)='refsect3'">3</xsl:when>
      <xsl:when test="local-name($node)='refsection'">
        <xsl:choose>
          <xsl:when test="$node/../../../../../refsection">5</xsl:when>
          <xsl:when test="$node/../../../../refsection">4</xsl:when>
          <xsl:when test="$node/../../../refsection">3</xsl:when>
          <xsl:when test="$node/../../refsection">2</xsl:when>
          <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:value-of select="$levelinRE + $RElevel"/>
</xsl:template><xsl:template name="refentry.level">
  <xsl:param name="node" select="."/>
  <xsl:variable name="container" select="($node/ancestor::section |                         $node/ancestor::sect1 |                         $node/ancestor::sect2 |                         $node/ancestor::sect3 |                         $node/ancestor::sect4 |                         $node/ancestor::sect5)[last()]"/>

  <xsl:choose>
    <xsl:when test="$container">
      <xsl:variable name="slevel">
        <xsl:call-template name="section.level">
          <xsl:with-param name="node" select="$container"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:value-of select="$slevel + 1"/>
    </xsl:when>
    <xsl:otherwise>1</xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="qandadiv.section.level">
  <xsl:variable name="section.level">
    <xsl:call-template name="qanda.section.level"/>
  </xsl:variable>
  <xsl:variable name="anc.divs" select="ancestor::qandadiv"/>

  <xsl:value-of select="count($anc.divs) + number($section.level)"/>
</xsl:template><xsl:template name="question.answer.label">
  <xsl:variable name="deflabel">
    <xsl:choose>
      <xsl:when test="ancestor-or-self::*[@defaultlabel]">
        <xsl:value-of select="(ancestor-or-self::*[@defaultlabel])[last()]                               /@defaultlabel"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$qanda.defaultlabel"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="label" select="@label"/>

<!--
 (hnr      (hierarchical-number-recursive (normalize "qandadiv") node))

         (parsect  (ancestor-member node (section-element-list)))

         (defnum   (if (and %qanda-inherit-numeration% 
                            %section-autolabel%)
                       (if (node-list-empty? parsect)
                           (section-autolabel-prefix node)
                           (section-autolabel parsect))
                       ""))

         (hnumber  (let loop ((numlist hnr) (number defnum) 
                              (sep (if (equal? defnum "") "" ".")))
                     (if (null? numlist)
                         number
                         (loop (cdr numlist) 
                               (string-append number
                                              sep
                                              (number->string (car numlist)))
                               "."))))
         (cnumber  (child-number (parent node)))
         (number   (string-append hnumber 
                                  (if (equal? hnumber "")
                                      ""
                                      ".")
                                  (number->string cnumber))))
-->

  <xsl:choose>
    <xsl:when test="$deflabel = 'qanda'">
      <xsl:call-template name="gentext">
        <xsl:with-param name="key">
          <xsl:choose>
            <xsl:when test="local-name(.) = 'question'">question</xsl:when>
            <xsl:when test="local-name(.) = 'answer'">answer</xsl:when>
            <xsl:when test="local-name(.) = 'qandadiv'">qandadiv</xsl:when>
            <xsl:otherwise>qandaset</xsl:otherwise>
          </xsl:choose>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$deflabel = 'label'">
      <xsl:value-of select="$label"/>
    </xsl:when>
    <xsl:when test="$deflabel = 'number'                     and local-name(.) = 'question'">
      <xsl:apply-templates select="ancestor::qandaset[1]" mode="number"/>
      <xsl:choose>
        <xsl:when test="ancestor::qandadiv">
          <xsl:apply-templates select="ancestor::qandadiv[1]" mode="number"/>
          <xsl:apply-templates select="ancestor::qandaentry" mode="number"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="ancestor::qandaentry" mode="number"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <!-- nothing -->
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="qandaset" mode="number">
  <!-- FIXME: -->
</xsl:template><xsl:template match="qandadiv" mode="number">
  <xsl:number level="multiple" from="qandaset" format="1."/>
</xsl:template><xsl:template match="qandaentry" mode="number">
  <xsl:choose>
    <xsl:when test="ancestor::qandadiv">
      <xsl:number level="single" from="qandadiv" format="1."/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:number level="single" from="qandaset" format="1."/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="object.id">
  <xsl:param name="object" select="."/>
  <xsl:choose>
    <xsl:when test="$object/@id">
      <xsl:value-of select="$object/@id"/>
    </xsl:when>
    <xsl:when test="$object/@xml:id">
      <xsl:value-of select="$object/@xml:id"/>
    </xsl:when>
    <xsl:when test="$generate.consistent.ids != 0">
      <!-- Make $object the current node -->
      <xsl:for-each select="$object">
        <xsl:text>id-</xsl:text>
        <xsl:number level="multiple" count="*"/>
      </xsl:for-each>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="generate-id($object)"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="person.name">
  <!-- Formats a personal name. Handles corpauthor as a special case. -->
  <xsl:param name="node" select="."/>

  <xsl:variable name="style">
    <xsl:choose>
      <xsl:when test="$node/@role">
        <xsl:value-of select="$node/@role"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="gentext.template">
          <xsl:with-param name="context" select="'styles'"/>
          <xsl:with-param name="name" select="'person-name'"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:choose>
    <!-- the personname element is a specialcase -->
    <xsl:when test="$node/personname">
      <xsl:call-template name="person.name">
        <xsl:with-param name="node" select="$node/personname"/>
      </xsl:call-template>
    </xsl:when>

    <!-- handle corpauthor as a special case...-->
    <!-- * MikeSmith 2007-06: I'm wondering if the person.name template -->
    <!-- * actually ever gets called to handle corpauthor.. maybe -->
    <!-- * we don't actually need to check for corpauthor here. -->
    <xsl:when test="local-name($node)='corpauthor'">
      <xsl:apply-templates select="$node"/>
    </xsl:when>

    <xsl:otherwise>
      <xsl:choose>
        <!-- Handle case when personname contains only general markup (DocBook 5.0) -->
        <xsl:when test="$node/self::personname and not($node/firstname or $node/honorific or $node/lineage or $node/othername or $node/surname)">
          <xsl:apply-templates select="$node/node()"/>
        </xsl:when>
        <xsl:when test="$style = 'family-given'">
          <xsl:call-template name="person.name.family-given">
            <xsl:with-param name="node" select="$node"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="$style = 'last-first'">
          <xsl:call-template name="person.name.last-first">
            <xsl:with-param name="node" select="$node"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="person.name.first-last">
            <xsl:with-param name="node" select="$node"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="person.name.family-given">
  <xsl:param name="node" select="."/>

  <!-- The family-given style applies a convention for identifying given -->
  <!-- and family names in locales where it may be ambiguous -->
  <xsl:apply-templates select="$node//surname[1]"/>

  <xsl:if test="$node//surname and $node//firstname">
    <xsl:text> </xsl:text>
  </xsl:if>

  <xsl:apply-templates select="$node//firstname[1]"/>

  <xsl:text> [FAMILY Given]</xsl:text>
</xsl:template><xsl:template name="person.name.last-first">
  <xsl:param name="node" select="."/>

  <xsl:apply-templates select="$node//surname[1]"/>

  <xsl:if test="$node//surname and $node//firstname">
    <xsl:text>, </xsl:text>
  </xsl:if>

  <xsl:apply-templates select="$node//firstname[1]"/>
</xsl:template><xsl:template name="person.name.first-last">
  <xsl:param name="node" select="."/>

  <xsl:if test="$node//honorific">
    <xsl:apply-templates select="$node//honorific[1]"/>
    <xsl:value-of select="$punct.honorific"/>
  </xsl:if>

  <xsl:if test="$node//firstname">
    <xsl:if test="$node//honorific">
      <xsl:text> </xsl:text>
    </xsl:if>
    <xsl:apply-templates select="$node//firstname[1]"/>
  </xsl:if>

  <xsl:if test="$node//othername and $author.othername.in.middle != 0">
    <xsl:if test="$node//honorific or $node//firstname">
      <xsl:text> </xsl:text>
    </xsl:if>
    <xsl:apply-templates select="$node//othername[1]"/>
  </xsl:if>

  <xsl:if test="$node//surname">
    <xsl:if test="$node//honorific or $node//firstname                   or ($node//othername and $author.othername.in.middle != 0)">
      <xsl:text> </xsl:text>
    </xsl:if>
    <xsl:apply-templates select="$node//surname[1]"/>
  </xsl:if>

  <xsl:if test="$node//lineage">
    <xsl:text>, </xsl:text>
    <xsl:apply-templates select="$node//lineage[1]"/>
  </xsl:if>
</xsl:template><xsl:template name="person.name.list">
  <!-- Return a formatted string representation of the contents of
       the current element. The current element must contain one or
       more AUTHORs, CORPAUTHORs, OTHERCREDITs, and/or EDITORs.

       John Doe
     or
       John Doe and Jane Doe
     or
       John Doe, Jane Doe, and A. Nonymous
  -->
  <xsl:param name="person.list" select="author|corpauthor|othercredit|editor"/>
  <xsl:param name="person.count" select="count($person.list)"/>
  <xsl:param name="count" select="1"/>

  <xsl:choose>
    <xsl:when test="$count &gt; $person.count"/>
    <xsl:otherwise>
      <xsl:call-template name="person.name">
        <xsl:with-param name="node" select="$person.list[position()=$count]"/>
      </xsl:call-template>

      <xsl:choose>
        <xsl:when test="$person.count = 2 and $count = 1">
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="'authorgroup'"/>
            <xsl:with-param name="name" select="'sep2'"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="$person.count &gt; 2 and $count+1 = $person.count">
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="'authorgroup'"/>
            <xsl:with-param name="name" select="'seplast'"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="$count &lt; $person.count">
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="'authorgroup'"/>
            <xsl:with-param name="name" select="'sep'"/>
          </xsl:call-template>
        </xsl:when>
      </xsl:choose>

      <xsl:call-template name="person.name.list">
        <xsl:with-param name="person.list" select="$person.list"/>
        <xsl:with-param name="person.count" select="$person.count"/>
        <xsl:with-param name="count" select="$count+1"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:param name="arg.choice.opt.open.str">[</xsl:param><xsl:param name="arg.choice.opt.close.str">]</xsl:param><xsl:param name="arg.choice.req.open.str">{</xsl:param><xsl:param name="arg.choice.req.close.str">}</xsl:param><xsl:param name="arg.choice.plain.open.str"><xsl:text> </xsl:text></xsl:param><xsl:param name="arg.choice.plain.close.str"><xsl:text> </xsl:text></xsl:param><xsl:param name="arg.choice.def.open.str">[</xsl:param><xsl:param name="arg.choice.def.close.str">]</xsl:param><xsl:param name="arg.rep.repeat.str">...</xsl:param><xsl:param name="arg.rep.norepeat.str"/><xsl:param name="arg.rep.def.str"/><xsl:param name="arg.or.sep"> | </xsl:param><xsl:param name="cmdsynopsis.hanging.indent">4pi</xsl:param><xsl:template name="filename-basename">
  <!-- We assume all filenames are really URIs and use "/" -->
  <xsl:param name="filename"/>
  <xsl:param name="recurse" select="false()"/>

  <xsl:choose>
    <xsl:when test="substring-after($filename, '/') != ''">
      <xsl:call-template name="filename-basename">
        <xsl:with-param name="filename" select="substring-after($filename, '/')"/>
        <xsl:with-param name="recurse" select="true()"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$filename"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="filename-extension">
  <xsl:param name="filename"/>
  <xsl:param name="recurse" select="false()"/>

  <!-- Make sure we only look at the base name... -->
  <xsl:variable name="basefn">
    <xsl:choose>
      <xsl:when test="$recurse">
        <xsl:value-of select="$filename"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="filename-basename">
          <xsl:with-param name="filename" select="$filename"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="substring-after($basefn, '.') != ''">
      <xsl:call-template name="filename-extension">
        <xsl:with-param name="filename" select="substring-after($basefn, '.')"/>
        <xsl:with-param name="recurse" select="true()"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$recurse">
      <xsl:value-of select="$basefn"/>
    </xsl:when>
    <xsl:otherwise/>
  </xsl:choose>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="select.mediaobject">
<refpurpose>Selects and processes an appropriate media object from a list</refpurpose>

<refdescription id="select.mediaobject-desc">
<para>This template takes a list of media objects (usually the
children of a mediaobject or inlinemediaobject) and processes
the "right" object.</para>

<para>This template relies on a template named 
"select.mediaobject.index" to determine which object
in the list is appropriate.</para>

<para>If no acceptable object is located, nothing happens.</para>
</refdescription>

<refparameter id="select.mediaobject-params">
<variablelist>
<varlistentry><term>olist</term>
<listitem>
<para>The node list of potential objects to examine.</para>
</listitem>
</varlistentry>
</variablelist>
</refparameter>

<refreturn id="select.mediaobject-returns">
<para>Calls &lt;xsl:apply-templates&gt; on the selected object.</para>
</refreturn>
</doc:template><xsl:template name="select.mediaobject">
  <xsl:param name="olist" select="imageobject|imageobjectco                      |videoobject|audioobject|textobject"/>
  
  <xsl:variable name="mediaobject.index">
    <xsl:call-template name="select.mediaobject.index">
      <xsl:with-param name="olist" select="$olist"/>
      <xsl:with-param name="count" select="1"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:if test="$mediaobject.index != ''">
    <xsl:apply-templates select="$olist[position() = $mediaobject.index]"/>
  </xsl:if>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="select.mediaobject.index">
<refpurpose>Selects the position of the appropriate media object from a list</refpurpose>

<refdescription id="select.mediaobject.index-desc">
<para>This template takes a list of media objects (usually the
children of a mediaobject or inlinemediaobject) and determines
the "right" object. It returns the position of that object
to be used by the calling template.</para>

<para>If the parameter <parameter>use.role.for.mediaobject</parameter>
is nonzero, then it first checks for an object with
a role attribute of the appropriate value.  It takes the first
of those.  Otherwise, it takes the first acceptable object
through a recursive pass through the list.</para>

<para>This template relies on a template named "is.acceptable.mediaobject"
to determine if a given object is an acceptable graphic. The semantics
of media objects is that the first acceptable graphic should be used.
</para>

<para>If no acceptable object is located, no index is returned.</para>
</refdescription>

<refparameter id="select.mediaobject.index-params">
<variablelist>
<varlistentry><term>olist</term>
<listitem>
<para>The node list of potential objects to examine.</para>
</listitem>
</varlistentry>
<varlistentry><term>count</term>
<listitem>
<para>The position in the list currently being considered by the 
recursive process.</para>
</listitem>
</varlistentry>
</variablelist>
</refparameter>

<refreturn id="select.mediaobject.index-returns">
<para>Returns the position in the original list of the selected object.</para>
</refreturn>
</doc:template><xsl:template name="select.mediaobject.index">
  <xsl:param name="olist" select="imageobject|imageobjectco                      |videoobject|audioobject|textobject"/>
  <xsl:param name="count">1</xsl:param>

  <xsl:choose>
    <!-- Test for objects preferred by role -->
    <xsl:when test="$use.role.for.mediaobject != 0                 and $preferred.mediaobject.role != ''                and $olist[@role = $preferred.mediaobject.role]"> 
      
      <!-- Get the first hit's position index -->
      <xsl:for-each select="$olist">
        <xsl:if test="@role = $preferred.mediaobject.role and              not(preceding-sibling::*[@role = $preferred.mediaobject.role])"> 
          <xsl:value-of select="position()"/> 
        </xsl:if>
      </xsl:for-each>
    </xsl:when>

    <xsl:when test="$use.role.for.mediaobject != 0                 and $olist[@role = $stylesheet.result.type]">
      <!-- Get the first hit's position index -->
      <xsl:for-each select="$olist">
        <xsl:if test="@role = $stylesheet.result.type and                not(preceding-sibling::*[@role = $stylesheet.result.type])"> 
          <xsl:value-of select="position()"/> 
        </xsl:if>
      </xsl:for-each>
    </xsl:when>
    <!-- Accept 'html' for $stylesheet.result.type = 'xhtml' -->
    <xsl:when test="$use.role.for.mediaobject != 0                 and $stylesheet.result.type = 'xhtml'                and $olist[@role = 'html']">
      <!-- Get the first hit's position index -->
      <xsl:for-each select="$olist">
        <xsl:if test="@role = 'html' and                not(preceding-sibling::*[@role = 'html'])"> 
          <xsl:value-of select="position()"/> 
        </xsl:if>
      </xsl:for-each>
    </xsl:when>

    <!-- If no selection by role, and there is only one object, use it -->
    <xsl:when test="count($olist) = 1 and $count = 1">
      <xsl:value-of select="$count"/> 
    </xsl:when>

    <xsl:otherwise>
      <!-- Otherwise select first acceptable object -->
      <xsl:if test="$count &lt;= count($olist)">
        <xsl:variable name="object" select="$olist[position()=$count]"/>
    
        <xsl:variable name="useobject">
          <xsl:choose>
            <!-- select videoobject or audioobject before textobject -->
            <xsl:when test="local-name($object) = 'videoobject'">
              <xsl:text>1</xsl:text> 
            </xsl:when>
            <xsl:when test="local-name($object) = 'audioobject'">
              <xsl:text>1</xsl:text> 
            </xsl:when>
            <!-- skip textobject if also video, audio, or image out of order -->
            <xsl:when test="local-name($object) = 'textobject' and                             ../imageobject or                             ../audioobject or                             ../videoobject">
              <xsl:text>0</xsl:text> 
            </xsl:when>
            <!-- The phrase is used only when contains TeX Math and output is FO -->
            <xsl:when test="local-name($object)='textobject' and $object/phrase                             and $object/@role='tex' and $stylesheet.result.type = 'fo'                             and $tex.math.in.alt != ''">
              <xsl:text>1</xsl:text> 
            </xsl:when>
            <!-- The phrase is never used -->
            <xsl:when test="local-name($object)='textobject' and $object/phrase">
              <xsl:text>0</xsl:text>
            </xsl:when>
            <xsl:when test="local-name($object)='textobject'                             and $object/ancestor::equation ">
            <!-- The first textobject is not a reasonable fallback
                 for equation image -->
              <xsl:text>0</xsl:text>
            </xsl:when>
            <!-- The first textobject is a reasonable fallback -->
            <xsl:when test="local-name($object)='textobject'                             and $object[not(@role) or @role!='tex']">
              <xsl:text>1</xsl:text>
            </xsl:when>
            <!-- don't use graphic when output is FO, TeX Math is used 
                 and there is math in alt element -->
            <xsl:when test="$object/ancestor::equation and                              $object/ancestor::equation/alt[@role='tex']                             and $stylesheet.result.type = 'fo'                             and $tex.math.in.alt != ''">
              <xsl:text>0</xsl:text>
            </xsl:when>
            <!-- If there's only one object, use it -->
            <xsl:when test="$count = 1 and count($olist) = 1">
               <xsl:text>1</xsl:text>
            </xsl:when>
            <!-- Otherwise, see if this one is a useable graphic -->
            <xsl:otherwise>
              <xsl:choose>
                <!-- peek inside imageobjectco to simplify the test -->
                <xsl:when test="local-name($object) = 'imageobjectco'">
                  <xsl:call-template name="is.acceptable.mediaobject">
                    <xsl:with-param name="object" select="$object/imageobject"/>
                  </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:call-template name="is.acceptable.mediaobject">
                    <xsl:with-param name="object" select="$object"/>
                  </xsl:call-template>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
    
        <xsl:choose>
          <xsl:when test="$useobject='1'">
            <xsl:value-of select="$count"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="select.mediaobject.index">
              <xsl:with-param name="olist" select="$olist"/>
              <xsl:with-param name="count" select="$count + 1"/>
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="is.acceptable.mediaobject">
<refpurpose>Returns '1' if the specified media object is recognized</refpurpose>

<refdescription id="is.acceptable.mediaobject-desc">
<para>This template examines a media object and returns '1' if the
object is recognized as a graphic.</para>
</refdescription>

<refparameter id="is.acceptable.mediaobject-params">
<variablelist>
<varlistentry><term>object</term>
<listitem>
<para>The media object to consider.</para>
</listitem>
</varlistentry>
</variablelist>
</refparameter>

<refreturn id="is.acceptable.mediaobject-returns">
<para>0 or 1</para>
</refreturn>
</doc:template><xsl:template name="is.acceptable.mediaobject">
  <xsl:param name="object"/>

  <xsl:variable name="filename">
    <xsl:call-template name="mediaobject.filename">
      <xsl:with-param name="object" select="$object"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="ext">
    <xsl:call-template name="filename-extension">
      <xsl:with-param name="filename" select="$filename"/>
    </xsl:call-template>
  </xsl:variable>

  <!-- there will only be one -->
  <xsl:variable name="data" select="$object/videodata                                     |$object/imagedata                                     |$object/audiodata"/>

  <xsl:variable name="format" select="$data/@format"/>

  <xsl:variable name="graphic.format">
    <xsl:if test="$format">
      <xsl:call-template name="is.graphic.format">
        <xsl:with-param name="format" select="$format"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="graphic.ext">
    <xsl:if test="$ext">
      <xsl:call-template name="is.graphic.extension">
        <xsl:with-param name="ext" select="$ext"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$use.svg = 0 and $format = 'SVG'">0</xsl:when>
    <xsl:when xmlns:svg="http://www.w3.org/2000/svg" test="$use.svg != 0 and $object/svg:*">1</xsl:when>
    <xsl:when test="$graphic.format = '1'">1</xsl:when>
    <xsl:when test="$graphic.ext = '1'">1</xsl:when>
    <xsl:otherwise>0</xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="mediaobject.filename">
  <xsl:param name="object"/>

  <xsl:variable name="data" select="$object/videodata                                     |$object/imagedata                                     |$object/audiodata                                     |$object"/>

  <xsl:variable name="filename">
    <xsl:choose>
      <xsl:when test="$data[@fileref]">
        <xsl:apply-templates select="$data/@fileref"/>
      </xsl:when>
      <xsl:when test="$data[@entityref]">
        <xsl:value-of select="unparsed-entity-uri($data/@entityref)"/>
      </xsl:when>
      <xsl:otherwise/>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="real.ext">
    <xsl:call-template name="filename-extension">
      <xsl:with-param name="filename" select="$filename"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="ext">
    <xsl:choose>
      <xsl:when test="$real.ext != ''">
        <xsl:value-of select="$real.ext"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$graphic.default.extension"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="graphic.ext">
    <xsl:call-template name="is.graphic.extension">
      <xsl:with-param name="ext" select="$ext"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$real.ext = ''">
      <xsl:choose>
        <xsl:when test="$ext != ''">
          <xsl:value-of select="$filename"/>
          <xsl:text>.</xsl:text>
          <xsl:value-of select="$ext"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$filename"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:when test="not($graphic.ext)">
      <xsl:choose>
        <xsl:when test="$graphic.default.extension != ''">
          <xsl:value-of select="$filename"/>
          <xsl:text>.</xsl:text>
          <xsl:value-of select="$graphic.default.extension"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$filename"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$filename"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="check.id.unique">
<refpurpose>Warn users about references to non-unique IDs</refpurpose>
<refdescription id="check.id.unique-desc">
<para>If passed an ID in <varname>linkend</varname>,
<function>check.id.unique</function> prints
a warning message to the user if either the ID does not exist or
the ID is not unique.</para>
</refdescription>
</doc:template><xsl:template name="check.id.unique">
  <xsl:param name="linkend"/>
  <xsl:if test="$linkend != ''">
    <xsl:variable name="targets" select="key('id',$linkend)"/>
    <xsl:variable name="target" select="$targets[1]"/>

    <xsl:if test="count($targets)=0">
      <xsl:message>
        <xsl:text>Error: no ID for constraint linkend: </xsl:text>
        <xsl:value-of select="$linkend"/>
        <xsl:text>.</xsl:text>
      </xsl:message>
      <!--
      <xsl:message>
        <xsl:text>If the ID exists in your document, did your </xsl:text>
        <xsl:text>XSLT Processor load the DTD?</xsl:text>
      </xsl:message>
      -->
    </xsl:if>

    <xsl:if test="count($targets)&gt;1">
      <xsl:message>
        <xsl:text>Warning: multiple "IDs" for constraint linkend: </xsl:text>
        <xsl:value-of select="$linkend"/>
        <xsl:text>.</xsl:text>
      </xsl:message>
    </xsl:if>
  </xsl:if>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="check.idref.targets">
<refpurpose>Warn users about incorrectly typed references</refpurpose>
<refdescription id="check.idref.targets-desc">
<para>If passed an ID in <varname>linkend</varname>,
<function>check.idref.targets</function> makes sure that the element
pointed to by the link is one of the elements listed in
<varname>element-list</varname> and warns the user otherwise.</para>
</refdescription>
</doc:template><xsl:template name="check.idref.targets">
  <xsl:param name="linkend"/>
  <xsl:param name="element-list"/>
  <xsl:if test="$linkend != ''">
    <xsl:variable name="targets" select="key('id',$linkend)"/>
    <xsl:variable name="target" select="$targets[1]"/>

    <xsl:if test="count($target) &gt; 0">
      <xsl:if test="not(contains(concat(' ', $element-list, ' '), local-name($target)))">
        <xsl:message>
          <xsl:text>Error: linkend (</xsl:text>
          <xsl:value-of select="$linkend"/>
          <xsl:text>) points to "</xsl:text>
          <xsl:value-of select="local-name($target)"/>
          <xsl:text>" not (one of): </xsl:text>
          <xsl:value-of select="$element-list"/>
        </xsl:message>
      </xsl:if>
    </xsl:if>
  </xsl:if>
</xsl:template><xsl:param name="procedure.step.numeration.formats" select="'1aiAI'"/><xsl:template name="procedure.step.numeration">
  <xsl:param name="context" select="."/>
  <xsl:variable name="format.length" select="string-length($procedure.step.numeration.formats)"/>
  <xsl:choose>
    <xsl:when test="local-name($context) = 'substeps'">
      <xsl:variable name="ssdepth" select="count($context/ancestor::substeps)"/>
      <xsl:variable name="sstype" select="($ssdepth mod $format.length)+2"/>
      <xsl:choose>
        <xsl:when test="$sstype &gt; $format.length">
          <xsl:value-of select="substring($procedure.step.numeration.formats,1,1)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="substring($procedure.step.numeration.formats,$sstype,1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:when test="local-name($context) = 'step'">
      <xsl:variable name="sdepth" select="count($context/ancestor::substeps)"/>
      <xsl:variable name="stype" select="($sdepth mod $format.length)+1"/>
      <xsl:value-of select="substring($procedure.step.numeration.formats,$stype,1)"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:message>
        <xsl:text>Unexpected context in procedure.step.numeration: </xsl:text>
        <xsl:value-of select="local-name($context)"/>
      </xsl:message>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="step" mode="number">
  <xsl:param name="rest" select="''"/>
  <xsl:param name="recursive" select="1"/>
  <xsl:variable name="format">
    <xsl:call-template name="procedure.step.numeration"/>
  </xsl:variable>
  <xsl:variable name="num">
    <xsl:number count="step" format="{$format}"/>
  </xsl:variable>
  <xsl:choose>
    <xsl:when test="$recursive != 0 and ancestor::step">
      <xsl:apply-templates select="ancestor::step[1]" mode="number">
        <xsl:with-param name="rest" select="concat('.', $num, $rest)"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="concat($num, $rest)"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="output-orderedlist-starting-number">
  <xsl:param name="list"/>
  <xsl:param name="pi-start"/>
  <xsl:choose>
    <xsl:when test="not($list/@continuation = 'continues')">
      <xsl:choose>
        <xsl:when test="$list/@startingnumber">
          <xsl:value-of select="$list/@startingnumber"/>
        </xsl:when>
        <xsl:when test="$pi-start != ''">
          <xsl:value-of select="$pi-start"/>
        </xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <!-- match on previous list at same nesting level -->
      <xsl:variable name="prevlist" select="$list/preceding::orderedlist                 [count($list/ancestor::orderedlist) = count(ancestor::orderedlist)][1]"/>
      <xsl:choose>
        <xsl:when test="count($prevlist) = 0">2</xsl:when>
        <xsl:otherwise>
          <xsl:variable name="prevlength" select="count($prevlist/listitem)"/>
          <xsl:variable name="prevstart">
            <xsl:call-template name="orderedlist-starting-number">
              <xsl:with-param name="list" select="$prevlist"/>
            </xsl:call-template>
          </xsl:variable>
          <xsl:value-of select="$prevstart + $prevlength"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="orderedlist-item-number">
  <!-- context node must be a listitem in an orderedlist -->
  <xsl:param name="node" select="."/>
  <xsl:choose>
    <xsl:when test="$node/@override">
      <xsl:value-of select="$node/@override"/>
    </xsl:when>
    <xsl:when test="$node/preceding-sibling::listitem">
      <xsl:variable name="pnum">
        <xsl:call-template name="orderedlist-item-number">
          <xsl:with-param name="node" select="$node/preceding-sibling::listitem[1]"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:value-of select="$pnum + 1"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="orderedlist-starting-number">
        <xsl:with-param name="list" select="parent::*"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="next.numeration">
  <xsl:param name="numeration" select="'default'"/>
  <xsl:choose>
    <!-- Change this list if you want to change the order of numerations -->
    <xsl:when test="$numeration = 'arabic'">loweralpha</xsl:when>
    <xsl:when test="$numeration = 'loweralpha'">lowerroman</xsl:when>
    <xsl:when test="$numeration = 'lowerroman'">upperalpha</xsl:when>
    <xsl:when test="$numeration = 'upperalpha'">upperroman</xsl:when>
    <xsl:when test="$numeration = 'upperroman'">arabic</xsl:when>
    <xsl:otherwise>arabic</xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="list.numeration">
  <xsl:param name="node" select="."/>

  <xsl:choose>
    <xsl:when test="$node/@numeration">
      <xsl:value-of select="$node/@numeration"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="$node/ancestor::orderedlist">
          <xsl:call-template name="next.numeration">
            <xsl:with-param name="numeration">
              <xsl:call-template name="list.numeration">
                <xsl:with-param name="node" select="$node/ancestor::orderedlist[1]"/>
              </xsl:call-template>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="next.numeration"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="orderedlist/listitem" mode="item-number">
  <xsl:variable name="numeration">
    <xsl:call-template name="list.numeration">
      <xsl:with-param name="node" select="parent::orderedlist"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="type">
    <xsl:choose>
      <xsl:when test="$numeration='arabic'">1.</xsl:when>
      <xsl:when test="$numeration='loweralpha'">a.</xsl:when>
      <xsl:when test="$numeration='lowerroman'">i.</xsl:when>
      <xsl:when test="$numeration='upperalpha'">A.</xsl:when>
      <xsl:when test="$numeration='upperroman'">I.</xsl:when>
      <!-- What!? This should never happen -->
      <xsl:otherwise>
        <xsl:message>
          <xsl:text>Unexpected numeration: </xsl:text>
          <xsl:value-of select="$numeration"/>
        </xsl:message>
        <xsl:value-of select="1."/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="item-number">
    <xsl:call-template name="orderedlist-item-number"/>
  </xsl:variable>

  <xsl:if test="parent::orderedlist/@inheritnum='inherit'                 and ancestor::listitem[parent::orderedlist]">
    <xsl:apply-templates select="ancestor::listitem[parent::orderedlist][1]" mode="item-number"/>
  </xsl:if>

  <xsl:number value="$item-number" format="{$type}"/>
</xsl:template><xsl:template name="next.itemsymbol">
  <xsl:param name="itemsymbol" select="'default'"/>
  <xsl:choose>
    <!-- Change this list if you want to change the order of symbols -->
    <xsl:when test="$itemsymbol = 'disc'">circle</xsl:when>
    <xsl:when test="$itemsymbol = 'circle'">square</xsl:when>
    <xsl:otherwise>disc</xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="list.itemsymbol">
  <xsl:param name="node" select="."/>

  <xsl:choose>
    <xsl:when test="@override">
      <xsl:value-of select="@override"/>
    </xsl:when>
    <xsl:when test="$node/@mark">
      <xsl:value-of select="$node/@mark"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="$node/ancestor::itemizedlist">
          <xsl:call-template name="next.itemsymbol">
            <xsl:with-param name="itemsymbol">
              <xsl:call-template name="list.itemsymbol">
                <xsl:with-param name="node" select="$node/ancestor::itemizedlist[1]"/>
              </xsl:call-template>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="next.itemsymbol"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="copyright.years">
<refpurpose>Print a set of years with collapsed ranges</refpurpose>

<refdescription id="copyright.years-desc">
<para>This template prints a list of year elements with consecutive
years printed as a range. In other words:</para>

<screen>&lt;year&gt;1992&lt;/year&gt;
&lt;year&gt;1993&lt;/year&gt;
&lt;year&gt;1994&lt;/year&gt;</screen>

<para>is printed <quote>1992-1994</quote>, whereas:</para>

<screen>&lt;year&gt;1992&lt;/year&gt;
&lt;year&gt;1994&lt;/year&gt;</screen>

<para>is printed <quote>1992, 1994</quote>.</para>

<para>This template assumes that all the year elements contain only
decimal year numbers, that the elements are sorted in increasing
numerical order, that there are no duplicates, and that all the years
are expressed in full <quote>century+year</quote>
(<quote>1999</quote> not <quote>99</quote>) notation.</para>
</refdescription>

<refparameter id="copyright.years-params">
<variablelist>
<varlistentry><term>years</term>
<listitem>
<para>The initial set of year elements.</para>
</listitem>
</varlistentry>
<varlistentry><term>print.ranges</term>
<listitem>
<para>If non-zero, multi-year ranges are collapsed. If zero, all years
are printed discretely.</para>
</listitem>
</varlistentry>
<varlistentry><term>single.year.ranges</term>
<listitem>
<para>If non-zero, two consecutive years will be printed as a range,
otherwise, they will be printed discretely. In other words, a single
year range is <quote>1991-1992</quote> but discretely it's
<quote>1991, 1992</quote>.</para>
</listitem>
</varlistentry>
</variablelist>
</refparameter>

<refreturn id="copyright.years-returns">
<para>This template returns the formatted list of years.</para>
</refreturn>
</doc:template><xsl:template name="copyright.years">
  <xsl:param name="years"/>
  <xsl:param name="print.ranges" select="1"/>
  <xsl:param name="single.year.ranges" select="0"/>
  <xsl:param name="firstyear" select="0"/>
  <xsl:param name="nextyear" select="0"/>

  <!--
  <xsl:message terminate="no">
    <xsl:text>CY: </xsl:text>
    <xsl:value-of select="count($years)"/>
    <xsl:text>, </xsl:text>
    <xsl:value-of select="$firstyear"/>
    <xsl:text>, </xsl:text>
    <xsl:value-of select="$nextyear"/>
    <xsl:text>, </xsl:text>
    <xsl:value-of select="$print.ranges"/>
    <xsl:text>, </xsl:text>
    <xsl:value-of select="$single.year.ranges"/>
    <xsl:text> (</xsl:text>
    <xsl:value-of select="$years[1]"/>
    <xsl:text>)</xsl:text>
  </xsl:message>
  -->
    
  <xsl:choose>
    <xsl:when test="$print.ranges = 0 and count($years) &gt; 0">
      <xsl:choose>
        <xsl:when test="count($years) = 1">
          <xsl:apply-templates select="$years[1]" mode="titlepage.mode"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="$years[1]" mode="titlepage.mode"/>
          <xsl:text>, </xsl:text>
          <xsl:call-template name="copyright.years">
            <xsl:with-param name="years" select="$years[position() &gt; 1]"/>
            <xsl:with-param name="print.ranges" select="$print.ranges"/>
            <xsl:with-param name="single.year.ranges" select="$single.year.ranges"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:when test="count($years) = 0">
      <xsl:variable name="lastyear" select="$nextyear - 1"/>
      <xsl:choose>
        <xsl:when test="$firstyear = 0">
          <!-- there weren't any years at all -->
        </xsl:when>
        <!-- Just output a year with range in its text -->
        <xsl:when test="contains($firstyear, '-') or contains($firstyear, ',')">
          <xsl:value-of select="$firstyear"/>
        </xsl:when>
        <xsl:when test="$firstyear = $lastyear">
          <xsl:value-of select="$firstyear"/>
        </xsl:when>
        <xsl:when test="$single.year.ranges = 0                         and $lastyear = $firstyear + 1">
          <xsl:value-of select="$firstyear"/>
          <xsl:text>, </xsl:text>
          <xsl:value-of select="$lastyear"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$firstyear"/>
          <xsl:text>-</xsl:text>
          <xsl:value-of select="$lastyear"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:when test="contains($firstyear, '-') or contains($firstyear, ',')">
      <!-- Just output a year with range in its text -->
      <xsl:value-of select="$firstyear"/>
      <xsl:if test="count($years) != 0">
        <xsl:text>, </xsl:text>
      </xsl:if>
      <xsl:call-template name="copyright.years">
        <xsl:with-param name="years" select="$years[position() &gt; 1]"/>
        <xsl:with-param name="firstyear" select="$years[1]"/>
        <xsl:with-param name="nextyear" select="$years[1] + 1"/>
        <xsl:with-param name="print.ranges" select="$print.ranges"/>
        <xsl:with-param name="single.year.ranges" select="$single.year.ranges"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$firstyear = 0">
      <xsl:call-template name="copyright.years">
        <xsl:with-param name="years" select="$years[position() &gt; 1]"/>
        <xsl:with-param name="firstyear" select="$years[1]"/>
        <xsl:with-param name="nextyear" select="$years[1] + 1"/>
        <xsl:with-param name="print.ranges" select="$print.ranges"/>
        <xsl:with-param name="single.year.ranges" select="$single.year.ranges"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$nextyear = $years[1]">
      <xsl:call-template name="copyright.years">
        <xsl:with-param name="years" select="$years[position() &gt; 1]"/>
        <xsl:with-param name="firstyear" select="$firstyear"/>
        <xsl:with-param name="nextyear" select="$nextyear + 1"/>
        <xsl:with-param name="print.ranges" select="$print.ranges"/>
        <xsl:with-param name="single.year.ranges" select="$single.year.ranges"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <!-- we have years left, but they aren't in the current range -->
      <xsl:choose>
        <xsl:when test="$nextyear = $firstyear + 1">
          <xsl:value-of select="$firstyear"/>
          <xsl:text>, </xsl:text>
        </xsl:when>
        <xsl:when test="$single.year.ranges = 0                         and $nextyear = $firstyear + 2">
          <xsl:value-of select="$firstyear"/>
          <xsl:text>, </xsl:text>
          <xsl:value-of select="$nextyear - 1"/>
          <xsl:text>, </xsl:text>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$firstyear"/>
          <xsl:text>-</xsl:text>
          <xsl:value-of select="$nextyear - 1"/>
          <xsl:text>, </xsl:text>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:call-template name="copyright.years">
        <xsl:with-param name="years" select="$years[position() &gt; 1]"/>
        <xsl:with-param name="firstyear" select="$years[1]"/>
        <xsl:with-param name="nextyear" select="$years[1] + 1"/>
        <xsl:with-param name="print.ranges" select="$print.ranges"/>
        <xsl:with-param name="single.year.ranges" select="$single.year.ranges"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="find.path.params">
<refpurpose>Search in a table for the "best" match for the node</refpurpose>

<refdescription id="find.path.params-desc">
<para>This template searches in a table for the value that most-closely
(in the typical best-match sense of XSLT) matches the current (element)
node location.</para>
</refdescription>
</doc:template><xsl:template name="find.path.params">
  <xsl:param name="node" select="."/>
  <xsl:param name="table" select="''"/>
  <xsl:param name="location">
    <xsl:call-template name="xpath.location">
      <xsl:with-param name="node" select="$node"/>
    </xsl:call-template>
  </xsl:param>

  <xsl:variable name="value">
    <xsl:call-template name="lookup.key">
      <xsl:with-param name="key" select="$location"/>
      <xsl:with-param name="table" select="$table"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$value != ''">
      <xsl:value-of select="$value"/>
    </xsl:when>
    <xsl:when test="contains($location, '/')">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="node" select="$node"/>
        <xsl:with-param name="table" select="$table"/>
        <xsl:with-param name="location" select="substring-after($location, '/')"/>
      </xsl:call-template>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template name="relative-uri">
  <xsl:param name="filename" select="."/>
  <xsl:param name="destdir" select="''"/>
  
  <xsl:variable name="srcurl">
    <xsl:call-template name="strippath">
      <xsl:with-param name="filename">
        <xsl:call-template name="xml.base.dirs">
          <xsl:with-param name="base.elem" select="$filename/ancestor-or-self::*                                    [@xml:base != ''][1]"/>
        </xsl:call-template>
        <xsl:value-of select="$filename"/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="srcurl.trimmed">
    <xsl:call-template name="trim.common.uri.paths">
      <xsl:with-param name="uriA" select="$srcurl"/>
      <xsl:with-param name="uriB" select="$destdir"/>
      <xsl:with-param name="return" select="'A'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="destdir.trimmed">
    <xsl:call-template name="trim.common.uri.paths">
      <xsl:with-param name="uriA" select="$srcurl"/>
      <xsl:with-param name="uriB" select="$destdir"/>
      <xsl:with-param name="return" select="'B'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="depth">
    <xsl:call-template name="count.uri.path.depth">
      <xsl:with-param name="filename" select="$destdir.trimmed"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:call-template name="copy-string">
    <xsl:with-param name="string" select="'../'"/>
    <xsl:with-param name="count" select="$depth"/>
  </xsl:call-template>
  <xsl:value-of select="$srcurl.trimmed"/>

</xsl:template><xsl:template name="xml.base.dirs">
  <xsl:param name="base.elem" select="NONODE"/>

  <!-- Recursively resolve xml:base attributes, up to a 
       full path with : in uri -->
  <xsl:if test="$base.elem/ancestor::*[@xml:base != ''] and                 not(contains($base.elem/@xml:base, ':'))">
    <xsl:call-template name="xml.base.dirs">
      <xsl:with-param name="base.elem" select="$base.elem/ancestor::*[@xml:base != ''][1]"/>
    </xsl:call-template>
  </xsl:if>
  <xsl:call-template name="getdir">
    <xsl:with-param name="filename" select="$base.elem/@xml:base"/>
  </xsl:call-template>

</xsl:template><xsl:template name="strippath">
  <xsl:param name="filename" select="''"/>
  <xsl:choose>
    <!-- Leading .. are not eliminated -->
    <xsl:when test="starts-with($filename, '../')">
      <xsl:value-of select="'../'"/>
      <xsl:call-template name="strippath">
        <xsl:with-param name="filename" select="substring-after($filename, '../')"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="contains($filename, '/../')">
      <xsl:call-template name="strippath">
        <xsl:with-param name="filename">
          <xsl:call-template name="getdir">
            <xsl:with-param name="filename" select="substring-before($filename, '/../')"/>
          </xsl:call-template>
          <xsl:value-of select="substring-after($filename, '/../')"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$filename"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="getdir">
  <xsl:param name="filename" select="''"/>
  <xsl:if test="contains($filename, '/')">
    <xsl:value-of select="substring-before($filename, '/')"/>
    <xsl:text>/</xsl:text>
    <xsl:call-template name="getdir">
      <xsl:with-param name="filename" select="substring-after($filename, '/')"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="string.upper">
<refpurpose>Converts a string to all uppercase letters</refpurpose>

<refdescription id="string.upper-desc">
<para>Given a string, this template does a language-aware conversion
of that string to all uppercase letters, based on the values of the
<literal>lowercase.alpha</literal> and
<literal>uppercase.alpha</literal> gentext keys for the current
locale. It affects only those characters found in the values of
<literal>lowercase.alpha</literal> and
<literal>uppercase.alpha</literal>. All other characters are left
unchanged.</para>
</refdescription>

<refparameter id="string.upper-params">
<variablelist>
<varlistentry><term>string</term>
<listitem>
<para>The string to convert to uppercase.</para>
</listitem>
</varlistentry>
</variablelist>
</refparameter>
</doc:template><xsl:template name="string.upper">
  <xsl:param name="string" select="''"/>
  <xsl:variable name="lowercase.alpha">
    <xsl:call-template name="gentext">
      <xsl:with-param name="key" select="'lowercase.alpha'"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="uppercase.alpha">
    <xsl:call-template name="gentext">
      <xsl:with-param name="key" select="'uppercase.alpha'"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:value-of select="translate($string,$lowercase.alpha,$uppercase.alpha)"/>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="string.lower">
<refpurpose>Converts a string to all lowercase letters</refpurpose>

<refdescription id="string.lower-desc">
<para>Given a string, this template does a language-aware conversion
of that string to all lowercase letters, based on the values of the
<literal>uppercase.alpha</literal> and
<literal>lowercase.alpha</literal> gentext keys for the current
locale. It affects only those characters found in the values of
<literal>uppercase.alpha</literal> and
<literal>lowercase.alpha</literal>. All other characters are left
unchanged.</para>
</refdescription>

<refparameter id="string.lower-params">
<variablelist>
<varlistentry><term>string</term>
<listitem>
<para>The string to convert to lowercase.</para>
</listitem>
</varlistentry>
</variablelist>
</refparameter>
</doc:template><xsl:template name="string.lower">
  <xsl:param name="string" select="''"/>
  <xsl:variable name="uppercase.alpha">
    <xsl:call-template name="gentext">
      <xsl:with-param name="key" select="'uppercase.alpha'"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="lowercase.alpha">
    <xsl:call-template name="gentext">
      <xsl:with-param name="key" select="'lowercase.alpha'"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:value-of select="translate($string,$uppercase.alpha,$lowercase.alpha)"/>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="select.choice.separator">
  <refpurpose>Returns localized choice separator</refpurpose>
  <refdescription id="select.choice.separator-desc">
    <para>This template enables auto-generation of an appropriate
    localized "choice" separator (for example, "and" or "or") before
    the final item in an inline list (though it could also be useful
    for generating choice separators for non-inline lists).</para>
    <para>It currently works by evaluating a processing instruction
    (PI) of the form &lt;?dbchoiceÂ choice="foo"?&gt; :
    <itemizedlist>
      <listitem>
        <simpara>if the value of the <tag>choice</tag>
        pseudo-attribute is "and" or "or", returns a localized "and"
        or "or"</simpara>
      </listitem>
      <listitem>
        <simpara>otherwise returns the literal value of the
        <tag>choice</tag> pseudo-attribute</simpara>
      </listitem>
    </itemizedlist>
    The latter is provided only as a temporary workaround because the
    locale files do not currently have translations for the word
    <wordasword>or</wordasword>. So if you want to generate a a
    logical "or" separator in French (for example), you currently need
    to do this:
    <literallayout>&lt;?dbchoice choice="ou"?&gt;</literallayout>
    </para>
    <warning>
      <para>The <tag>dbchoice</tag> processing instruction is
      an unfortunate hack; support for it may disappear in the future
      (particularly if and when a more appropriate means for marking
      up "choice" lists becomes available in DocBook).</para>
    </warning>
  </refdescription>
</doc:template><xsl:template name="select.choice.separator">
  <xsl:variable name="choice">
    <xsl:call-template name="pi.dbchoice_choice"/>
  </xsl:variable>
  <xsl:choose>
    <!-- if value of $choice is "and" or "or", translate to equivalent in -->
    <!-- current locale -->
    <xsl:when test="$choice = 'and' or $choice = 'or'">
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="$choice"/>
      </xsl:call-template>
    </xsl:when>
    <!--  otherwise, just output value of $choice, whatever it is -->
    <xsl:otherwise>
      <xsl:value-of select="$choice"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="evaluate.info.profile">
  <refpurpose>Evaluates an info profile</refpurpose>
  <refdescription id="evaluate.info.profile-desc">
    <para>This template evaluates an "info profile" matching the XPath
    expression given by the <parameter>profile</parameter>
    parameter. It relies on the XSLT <function>evaluate()</function>
    extension function.</para>

    <para>The value of the <parameter>profile</parameter> parameter
    can include the literal string <literal>$info</literal>. If found
    in the value of the <parameter>profile</parameter> parameter, the
    literal string <literal>$info</literal> string is replaced with
    the value of the <parameter>info</parameter> parameter, which
    should be a set of <replaceable>*info</replaceable> nodes; the
    expression is then evaluated using the XSLT
    <function>evaluate()</function> extension function.</para>
  </refdescription>
  <refparameter id="evaluate.info.profile-params">
    <variablelist>
       <varlistentry>
        <term>profile</term>
        <listitem>
          <para>A string representing an XPath expression </para>
        </listitem>
      </varlistentry>
       <varlistentry>
        <term>info</term>
        <listitem>
          <para>A set of *info nodes</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>

  <refreturn id="evaluate.info.profile-returns">
    <para>Returns a node (the result of evaluating the
    <parameter>profile</parameter> parameter)</para>
  </refreturn>
</doc:template><xsl:template name="evaluate.info.profile">
    <xsl:param name="profile"/>
    <xsl:param name="info"/>
    <xsl:choose>
      <!-- * xsltproc and Xalan both support dyn:evaluate() -->
      <xsl:when test="function-available('dyn:evaluate')">
        <xsl:apply-templates select="dyn:evaluate($profile)" mode="get.refentry.metadata"/>
      </xsl:when>
      <!-- * Saxon has its own evaluate() & doesn't support dyn:evaluate() -->
      <xsl:when test="function-available('saxon:evaluate')">
        <xsl:apply-templates select="saxon:evaluate($profile)" mode="get.refentry.metadata"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:message terminate="yes">
Error: The "info profiling" mechanism currently requires an XSLT
engine that supports the evaluate() XSLT extension function. Your XSLT
engine does not support it.
</xsl:message>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="graphic.format.content-type">
  <refpurpose>Returns mimetype for media format</refpurpose>
  <refdescription id="graphic.format.content-type-desc">
    <para>This takes as input a 'format' param and returns
    a mimetype string.  It uses an xsl:choose after first
    converting the input to all uppercase.</para>
  </refdescription>
</doc:template><xsl:template name="graphic.format.content-type">
  <xsl:param name="format"/>
  <xsl:variable name="upperformat" select="translate($format,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
  <xsl:choose>
    <xsl:when test="$upperformat = ''"/>
    <xsl:when test="$upperformat = 'linespecific'"/>
    <xsl:when test="$upperformat = 'PS'">application/postscript</xsl:when>
    <xsl:when test="$upperformat = 'PDF'">application/pdf</xsl:when>
    <xsl:when test="$upperformat = 'PNG'">image/png</xsl:when>
    <xsl:when test="$upperformat = 'SVG'">image/svg+xml</xsl:when>
    <xsl:when test="$upperformat = 'JPG'">image/jpeg</xsl:when>
    <xsl:when test="$upperformat = 'JPEG'">image/jpeg</xsl:when>
    <xsl:when test="$upperformat = 'GIF'">image/gif</xsl:when>
    <xsl:when test="$upperformat = 'GIF87A'">image/gif</xsl:when>
    <xsl:when test="$upperformat = 'GIF89A'">image/gif</xsl:when>
    <xsl:when test="$upperformat = 'ACC'">audio/acc</xsl:when>
    <xsl:when test="$upperformat = 'MPG'">audio/mpeg</xsl:when>
    <xsl:when test="$upperformat = 'MP1'">audio/mpeg</xsl:when>
    <xsl:when test="$upperformat = 'MP2'">audio/mpeg</xsl:when>
    <xsl:when test="$upperformat = 'MP3'">audio/mpeg</xsl:when>
    <xsl:when test="$upperformat = 'M4A'">audio/mp4</xsl:when>
    <xsl:when test="$upperformat = 'MPEG'">audio/mpeg</xsl:when>
    <xsl:when test="$upperformat = 'WAV'">audio/wav</xsl:when>
    <xsl:when test="$upperformat = 'MP4'">video/mp4</xsl:when>
    <xsl:when test="$upperformat = 'M4V'">video/mp4</xsl:when>
    <xsl:when test="$upperformat = 'OGV'">video/ogg</xsl:when>
    <xsl:when test="$upperformat = 'OGG'">video/ogg</xsl:when>
    <xsl:when test="$upperformat = 'WEBM'">video/webm</xsl:when>
    <xsl:otherwise>
        <xsl:value-of select="concat('image/', $upperformat)"/> 
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<doc:reference xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" xml:id="utility">
  <info>
    <title>Common Â» Utility Template Reference</title>
    <releaseinfo role="meta">
      $Id: utility.xsl 7101 2007-07-20 15:32:12Z xmldoc $
    </releaseinfo>
  </info>
  <!-- * yes, partintro is a valid child of a reference... -->
  <partintro id="partintro">
    <title>Introduction</title>
    <para>This is technical reference documentation for the
      miscellaneous utility templates in the DocBook XSL
      Stylesheets.</para>
    <note>
      <para>These templates are defined in a separate file from the set
        of â€œcommonâ€ templates because some of the common templates
        reference DocBook XSL stylesheet parameters, requiring the
        entire set of parameters to be imported/included in any
        stylesheet that imports/includes the common templates.</para>
      <para>The utility templates donâ€™t import or include any DocBook
        XSL stylesheet parameters, so the utility templates can be used
        without importing the whole set of parameters.</para>
    </note>
    <para>This is not intended to be user documentation. It is
      provided for developers writing customization layers for the
      stylesheets.</para>
  </partintro>
</doc:reference><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="log.message">
  <refpurpose>Logs/emits formatted notes and warnings</refpurpose>

  <refdescription id="log.message-desc">
    <para>The <function>log.message</function> template is a utility
    template for logging/emitting formatted messagesÂ â€“ that is,
    notes and warnings, along with a given log â€œlevelâ€ and an
    identifier for the â€œsourceâ€ that the message relates to.</para>
  </refdescription>

  <refparameter id="log.message-params">
    <variablelist>
      <varlistentry><term>level</term>
        <listitem>
          <para>Text to log/emit in the message-level field to
            indicate the message level
          (<literal>Note</literal> or
          <literal>Warning</literal>)</para>
        </listitem>
      </varlistentry>
      <varlistentry><term>source</term>
        <listitem>
          <para>Text to log/emit in the source field to identify the
            â€œsourceâ€ to which the notification/warning relates.
            This can be any arbitrary string, but because the
            message lacks line and column numbers to identify the
            exact part of the source document to which it
            relates, the intention is that the value you pass
            into the <literal>source</literal> parameter should
            give the user some way to identify the portion of
            their source document on which to take potentially
            take action in response to the log message (for
            example, to edit, change, or add content).</para>
          <para>So the <literal>source</literal> value should be,
            for example, an ID, book/chapter/article title, title
            of some formal object, or even a string giving an
            XPath expression.</para>
        </listitem>
      </varlistentry>
      <varlistentry><term>context-desc</term>
        <listitem>
          <para>Text to log/emit in the context-description field to
            describe the context for the message.</para>
        </listitem>
      </varlistentry>
      <varlistentry><term>context-desc-field-length</term>
        <listitem>
          <para>Specifies length of the context-description field
            (in characters); default is 12</para>
          <para>If the text specified by the
            <literal>context-desc</literal> parameter is longer
            than the number of characters specified in
            <literal>context-desc-field-length</literal>, it is
            truncated to <literal>context-desc-field-length</literal>
            (12 characters by default).</para>
          <para>If the specified text is shorter than
            <literal>context-desc-field-length</literal>,
          it is right-padded out to
          <literal>context-desc-field-length</literal> (12 by
          default).</para>
        <para>If no value has been specified for the
          <literal>context-desc</literal> parameter, the field is
          left empty and the text of the log message begins with
          the value of the <literal>message</literal>
          parameter.</para>
        </listitem>
      </varlistentry>
      <varlistentry><term>message</term>
        <listitem>
          <para>Text to log/emit in the actual message field</para>
        </listitem>
      </varlistentry>
      <varlistentry><term>message-field-length</term>
        <listitem>
          <para>Specifies length of the message
            field (in characters); default is 45</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refreturn id="log.message-returns">
  <para>Outputs a message (generally, to standard error).</para></refreturn>
</doc:template><xsl:template name="log.message">
  <xsl:param name="level"/>
  <xsl:param name="source"/>
  <xsl:param name="context-desc"/>
  <xsl:param name="context-desc-field-length">12</xsl:param>
  <xsl:param name="context-desc-padded">
    <xsl:if test="not($context-desc = '')">
      <xsl:call-template name="pad-string">
        <xsl:with-param name="leftRight">right</xsl:with-param>
        <xsl:with-param name="padVar" select="substring($context-desc, 1, $context-desc-field-length)"/>
        <xsl:with-param name="length" select="$context-desc-field-length"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:param>
  <xsl:param name="message"/>
  <xsl:param name="message-field-length" select="45"/>
  <xsl:param name="message-padded">
    <xsl:variable name="spaces-for-blank-level">
      <!-- * if the level field is blank, we'll need to pad out -->
      <!-- * the message field with spaces to compensate -->
      <xsl:choose>
        <xsl:when test="$level = ''">
          <xsl:value-of select="4 + 2"/>
          <!-- * 4 = hard-coded length of comment text ("Note" or "Warn") -->
          <!-- * + 2 = length of colon-plus-space separator ": " -->
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="0"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="spaces-for-blank-context-desc">
      <!-- * if the context-description field is blank, we'll need -->
      <!-- * to pad out the message field with spaces to compensate -->
      <xsl:choose>
        <xsl:when test="$context-desc = ''">
          <xsl:value-of select="$context-desc-field-length + 2"/>
          <!-- * + 2 = length of colon-plus-space separator ": " -->
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="0"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="extra-spaces" select="$spaces-for-blank-level + $spaces-for-blank-context-desc"/>
    <xsl:call-template name="pad-string">
      <xsl:with-param name="leftRight">right</xsl:with-param>
      <xsl:with-param name="padVar" select="substring($message, 1, ($message-field-length + $extra-spaces))"/>
      <xsl:with-param name="length" select="$message-field-length + $extra-spaces"/>
    </xsl:call-template>
  </xsl:param>
  <!-- * emit the actual log message -->
  <xsl:message>
    <xsl:if test="not($level = '')">
      <xsl:value-of select="$level"/>
      <xsl:text>: </xsl:text>
    </xsl:if>
    <xsl:if test="not($context-desc = '')">
      <xsl:value-of select="$context-desc-padded"/>
      <xsl:text>: </xsl:text>
    </xsl:if>
    <xsl:value-of select="$message-padded"/>
    <xsl:text>  </xsl:text>
    <xsl:value-of select="$source"/>
  </xsl:message>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="get.doc.title">
  <refpurpose>Gets a title from the current document</refpurpose>
  <refdescription id="get.doc.title-desc">
    <para>The <function>get.doc.title</function> template is a
      utility template for returning the first title found in the
      current document.</para>
  </refdescription>
  <refreturn id="get.doc.title-returns">
  <para>Returns a string containing some identifying title for the
    current document .</para></refreturn>
</doc:template><xsl:template name="get.doc.title">
  <xsl:choose>
    <xsl:when test="//*[local-name() = 'title'       or local-name() = 'refname']">
      <xsl:value-of select="//*[local-name() = 'title'         or local-name() = 'refname'][1]"/>
    </xsl:when>
    <xsl:when test="substring(local-name(*[1]),       string-length(local-name(*[1])-3) = 'info')       and *[1]/*[local-name() = 'title']">
      <xsl:value-of select="*[1]/*[local-name() = 'title'][1]"/>
    </xsl:when>
  </xsl:choose>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="pad-string">
  <refpurpose>Right-pads or left-pads a string out to a certain length</refpurpose>
  <refdescription id="pad-string-desc">
    <para>This function takes string <parameter>padVar</parameter> and
      pads it out in the direction <parameter>rightLeft</parameter> to
      the string-length <parameter>length</parameter>, using string
      <parameter>padChar</parameter> (a space character by default) as
      the padding string (note that <parameter>padChar</parameter> can
      be a string; it is not limited to just being a single
      character).</para>
    <note>
      <para>This function began as a copy of Nate Austin's
        <function>prepend-pad</function> function in the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.dpawson.co.uk/xsl/sect2/padding.html">Padding
          Content</link> section of Dave Pawson's <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.dpawson.co.uk/xsl/index.html">XSLT
          FAQ</link>.</para>
    </note>
  </refdescription>
  <refreturn id="pad-string-returns">
  <para>Returns a (padded) string.</para></refreturn>
</doc:template><xsl:template name="pad-string">
  <!-- * recursive template to right/left pad the value with -->
  <!-- * whatever padChar is passed in -->
  <xsl:param name="padChar" select="' '"/>
  <xsl:param name="leftRight">left</xsl:param>
  <xsl:param name="padVar"/>
  <xsl:param name="length"/>
  <xsl:choose>
    <xsl:when test="string-length($padVar) &lt; $length">
      <xsl:call-template name="pad-string">
        <xsl:with-param name="padChar" select="$padChar"/>
        <xsl:with-param name="leftRight" select="$leftRight"/>
        <xsl:with-param name="padVar">
          <xsl:choose>
            <!-- * determine whether string should be -->
            <!-- * right- or left-padded -->
            <xsl:when test="$leftRight = 'left'">
              <!-- * pad it to left -->
              <xsl:value-of select="concat($padChar,$padVar)"/>
            </xsl:when>
            <xsl:otherwise>
              <!-- * otherwise, right-pad the string -->
              <xsl:value-of select="concat($padVar,$padChar)"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:with-param>
        <xsl:with-param name="length" select="$length"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="substring($padVar,string-length($padVar) - $length + 1)"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<doc:mode xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" mode="label.markup">
<refpurpose>Provides access to element labels</refpurpose>
<refdescription id="label.markup-desc">
<para>Processing an element in the
<literal role="mode">label.markup</literal> mode produces the
element label.</para>
<para>Trailing punctuation is not added to the label.
</para>
</refdescription>
</doc:mode><xsl:template match="*" mode="intralabel.punctuation">
  <xsl:text>.</xsl:text>
</xsl:template><xsl:template match="*" mode="label.markup">
  <xsl:param name="verbose" select="1"/>
  <xsl:if test="$verbose">
    <xsl:message>
      <xsl:text>Request for label of unexpected element: </xsl:text>
      <xsl:value-of select="local-name(.)"/>
    </xsl:message>
  </xsl:if>
</xsl:template><xsl:template match="set|book" mode="label.markup">
  <xsl:if test="@label">
    <xsl:value-of select="@label"/>
  </xsl:if>
</xsl:template><xsl:template match="part" mode="label.markup">
  <xsl:choose>
    <xsl:when test="@label">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:when test="string($part.autolabel) != 0">
      <xsl:variable name="format">
        <xsl:call-template name="autolabel.format">
          <xsl:with-param name="format" select="$part.autolabel"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:number from="book" count="part" format="{$format}"/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="partintro" mode="label.markup">
  <!-- no label -->
</xsl:template><xsl:template match="preface" mode="label.markup">
  <xsl:choose>
    <xsl:when test="@label">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:when test="string($preface.autolabel) != 0">
      <xsl:if test="$component.label.includes.part.label != 0 and                       ancestor::part">
        <xsl:variable name="part.label">
          <xsl:apply-templates select="ancestor::part" mode="label.markup"/>
        </xsl:variable>
        <xsl:if test="$part.label != ''">
          <xsl:value-of select="$part.label"/>
          <xsl:apply-templates select="ancestor::part" mode="intralabel.punctuation"/>
        </xsl:if>
      </xsl:if>
      <xsl:variable name="format">
        <xsl:call-template name="autolabel.format">
          <xsl:with-param name="format" select="$preface.autolabel"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="$label.from.part != 0 and ancestor::part">
          <xsl:number from="part" count="preface" format="{$format}" level="any"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number from="book" count="preface" format="{$format}" level="any"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="chapter" mode="label.markup">
  <xsl:choose>
    <xsl:when test="@label">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:when test="string($chapter.autolabel) != 0">
      <xsl:if test="$component.label.includes.part.label != 0 and                       ancestor::part">
        <xsl:variable name="part.label">
          <xsl:apply-templates select="ancestor::part" mode="label.markup"/>
        </xsl:variable>
        <xsl:if test="$part.label != ''">
          <xsl:value-of select="$part.label"/>
          <xsl:apply-templates select="ancestor::part" mode="intralabel.punctuation"/>
        </xsl:if>
      </xsl:if>
      <xsl:variable name="format">
        <xsl:call-template name="autolabel.format">
          <xsl:with-param name="format" select="$chapter.autolabel"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="$label.from.part != 0 and ancestor::part">
          <xsl:number from="part" count="chapter" format="{$format}" level="any"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number from="book" count="chapter" format="{$format}" level="any"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="appendix" mode="label.markup">
  <xsl:choose>
    <xsl:when test="@label">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:when test="string($appendix.autolabel) != 0">
      <xsl:if test="$component.label.includes.part.label != 0 and                       ancestor::part">
        <xsl:variable name="part.label">
          <xsl:apply-templates select="ancestor::part" mode="label.markup"/>
        </xsl:variable>
        <xsl:if test="$part.label != ''">
          <xsl:value-of select="$part.label"/>
          <xsl:apply-templates select="ancestor::part" mode="intralabel.punctuation"/>
        </xsl:if>
      </xsl:if>
      <xsl:variable name="format">
        <xsl:call-template name="autolabel.format">
          <xsl:with-param name="format" select="$appendix.autolabel"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="$label.from.part != 0 and ancestor::part">
          <xsl:number from="part" count="appendix" format="{$format}" level="any"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number from="book|article" count="appendix" format="{$format}" level="any"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="article" mode="label.markup">
  <xsl:if test="@label">
    <xsl:value-of select="@label"/>
  </xsl:if>
</xsl:template><xsl:template match="dedication|colophon" mode="label.markup">
  <xsl:if test="@label">
    <xsl:value-of select="@label"/>
  </xsl:if>
</xsl:template><xsl:template match="reference" mode="label.markup">
  <xsl:choose>
    <xsl:when test="@label">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:when test="string($reference.autolabel) != 0">
      <xsl:if test="$component.label.includes.part.label != 0 and                       ancestor::part">
        <xsl:variable name="part.label">
          <xsl:apply-templates select="ancestor::part" mode="label.markup"/>
        </xsl:variable>
        <xsl:if test="$part.label != ''">
          <xsl:value-of select="$part.label"/>
          <xsl:apply-templates select="ancestor::part" mode="intralabel.punctuation"/>
        </xsl:if>
      </xsl:if>
      <xsl:variable name="format">
        <xsl:call-template name="autolabel.format">
          <xsl:with-param name="format" select="$reference.autolabel"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="$label.from.part != 0 and ancestor::part">
          <xsl:number from="part" count="reference" format="{$format}" level="any"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number from="book" count="reference" format="{$format}" level="any"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="refentry" mode="label.markup">
  <xsl:if test="@label">
    <xsl:value-of select="@label"/>
  </xsl:if>
</xsl:template><xsl:template match="section" mode="label.markup">
  <!-- if this is a nested section, label the parent -->
  <xsl:if test="local-name(..) = 'section'">
    <xsl:variable name="parent.section.label">
      <xsl:call-template name="label.this.section">
        <xsl:with-param name="section" select=".."/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:if test="$parent.section.label != '0'">
      <xsl:apply-templates select=".." mode="label.markup"/>
      <xsl:apply-templates select=".." mode="intralabel.punctuation"/>
    </xsl:if>
  </xsl:if>

  <!-- if the parent is a component, maybe label that too -->
  <xsl:variable name="parent.is.component">
    <xsl:call-template name="is.component">
      <xsl:with-param name="node" select=".."/>
    </xsl:call-template>
  </xsl:variable>

  <!-- does this section get labelled? -->
  <xsl:variable name="label">
    <xsl:call-template name="label.this.section">
      <xsl:with-param name="section" select="."/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:if test="$section.label.includes.component.label != 0                 and $parent.is.component != 0">
    <xsl:variable name="parent.label">
      <xsl:apply-templates select=".." mode="label.markup"/>
    </xsl:variable>
    <xsl:if test="$parent.label != ''">
      <xsl:apply-templates select=".." mode="label.markup"/>
      <xsl:apply-templates select=".." mode="intralabel.punctuation"/>
    </xsl:if>
  </xsl:if>

<!--
  <xsl:message>
    test: <xsl:value-of select="$label"/>, <xsl:number count="section"/>
  </xsl:message>
-->

  <xsl:choose>
    <xsl:when test="@label">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:when test="$label != 0">      
      <xsl:variable name="format">
        <xsl:call-template name="autolabel.format">
          <xsl:with-param name="format" select="$section.autolabel"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:number format="{$format}" count="section"/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="sect1" mode="label.markup">
  <!-- if the parent is a component, maybe label that too -->
  <xsl:variable name="parent.is.component">
    <xsl:call-template name="is.component">
      <xsl:with-param name="node" select=".."/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="component.label">
    <xsl:if test="$section.label.includes.component.label != 0                   and $parent.is.component != 0">
      <xsl:variable name="parent.label">
        <xsl:apply-templates select=".." mode="label.markup"/>
      </xsl:variable>
      <xsl:if test="$parent.label != ''">
        <xsl:apply-templates select=".." mode="label.markup"/>
        <xsl:apply-templates select=".." mode="intralabel.punctuation"/>
      </xsl:if>
    </xsl:if>
  </xsl:variable>


  <xsl:variable name="is.numbered">
    <xsl:call-template name="label.this.section"/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="@label">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:when test="$is.numbered != 0">
      <xsl:variable name="format">
        <xsl:call-template name="autolabel.format">
          <xsl:with-param name="format" select="$section.autolabel"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:copy-of select="$component.label"/>
      <xsl:number format="{$format}" count="sect1"/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="sect2|sect3|sect4|sect5" mode="label.markup">
  <!-- label the parent -->
  <xsl:variable name="parent.section.label">
    <xsl:call-template name="label.this.section">
      <xsl:with-param name="section" select=".."/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:if test="$parent.section.label != '0'">
    <xsl:apply-templates select=".." mode="label.markup"/>
    <xsl:apply-templates select=".." mode="intralabel.punctuation"/>
  </xsl:if>

  <xsl:variable name="is.numbered">
    <xsl:call-template name="label.this.section"/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="@label">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:when test="$is.numbered != 0">
      <xsl:variable name="format">
        <xsl:call-template name="autolabel.format">
          <xsl:with-param name="format" select="$section.autolabel"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="local-name(.) = 'sect2'">
          <xsl:number format="{$format}" count="sect2"/>
        </xsl:when>
        <xsl:when test="local-name(.) = 'sect3'">
          <xsl:number format="{$format}" count="sect3"/>
        </xsl:when>
        <xsl:when test="local-name(.) = 'sect4'">
          <xsl:number format="{$format}" count="sect4"/>
        </xsl:when>
        <xsl:when test="local-name(.) = 'sect5'">
          <xsl:number format="{$format}" count="sect5"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message>label.markup: this can't happen!</xsl:message>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="bridgehead" mode="label.markup">
  <!-- bridgeheads are not normally numbered -->
</xsl:template><xsl:template match="refsect1" mode="label.markup">
  <xsl:choose>
    <xsl:when test="@label">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:when test="$section.autolabel != 0">
      <xsl:variable name="format">
        <xsl:call-template name="autolabel.format">
          <xsl:with-param name="format" select="$section.autolabel"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:number count="refsect1" format="{$format}"/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="refsect2|refsect3" mode="label.markup">
  <!-- label the parent -->
  <xsl:variable name="parent.label">
    <xsl:apply-templates select=".." mode="label.markup"/>
  </xsl:variable>
  <xsl:if test="$parent.label != ''">
    <xsl:apply-templates select=".." mode="label.markup"/>
    <xsl:apply-templates select=".." mode="intralabel.punctuation"/>
  </xsl:if>

  <xsl:choose>
    <xsl:when test="@label">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:when test="$section.autolabel != 0">
      <xsl:variable name="format">
        <xsl:call-template name="autolabel.format">
          <xsl:with-param name="format" select="$section.autolabel"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="local-name(.) = 'refsect2'">
          <xsl:number count="refsect2" format="{$format}"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number count="refsect3" format="{$format}"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="simplesect" mode="label.markup">
  <!-- if this is a nested section, label the parent -->
  <xsl:if test="local-name(..) = 'section'                 or local-name(..) = 'sect1'                 or local-name(..) = 'sect2'                 or local-name(..) = 'sect3'                 or local-name(..) = 'sect4'                 or local-name(..) = 'sect5'">
    <xsl:variable name="parent.section.label">
      <xsl:apply-templates select=".." mode="label.markup"/>
    </xsl:variable>
    <xsl:if test="$parent.section.label != ''">
      <xsl:apply-templates select=".." mode="label.markup"/>
      <xsl:apply-templates select=".." mode="intralabel.punctuation"/>
    </xsl:if>
  </xsl:if>

  <!-- if the parent is a component, maybe label that too -->
  <xsl:variable name="parent.is.component">
    <xsl:call-template name="is.component">
      <xsl:with-param name="node" select=".."/>
    </xsl:call-template>
  </xsl:variable>

  <!-- does this section get labelled? -->
  <xsl:variable name="label">
    <xsl:call-template name="label.this.section">
      <xsl:with-param name="section" select="."/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:if test="$section.label.includes.component.label != 0                 and $parent.is.component != 0">
    <xsl:variable name="parent.label">
      <xsl:apply-templates select=".." mode="label.markup"/>
    </xsl:variable>
    <xsl:if test="$parent.label != ''">
      <xsl:apply-templates select=".." mode="label.markup"/>
      <xsl:apply-templates select=".." mode="intralabel.punctuation"/>
    </xsl:if>
  </xsl:if>

  <xsl:choose>
    <xsl:when test="@label">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:when test="$label != 0">
      <xsl:variable name="format">
        <xsl:call-template name="autolabel.format">
          <xsl:with-param name="format" select="$section.autolabel"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:number format="{$format}" count="simplesect"/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="topic" mode="label.markup">
  <!-- topics are not numbered by default -->
</xsl:template><xsl:template match="qandadiv" mode="label.markup">
  <xsl:variable name="lparent" select="(ancestor::set                                        |ancestor::book                                        |ancestor::chapter                                        |ancestor::appendix                                        |ancestor::preface                                        |ancestor::section                                        |ancestor::simplesect                                        |ancestor::sect1                                        |ancestor::sect2                                        |ancestor::sect3                                        |ancestor::sect4                                        |ancestor::sect5                                        |ancestor::refsect1                                        |ancestor::refsect2                                        |ancestor::refsect3)[last()]"/>

  <xsl:variable name="lparent.prefix">
    <xsl:apply-templates select="$lparent" mode="label.markup"/>
  </xsl:variable>

  <xsl:variable name="prefix">
    <xsl:if test="$qanda.inherit.numeration != 0">
      <xsl:if test="$lparent.prefix != ''">
        <xsl:apply-templates select="$lparent" mode="label.markup"/>
        <xsl:apply-templates select="$lparent" mode="intralabel.punctuation"/>
      </xsl:if>
    </xsl:if>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$qandadiv.autolabel != 0">
      <xsl:variable name="format">
        <xsl:call-template name="autolabel.format">
          <xsl:with-param name="format" select="$qandadiv.autolabel"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:value-of select="$prefix"/>
      <xsl:number level="multiple" count="qandadiv" format="{$format}"/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="question|answer" mode="label.markup">
  <xsl:variable name="lparent" select="(ancestor::set                                        |ancestor::book                                        |ancestor::chapter                                        |ancestor::appendix                                        |ancestor::preface                                        |ancestor::section                                        |ancestor::simplesect                                        |ancestor::sect1                                        |ancestor::sect2                                        |ancestor::sect3                                        |ancestor::sect4                                        |ancestor::sect5                                        |ancestor::refsect1                                        |ancestor::refsect2                                        |ancestor::refsect3)[last()]"/>

  <xsl:variable name="lparent.prefix">
    <xsl:apply-templates select="$lparent" mode="label.markup"/>
  </xsl:variable>

  <xsl:variable name="prefix">
    <xsl:if test="$qanda.inherit.numeration != 0">
      <xsl:choose>
        <xsl:when test="ancestor::qandadiv">
          <xsl:variable name="div.label">
            <xsl:apply-templates select="ancestor::qandadiv[1]" mode="label.markup"/>
          </xsl:variable>
          <xsl:if test="string-length($div.label) != 0">
            <xsl:copy-of select="$div.label"/>
            <xsl:apply-templates select="ancestor::qandadiv[1]" mode="intralabel.punctuation"/>
          </xsl:if>
        </xsl:when>
        <xsl:when test="$lparent.prefix != ''">
          <xsl:apply-templates select="$lparent" mode="label.markup"/>
          <xsl:apply-templates select="$lparent" mode="intralabel.punctuation"/>
        </xsl:when>
      </xsl:choose>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="inhlabel" select="ancestor-or-self::qandaset/@defaultlabel[1]"/>

  <xsl:variable name="deflabel">
    <xsl:choose>
      <xsl:when test="$inhlabel != ''">
        <xsl:value-of select="$inhlabel"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$qanda.defaultlabel"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="label" select="label"/>

  <xsl:choose>
    <xsl:when test="count($label)&gt;0">
      <xsl:apply-templates select="$label"/>
    </xsl:when>

    <xsl:when test="$deflabel = 'qanda' and self::question">
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="'Question'"/>
      </xsl:call-template>
    </xsl:when>

    <xsl:when test="$deflabel = 'qanda' and self::answer">
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="'Answer'"/>
      </xsl:call-template>
    </xsl:when>

    <xsl:when test="($deflabel = 'qnumber' or                      $deflabel = 'qnumberanda') and self::question">
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="'Question'"/>
      </xsl:call-template>
      <xsl:text>Â </xsl:text>
      <xsl:value-of select="$prefix"/>
      <xsl:number level="multiple" count="qandaentry" format="1"/>
    </xsl:when>

    <xsl:when test="$deflabel = 'qnumberanda' and self::answer">
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="'Answer'"/>
      </xsl:call-template>
    </xsl:when>

    <xsl:when test="$deflabel = 'number' and self::question">
      <xsl:value-of select="$prefix"/>
      <xsl:number level="multiple" count="qandaentry" format="1"/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="bibliography|glossary|                      qandaset|index|setindex" mode="label.markup">
  <xsl:if test="@label">
    <xsl:value-of select="@label"/>
  </xsl:if>
</xsl:template><xsl:template match="figure|table|example" mode="label.markup">
  <xsl:variable name="pchap" select="(ancestor::chapter                         |ancestor::appendix                         |ancestor::article[ancestor::book])[last()]"/>

  <xsl:variable name="prefix">
    <xsl:if test="count($pchap) &gt; 0">
      <xsl:apply-templates select="$pchap" mode="label.markup"/>
    </xsl:if>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="@label">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="$prefix != ''">
            <xsl:apply-templates select="$pchap" mode="label.markup"/>
            <xsl:apply-templates select="$pchap" mode="intralabel.punctuation"/>
          <xsl:number format="1" from="chapter|appendix" level="any"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number format="1" from="book|article|section" level="any"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="procedure" mode="label.markup">
  <xsl:variable name="pchap" select="ancestor::chapter                         |ancestor::appendix                         |ancestor::article[ancestor::book]"/>

  <xsl:variable name="prefix">
    <xsl:if test="count($pchap) &gt; 0">
      <xsl:apply-templates select="$pchap" mode="label.markup"/>
    </xsl:if>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="@label">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:when test="$formal.procedures = 0">
      <!-- No label -->
    </xsl:when>
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="count($pchap)&gt;0">
          <xsl:if test="$prefix != ''">
            <xsl:apply-templates select="$pchap" mode="label.markup"/>
            <xsl:apply-templates select="$pchap" mode="intralabel.punctuation"/>
          </xsl:if>
          <xsl:number count="procedure[title]" format="1" from="chapter|appendix" level="any"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number count="procedure[title]" format="1" from="book|article|section" level="any"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="equation" mode="label.markup">
  <xsl:variable name="pchap" select="ancestor::chapter                         |ancestor::appendix                         |ancestor::article[ancestor::book]"/>

  <xsl:variable name="prefix">
    <xsl:if test="count($pchap) &gt; 0">
      <xsl:apply-templates select="$pchap" mode="label.markup"/>
    </xsl:if>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="@label">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="count($pchap)&gt;0">
          <xsl:if test="$prefix != ''">
            <xsl:apply-templates select="$pchap" mode="label.markup"/>
            <xsl:apply-templates select="$pchap" mode="intralabel.punctuation"/>
          </xsl:if>
          <xsl:number format="1" count="equation" from="chapter|appendix" level="any"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number format="1" count="equation" from="book|article|section" level="any"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="orderedlist/listitem" mode="label.markup">
  <xsl:variable name="numeration">
    <xsl:call-template name="list.numeration">
      <xsl:with-param name="node" select="parent::orderedlist"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="type">
    <xsl:choose>
      <xsl:when test="$numeration='arabic'">1</xsl:when>
      <xsl:when test="$numeration='loweralpha'">a</xsl:when>
      <xsl:when test="$numeration='lowerroman'">i</xsl:when>
      <xsl:when test="$numeration='upperalpha'">A</xsl:when>
      <xsl:when test="$numeration='upperroman'">I</xsl:when>
      <!-- What!? This should never happen -->
      <xsl:otherwise>
        <xsl:message>
          <xsl:text>Unexpected numeration: </xsl:text>
          <xsl:value-of select="$numeration"/>
        </xsl:message>
        <xsl:value-of select="1."/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="item-number">
    <xsl:call-template name="orderedlist-item-number"/>
  </xsl:variable>

  <xsl:number value="$item-number" format="{$type}"/>
</xsl:template><xsl:template match="production" mode="label.markup">
  <xsl:number count="production" level="any"/>
</xsl:template><xsl:template match="abstract" mode="label.markup">
  <!-- nop -->
</xsl:template><xsl:template match="sidebar" mode="label.markup">
  <!-- nop -->
</xsl:template><xsl:template match="glossdiv|glosslist" mode="label.markup">
  <!-- nop -->
</xsl:template><xsl:template match="glossentry" mode="label.markup">
  <!-- nop -->
</xsl:template><xsl:template name="label.this.section">
  <xsl:param name="section" select="."/>

  <xsl:variable name="level">
    <xsl:call-template name="section.level"/>
  </xsl:variable>

  <xsl:choose>
    <!-- bridgeheads are not numbered -->
    <xsl:when test="$section/self::bridgehead">0</xsl:when>
    <xsl:when test="$level &lt;= $section.autolabel.max.depth">      
      <xsl:value-of select="$section.autolabel"/>
    </xsl:when>
    <xsl:otherwise>0</xsl:otherwise>
  </xsl:choose>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="label.this.section">
<refpurpose>Returns true if $section should be labelled</refpurpose>
<refdescription id="label.this.section-desc">
<para>Returns true if the specified section should be labelled.
By default, this template returns zero unless 
the section level is less than or equal to the value of the
<literal>$section.autolabel.max.depth</literal> parameter, in
which case it returns
<literal>$section.autolabel</literal>.
Custom stylesheets may override it to get more selective behavior.</para>
</refdescription>
</doc:template><xsl:template name="default.autolabel.format">
  <xsl:param name="context" select="."/>
  <xsl:choose>
    <xsl:when test="local-name($context) = 'appendix'">
      <xsl:value-of select="'A'"/>
    </xsl:when>
    <xsl:when test="local-name($context) = 'part'">
      <xsl:value-of select="'I'"/>
    </xsl:when>
    <xsl:otherwise>1</xsl:otherwise>
  </xsl:choose>  
</xsl:template><xsl:template name="autolabel.format">
  <xsl:param name="context" select="."/>
  <xsl:param name="format"/>

  <xsl:choose>
    <xsl:when test="string($format) != 0">
      <xsl:choose>
        <xsl:when test="string($format)='arabic' or $format='1'">1</xsl:when>
        <xsl:when test="$format='loweralpha' or $format='a'">
          <xsl:value-of select="'a'"/>
        </xsl:when>
        <xsl:when test="$format='lowerroman' or $format='i'">
          <xsl:value-of select="'i'"/>
        </xsl:when>
        <xsl:when test="$format='upperalpha' or $format='A'">
          <xsl:value-of select="'A'"/>
        </xsl:when>
        <xsl:when test="$format='upperroman' or $format='I'">
          <xsl:value-of select="'I'"/>
        </xsl:when>      
        <xsl:when test="$format='arabicindic' or $format='&#x661;'">
          <xsl:value-of select="'&#x661;'"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message>
            <xsl:text>Unexpected </xsl:text><xsl:value-of select="local-name(.)"/><xsl:text>.autolabel value: </xsl:text>
            <xsl:value-of select="$format"/><xsl:text>; using default.</xsl:text>
          </xsl:message>
          <xsl:call-template name="default.autolabel.format"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
  </xsl:choose>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="autolabel.format">
<refpurpose>Returns format for autolabel parameters</refpurpose>
<refdescription id="autolabel.format-desc">
<para>Returns format passed as parameter if non zero. Supported
  format are 'arabic' or '1', 'loweralpha' or 'a', 'lowerroman' or 'i', 
  'upperlapha' or 'A', 'upperroman' or 'I', 'arabicindic' or 'Ù¡'.
  If its not one of these then 
  returns the default format.</para>
</refdescription>
</doc:template>
<doc:mode xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" mode="title.markup">
<refpurpose>Provides access to element titles</refpurpose>
<refdescription id="title.markup-desc">
<para>Processing an element in the
<literal role="mode">title.markup</literal> mode produces the
title of the element. This does not include the label.
</para>
</refdescription>
</doc:mode><xsl:template match="*" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:param name="verbose" select="1"/>
  <xsl:choose>
    <!-- * FIXME: this should handle other *info elements as well -->
    <!-- * but this is good enough for now. -->
    <xsl:when test="title|info/title">
      <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:when test="local-name(.) = 'partintro'">
      <!-- partintro's don't have titles, use the parent (part or reference)
           title instead. -->
      <xsl:apply-templates select="parent::*" mode="title.markup"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:if test="$verbose != 0">
        <xsl:message>
          <xsl:text>Request for title of element with no title: </xsl:text>
          <xsl:value-of select="local-name(.)"/>
          <xsl:choose>
            <xsl:when test="@id">
              <xsl:text> (id="</xsl:text>
              <xsl:value-of select="@id"/>
              <xsl:text>")</xsl:text>
            </xsl:when>
            <xsl:when test="@xml:id">
              <xsl:text> (xml:id="</xsl:text>
              <xsl:value-of select="@xml:id"/>
              <xsl:text>")</xsl:text>
            </xsl:when>
            <xsl:otherwise>
              <xsl:text> (contained in </xsl:text>
              <xsl:value-of select="local-name(..)"/>
              <xsl:if test="../@id or ../@xml:id">
                <xsl:text> with id </xsl:text>
                <xsl:value-of select="../@id | ../@xml:id"/>
              </xsl:if>
              <xsl:text>)</xsl:text>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:message>
      </xsl:if>
      <xsl:text>???TITLE???</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="title" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>

  <xsl:choose>
    <xsl:when test="$allow-anchors != 0">
      <xsl:apply-templates/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="no.anchor.mode"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="caption" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>

  <xsl:choose>
    <xsl:when test="$allow-anchors != 0">
      <xsl:apply-templates/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="no.anchor.mode"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="set" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:apply-templates select="(setinfo/title|info/title|title)[1]" mode="title.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="book" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:apply-templates select="(bookinfo/title|info/title|title)[1]" mode="title.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="part" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:apply-templates select="(partinfo/title|info/title|docinfo/title|title)[1]" mode="title.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="preface|chapter|appendix" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>

<!--
  <xsl:message>
    <xsl:value-of select="local-name(.)"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="$allow-anchors"/>
  </xsl:message>
-->

  <xsl:variable name="title" select="(docinfo/title                                       |info/title                                       |prefaceinfo/title                                       |chapterinfo/title                                       |appendixinfo/title                                       |title)[1]"/>
  <xsl:apply-templates select="$title" mode="title.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="dedication" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:choose>
    <xsl:when test="title|info/title">
      <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="'Dedication'"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="acknowledgements" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:choose>
    <xsl:when test="title|info/title">
      <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="'Acknowledgements'"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="colophon" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:choose>
    <xsl:when test="title|info/title">
      <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="'Colophon'"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="article" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:variable name="title" select="(artheader/title                                       |articleinfo/title                                       |info/title                                       |title)[1]"/>

  <xsl:apply-templates select="$title" mode="title.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="reference" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:apply-templates select="(referenceinfo/title|docinfo/title|info/title|title)[1]" mode="title.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="refentry" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:variable name="refmeta" select=".//refmeta"/>
  <xsl:variable name="refentrytitle" select="$refmeta//refentrytitle"/>
  <xsl:variable name="refnamediv" select=".//refnamediv"/>
  <xsl:variable name="refname" select="$refnamediv//refname"/>
  <xsl:variable name="refdesc" select="$refnamediv//refdescriptor"/>

  <xsl:variable name="title">
    <xsl:choose>
      <xsl:when test="$refentrytitle">
        <xsl:apply-templates select="$refentrytitle[1]" mode="title.markup"/>
      </xsl:when>
      <xsl:when test="$refdesc">
        <xsl:apply-templates select="$refdesc" mode="title.markup"/>
      </xsl:when>
      <xsl:when test="$refname">
        <xsl:apply-templates select="$refname[1]" mode="title.markup"/>
      </xsl:when>
      <xsl:otherwise>REFENTRY WITHOUT TITLE???</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:copy-of select="$title"/>
</xsl:template><xsl:template match="refentrytitle|refname|refdescriptor" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:choose>
    <xsl:when test="$allow-anchors != 0">
      <xsl:apply-templates/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="no.anchor.mode"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="section                      |sect1|sect2|sect3|sect4|sect5                      |refsect1|refsect2|refsect3|refsection                      |topic                      |simplesect" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:variable name="title" select="(info/title                                       |sectioninfo/title                                       |sect1info/title                                       |sect2info/title                                       |sect3info/title                                       |sect4info/title                                       |sect5info/title                                       |refsect1info/title                                       |refsect2info/title                                       |refsect3info/title                                       |refsectioninfo/title                                       |title)[1]"/>

  <xsl:apply-templates select="$title" mode="title.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="bridgehead" mode="title.markup">
  <xsl:apply-templates/> 
</xsl:template><xsl:template match="refsynopsisdiv" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:choose>
    <xsl:when test="title|info/title">
      <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="'RefSynopsisDiv'"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="bibliography" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:variable name="title" select="(bibliographyinfo/title|info/title|title)[1]"/>
  <xsl:choose>
    <xsl:when test="$title">
      <xsl:apply-templates select="$title" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="'Bibliography'"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="glossary" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:variable name="title" select="(glossaryinfo/title|info/title|title)[1]"/>
  <xsl:choose>
    <xsl:when test="$title">
      <xsl:apply-templates select="$title" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext.element.name">
        <xsl:with-param name="element.name" select="local-name(.)"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="glossdiv" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:variable name="title" select="(info/title|title)[1]"/>
  <xsl:choose>
    <xsl:when test="$title">
      <xsl:apply-templates select="$title" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:message>ERROR: glossdiv missing its required title</xsl:message>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="glossentry" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:apply-templates select="glossterm" mode="title.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="glossterm|firstterm" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>

  <xsl:choose>
    <xsl:when test="$allow-anchors != 0">
      <xsl:apply-templates/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="no.anchor.mode"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="index" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:variable name="title" select="(indexinfo/title|info/title|title)[1]"/>
  <xsl:choose>
    <xsl:when test="$title">
      <xsl:apply-templates select="$title" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="'Index'"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="setindex" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:variable name="title" select="(setindexinfo/title|info/title|title)[1]"/>
  <xsl:choose>
    <xsl:when test="$title">
      <xsl:apply-templates select="$title" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="'SetIndex'"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="figure|example|equation" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="table" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:apply-templates select="(title|info/title|caption)[1]" mode="title.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="procedure" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="task" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="sidebar" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:apply-templates select="(info/title|sidebarinfo/title|title)[1]" mode="title.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="abstract" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:choose>
    <xsl:when test="title|info/title">
      <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="'Abstract'"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="caution|tip|warning|important|note" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:variable name="title" select="(title|info/title)[1]"/>
  <xsl:choose>
    <xsl:when test="$title">
      <xsl:apply-templates select="$title" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext">
        <xsl:with-param name="key">
          <xsl:choose>
            <xsl:when test="local-name(.)='note'">Note</xsl:when>
            <xsl:when test="local-name(.)='important'">Important</xsl:when>
            <xsl:when test="local-name(.)='caution'">Caution</xsl:when>
            <xsl:when test="local-name(.)='warning'">Warning</xsl:when>
            <xsl:when test="local-name(.)='tip'">Tip</xsl:when>
          </xsl:choose>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="question" mode="title.markup">
  <!-- questions don't have titles -->
  <xsl:text>Question</xsl:text>
</xsl:template><xsl:template match="answer" mode="title.markup">
  <!-- answers don't have titles -->
  <xsl:text>Answer</xsl:text>
</xsl:template><xsl:template match="qandaentry" mode="title.markup">
  <!-- qandaentrys are represented by the first question in them -->
  <xsl:text>Question</xsl:text>
</xsl:template><xsl:template match="qandaset" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:variable name="title" select="(info/title|                                       blockinfo/title|                                       title)[1]"/>
  <xsl:choose>
    <xsl:when test="$title">
      <xsl:apply-templates select="$title" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="'QandASet'"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="legalnotice" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:choose>
    <xsl:when test="title|info/title">
      <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext">
        <xsl:with-param name="key" select="'LegalNotice'"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="titleabbrev"/><xsl:template match="*" mode="titleabbrev.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:choose>
    <xsl:when test="titleabbrev">
      <xsl:apply-templates select="titleabbrev[1]" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:when test="info/titleabbrev">
      <xsl:apply-templates select="info/titleabbrev[1]" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="." mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        <xsl:with-param name="verbose" select="$verbose"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="book|part|set|preface|chapter|appendix" mode="titleabbrev.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:variable name="titleabbrev" select="(docinfo/titleabbrev                                            |bookinfo/titleabbrev                                            |info/titleabbrev                                            |prefaceinfo/titleabbrev                                            |setinfo/titleabbrev                                            |partinfo/titleabbrev                                            |chapterinfo/titleabbrev                                            |appendixinfo/titleabbrev                                            |titleabbrev)[1]"/>

  <xsl:choose>
    <xsl:when test="$titleabbrev">
      <xsl:apply-templates select="$titleabbrev" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="." mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        <xsl:with-param name="verbose" select="$verbose"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="article" mode="titleabbrev.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:variable name="titleabbrev" select="(artheader/titleabbrev                                            |articleinfo/titleabbrev                                            |info/titleabbrev                                            |titleabbrev)[1]"/>

  <xsl:choose>
    <xsl:when test="$titleabbrev">
      <xsl:apply-templates select="$titleabbrev" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="." mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        <xsl:with-param name="verbose" select="$verbose"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="section                      |sect1|sect2|sect3|sect4|sect5                      |refsect1|refsect2|refsect3                      |topic                      |simplesect" mode="titleabbrev.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:variable name="titleabbrev" select="(info/titleabbrev                                             |sectioninfo/titleabbrev                                             |sect1info/titleabbrev                                             |sect2info/titleabbrev                                             |sect3info/titleabbrev                                             |sect4info/titleabbrev                                             |sect5info/titleabbrev                                             |refsect1info/titleabbrev                                             |refsect2info/titleabbrev                                             |refsect3info/titleabbrev                                             |titleabbrev)[1]"/>

  <xsl:choose>
    <xsl:when test="$titleabbrev">
      <xsl:apply-templates select="$titleabbrev" mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="." mode="title.markup">
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        <xsl:with-param name="verbose" select="$verbose"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="titleabbrev" mode="title.markup">
  <xsl:param name="allow-anchors" select="0"/>

  <xsl:choose>
    <xsl:when test="$allow-anchors != 0">
      <xsl:apply-templates/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="no.anchor.mode"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="*" mode="no.anchor.mode">
  <!-- Switch to normal mode if no links -->
  <xsl:choose>
    <xsl:when test="descendant-or-self::footnote or                     descendant-or-self::anchor or                     descendant-or-self::ulink or                     descendant-or-self::link or                     descendant-or-self::olink or                     descendant-or-self::xref or                     descendant-or-self::indexterm or       (ancestor::title and (@id or @xml:id))">

      <xsl:apply-templates mode="no.anchor.mode"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="."/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="footnote" mode="no.anchor.mode">
  <!-- nop, suppressed -->
</xsl:template><xsl:template match="anchor" mode="no.anchor.mode">
  <!-- nop, suppressed -->
</xsl:template><xsl:template match="ulink" mode="no.anchor.mode">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="link" mode="no.anchor.mode">
  <xsl:choose>
    <xsl:when test="count(child::node()) &gt; 0">
      <!-- If it has content, use it -->
      <xsl:apply-templates/>
    </xsl:when>
	<!-- look for an endterm -->
    <xsl:when test="@endterm">
      <xsl:variable name="etargets" select="key('id',@endterm)"/>
      <xsl:variable name="etarget" select="$etargets[1]"/>
      <xsl:choose>
	<xsl:when test="count($etarget) = 0">
          <xsl:message>
	    <xsl:value-of select="count($etargets)"/>
	    <xsl:text>Endterm points to nonexistent ID: </xsl:text>
	    <xsl:value-of select="@endterm"/>
          </xsl:message>
	  <xsl:text>???</xsl:text>
	</xsl:when>
        <xsl:otherwise>
	  <xsl:apply-templates select="$etarget" mode="endterm"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="olink" mode="no.anchor.mode">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="indexterm" mode="no.anchor.mode">
  <!-- nop, suppressed -->
</xsl:template><xsl:template match="xref" mode="no.anchor.mode">
  <xsl:variable name="targets" select="key('id',@linkend)|key('id',substring-after(@xlink:href,'#'))"/>
  <xsl:variable name="target" select="$targets[1]"/>
  <xsl:variable name="refelem" select="local-name($target)"/>
  
  <xsl:call-template name="check.id.unique">
    <xsl:with-param name="linkend" select="@linkend"/>
  </xsl:call-template>

  <xsl:choose>
    <xsl:when test="count($target) = 0">
      <xsl:message>
        <xsl:text>XRef to nonexistent id: </xsl:text>
        <xsl:value-of select="@linkend"/> 
        <xsl:value-of select="@xlink:href"/>
      </xsl:message>
      <xsl:text>???</xsl:text>
    </xsl:when>

    <xsl:when test="@endterm">
      <xsl:variable name="etargets" select="key('id',@endterm)"/>
      <xsl:variable name="etarget" select="$etargets[1]"/>
      <xsl:choose>
        <xsl:when test="count($etarget) = 0">
          <xsl:message>
            <xsl:value-of select="count($etargets)"/>
            <xsl:text>Endterm points to nonexistent ID: </xsl:text>
            <xsl:value-of select="@endterm"/>
          </xsl:message>
          <xsl:text>???</xsl:text>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="$etarget" mode="endterm"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>

    <xsl:when test="$target/@xreflabel">
      <xsl:call-template name="xref.xreflabel">
        <xsl:with-param name="target" select="$target"/>
      </xsl:call-template>
    </xsl:when>

    <xsl:otherwise>
   
      <xsl:choose>
	<!-- Watch out for the case when there is a xref or link inside 
	     a title. See bugs #1811721 and #1838136. -->
	<xsl:when test="not(ancestor::*[@id = $target/@id] or ancestor::*[@xml:id = $target/@xml:id])">

	  <xsl:apply-templates select="$target" mode="xref-to-prefix"/>
	  
	  <xsl:apply-templates select="$target" mode="xref-to">
	    
	    <xsl:with-param name="referrer" select="."/>
	    <xsl:with-param name="xrefstyle">
	      <xsl:choose>
		<xsl:when test="@role and not(@xrefstyle) and $use.role.as.xrefstyle != 0">
		  <xsl:value-of select="@role"/>
		</xsl:when>
		<xsl:otherwise>
		  <xsl:value-of select="@xrefstyle"/>
		</xsl:otherwise>
	      </xsl:choose>
	    </xsl:with-param>
	  </xsl:apply-templates>
	  
	  <xsl:apply-templates select="$target" mode="xref-to-suffix"/>
	</xsl:when>
	
	<xsl:otherwise>
	  <xsl:apply-templates/>
	</xsl:otherwise>
      
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>

</xsl:template>
<doc:mode xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" mode="subtitle.markup">
<refpurpose>Provides access to element subtitles</refpurpose>
<refdescription id="subtitle.markup-desc">
<para>Processing an element in the
<literal role="mode">subtitle.markup</literal> mode produces the
subtitle of the element.
</para>
</refdescription>
</doc:mode><xsl:template match="*" mode="subtitle.markup">
  <xsl:param name="verbose" select="1"/>
  <xsl:if test="$verbose != 0">
    <xsl:message>
      <xsl:text>Request for subtitle of unexpected element: </xsl:text>
      <xsl:value-of select="local-name(.)"/>
    </xsl:message>
    <xsl:text>???SUBTITLE???</xsl:text>
  </xsl:if>
</xsl:template><xsl:template match="subtitle" mode="subtitle.markup">
  <xsl:param name="allow-anchors" select="'0'"/>
  <xsl:param name="verbose" select="1"/>
  <xsl:apply-templates/>
</xsl:template><xsl:template match="set" mode="subtitle.markup">
  <xsl:param name="allow-anchors" select="'0'"/>
  <xsl:param name="verbose" select="1"/>
  <xsl:apply-templates select="(setinfo/subtitle|info/subtitle|subtitle)[1]" mode="subtitle.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="book" mode="subtitle.markup">
  <xsl:param name="allow-anchors" select="'0'"/>
  <xsl:param name="verbose" select="1"/>
  <xsl:apply-templates select="(bookinfo/subtitle|info/subtitle|subtitle)[1]" mode="subtitle.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="part" mode="subtitle.markup">
  <xsl:param name="allow-anchors" select="'0'"/>
  <xsl:param name="verbose" select="1"/>
  <xsl:apply-templates select="(partinfo/subtitle                                 |docinfo/subtitle                                 |info/subtitle                                 |subtitle)[1]" mode="subtitle.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="preface|chapter|appendix" mode="subtitle.markup">
  <xsl:param name="allow-anchors" select="'0'"/>
  <xsl:param name="verbose" select="1"/>
  <xsl:apply-templates select="(docinfo/subtitle                                 |info/subtitle                                 |prefaceinfo/subtitle                                 |chapterinfo/subtitle                                 |appendixinfo/subtitle                                 |subtitle)[1]" mode="subtitle.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="article" mode="subtitle.markup">
  <xsl:param name="allow-anchors" select="'0'"/>
  <xsl:param name="verbose" select="1"/>
  <xsl:apply-templates select="(artheader/subtitle                                 |articleinfo/subtitle                                 |info/subtitle                                 |subtitle)[1]" mode="subtitle.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="dedication|colophon" mode="subtitle.markup">
  <xsl:param name="allow-anchors" select="'0'"/>
  <xsl:param name="verbose" select="1"/>
  <xsl:apply-templates select="(subtitle|info/subtitle)[1]" mode="subtitle.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="reference" mode="subtitle.markup">
  <xsl:param name="allow-anchors" select="'0'"/>
  <xsl:param name="verbose" select="1"/>
  <xsl:apply-templates select="(referenceinfo/subtitle                                 |docinfo/subtitle                                 |info/subtitle                                 |subtitle)[1]" mode="subtitle.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="qandaset" mode="subtitle.markup">
  <xsl:param name="allow-anchors" select="'0'"/>
  <xsl:param name="verbose" select="1"/>
  <xsl:apply-templates select="(blockinfo/subtitle|info/subtitle)[1]" mode="subtitle.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="refentry" mode="subtitle.markup">
  <xsl:param name="allow-anchors" select="'0'"/>
  <xsl:param name="verbose" select="1"/>
  <xsl:apply-templates select="(refentryinfo/subtitle                                 |info/subtitle                                 |docinfo/subtitle)[1]" mode="subtitle.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="section                      |sect1|sect2|sect3|sect4|sect5                      |refsect1|refsect2|refsect3                      |topic                      |simplesect" mode="subtitle.markup">
  <xsl:param name="allow-anchors" select="'0'"/>
  <xsl:param name="verbose" select="1"/>
  <xsl:apply-templates select="(info/subtitle                                 |sectioninfo/subtitle                                 |sect1info/subtitle                                 |sect2info/subtitle                                 |sect3info/subtitle                                 |sect4info/subtitle                                 |sect5info/subtitle                                 |refsect1info/subtitle                                 |refsect2info/subtitle                                 |refsect3info/subtitle                                 |subtitle)[1]" mode="subtitle.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template>
<xsl:template match="*" mode="object.title.template">
  <xsl:call-template name="gentext.template">
    <xsl:with-param name="context" select="'title'"/>
    <xsl:with-param name="name">
      <xsl:call-template name="xpath.location"/>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template><xsl:template match="chapter" mode="object.title.template">
  <xsl:choose>
    <xsl:when test="string($chapter.autolabel) != 0">
      <xsl:call-template name="gentext.template">
        <xsl:with-param name="context" select="'title-numbered'"/>
        <xsl:with-param name="name">
          <xsl:call-template name="xpath.location"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext.template">
        <xsl:with-param name="context" select="'title-unnumbered'"/>
        <xsl:with-param name="name">
          <xsl:call-template name="xpath.location"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="appendix" mode="object.title.template">
  <xsl:choose>
    <xsl:when test="string($appendix.autolabel) != 0">
      <xsl:call-template name="gentext.template">
        <xsl:with-param name="context" select="'title-numbered'"/>
        <xsl:with-param name="name">
          <xsl:call-template name="xpath.location"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext.template">
        <xsl:with-param name="context" select="'title-unnumbered'"/>
        <xsl:with-param name="name">
          <xsl:call-template name="xpath.location"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="part" mode="object.title.template">
  <xsl:choose>
    <xsl:when test="string($part.autolabel) != 0">
      <xsl:call-template name="gentext.template">
        <xsl:with-param name="context" select="'title-numbered'"/>
        <xsl:with-param name="name">
          <xsl:call-template name="xpath.location"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext.template">
        <xsl:with-param name="context" select="'title-unnumbered'"/>
        <xsl:with-param name="name">
          <xsl:call-template name="xpath.location"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="section|sect1|sect2|sect3|sect4|sect5|simplesect                      |bridgehead|topic" mode="object.title.template">
  <xsl:variable name="is.numbered">
    <xsl:call-template name="label.this.section"/>
  </xsl:variable>
  <xsl:choose>
    <xsl:when test="$is.numbered != 0">
      <xsl:call-template name="gentext.template">
        <xsl:with-param name="context" select="'title-numbered'"/>
        <xsl:with-param name="name">
          <xsl:call-template name="xpath.location"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext.template">
        <xsl:with-param name="context" select="'title-unnumbered'"/>
        <xsl:with-param name="name">
          <xsl:call-template name="xpath.location"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="procedure" mode="object.title.template">
  <xsl:choose>
    <xsl:when test="$formal.procedures != 0 and title">
      <xsl:call-template name="gentext.template">
        <xsl:with-param name="context" select="'title'"/>
        <xsl:with-param name="name">
          <xsl:call-template name="xpath.location"/>
          <xsl:text>.formal</xsl:text>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="gentext.template">
        <xsl:with-param name="context" select="'title'"/>
        <xsl:with-param name="name">
          <xsl:call-template name="xpath.location"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="*" mode="object.subtitle.template">
  <xsl:call-template name="gentext.template">
    <xsl:with-param name="context" select="'subtitle'"/>
    <xsl:with-param name="name">
      <xsl:call-template name="xpath.location"/>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template><xsl:template match="*" mode="is.autonumber">
  <xsl:value-of select="'0'"/>
</xsl:template><xsl:template match="section|sect1|sect2|sect3|sect4|sect5" mode="is.autonumber">
  <xsl:call-template name="label.this.section"/>
</xsl:template><xsl:template match="figure|example|table|equation" mode="is.autonumber">
  <xsl:value-of select="'1'"/>
</xsl:template><xsl:template match="appendix" mode="is.autonumber">
  <xsl:value-of select="$appendix.autolabel"/>
</xsl:template><xsl:template match="chapter" mode="is.autonumber">
  <xsl:value-of select="$chapter.autolabel"/>
</xsl:template><xsl:template match="part" mode="is.autonumber">
  <xsl:value-of select="$part.autolabel"/>
</xsl:template><xsl:template match="preface" mode="is.autonumber">
  <xsl:value-of select="$preface.autolabel"/>
</xsl:template><xsl:template match="question|answer" mode="is.autonumber">
  <xsl:choose>
    <xsl:when test="$qanda.defaultlabel = 'number'                     and not(label)">
      <xsl:value-of select="'1'"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="'0'"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="qandadiv" mode="is.autonumber">
  <xsl:value-of select="$qandadiv.autolabel"/>
</xsl:template><xsl:template match="bridgehead" mode="is.autonumber">
  <!-- bridgeheads are not numbered -->
  <xsl:text>0</xsl:text>
</xsl:template><xsl:template match="procedure" mode="is.autonumber">
  <xsl:value-of select="$formal.procedures"/>
</xsl:template><xsl:template match="*" mode="object.xref.template">
  <xsl:param name="purpose"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="referrer"/>

  <!-- Is autonumbering on? -->
  <xsl:variable name="autonumber">
    <xsl:apply-templates select="." mode="is.autonumber"/>
  </xsl:variable>

  <xsl:variable name="number-and-title-template">
    <xsl:call-template name="gentext.template.exists">
      <xsl:with-param name="context" select="'xref-number-and-title'"/>
      <xsl:with-param name="name">
        <xsl:call-template name="xpath.location"/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="number-template">
    <xsl:call-template name="gentext.template.exists">
      <xsl:with-param name="context" select="'xref-number'"/>
      <xsl:with-param name="name">
        <xsl:call-template name="xpath.location"/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="context">
    <xsl:choose>
      <xsl:when test="self::equation and not(title) and not(info/title)">
         <xsl:value-of select="'xref-number'"/>
      </xsl:when>
      <xsl:when test="string($autonumber) != 0                        and $number-and-title-template != 0                       and $xref.with.number.and.title != 0">
         <xsl:value-of select="'xref-number-and-title'"/>
      </xsl:when>
      <xsl:when test="string($autonumber) != 0                        and $number-template != 0">
         <xsl:value-of select="'xref-number'"/>
      </xsl:when>
      <xsl:otherwise>
         <xsl:value-of select="'xref'"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="gentext.template">
    <xsl:with-param name="context" select="$context"/>
    <xsl:with-param name="name">
      <xsl:call-template name="xpath.location"/>
    </xsl:with-param>
    <xsl:with-param name="purpose" select="$purpose"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
  </xsl:call-template>

</xsl:template><xsl:template match="*" mode="object.title.markup">
  <xsl:param name="allow-anchors" select="0"/>
  <xsl:variable name="template">
    <xsl:apply-templates select="." mode="object.title.template"/>
  </xsl:variable>

<!--
  <xsl:message>
    <xsl:text>object.title.markup: </xsl:text>
    <xsl:value-of select="local-name(.)"/>
    <xsl:text>: </xsl:text>
    <xsl:value-of select="$template"/>
  </xsl:message>
-->

  <xsl:call-template name="substitute-markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
    <xsl:with-param name="template" select="$template"/>
  </xsl:call-template>
</xsl:template><xsl:template match="*" mode="object.title.markup.textonly">
  <xsl:variable name="title">
    <xsl:apply-templates select="." mode="object.title.markup"/>
  </xsl:variable>
  <xsl:value-of select="normalize-space($title)"/>
</xsl:template><xsl:template match="*" mode="object.titleabbrev.markup">
  <xsl:param name="allow-anchors" select="0"/>

  <!-- Just for consistency in template naming -->

  <xsl:apply-templates select="." mode="titleabbrev.markup">
    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="*" mode="object.subtitle.markup">
  <xsl:variable name="template">
    <xsl:apply-templates select="." mode="object.subtitle.template"/>
  </xsl:variable>

  <xsl:call-template name="substitute-markup">
    <xsl:with-param name="template" select="$template"/>
  </xsl:call-template>
</xsl:template><xsl:template match="*" mode="object.xref.markup">
  <xsl:param name="purpose"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="referrer"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:variable name="template">
    <xsl:choose>
      <xsl:when test="starts-with(normalize-space($xrefstyle), 'select:')">
        <xsl:call-template name="make.gentext.template">
          <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
          <xsl:with-param name="purpose" select="$purpose"/>
          <xsl:with-param name="referrer" select="$referrer"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="starts-with(normalize-space($xrefstyle), 'template:')">
        <xsl:value-of select="substring-after(normalize-space($xrefstyle), 'template:')"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="." mode="object.xref.template">
          <xsl:with-param name="purpose" select="$purpose"/>
          <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
          <xsl:with-param name="referrer" select="$referrer"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

<!-- 
  <xsl:message>
    <xsl:text>object.xref.markup: </xsl:text>
    <xsl:value-of select="local-name(.)"/>
    <xsl:text>(</xsl:text>
    <xsl:value-of select="$xrefstyle"/>
    <xsl:text>, </xsl:text>
    <xsl:value-of select="$purpose"/>
    <xsl:text>)</xsl:text>
    <xsl:text>: [</xsl:text>
    <xsl:value-of select="$template"/>
    <xsl:text>]</xsl:text>
  </xsl:message>
-->

  <xsl:if test="$template = '' and $verbose != 0">
    <xsl:message>
      <xsl:text>object.xref.markup: empty xref template</xsl:text>
      <xsl:text> for linkend="</xsl:text>
      <xsl:value-of select="@id|@xml:id"/>
      <xsl:text>" and @xrefstyle="</xsl:text>
      <xsl:value-of select="$xrefstyle"/>
      <xsl:text>"</xsl:text>
    </xsl:message>
  </xsl:if>

  <xsl:call-template name="substitute-markup">
    <xsl:with-param name="purpose" select="$purpose"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="template" select="$template"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:call-template>
</xsl:template><xsl:template match="listitem" mode="object.xref.markup">
  <xsl:param name="verbose" select="1"/>

  <xsl:choose>
    <xsl:when test="parent::orderedlist">
      <xsl:variable name="template">
        <xsl:apply-templates select="." mode="object.xref.template"/>
      </xsl:variable>
      <xsl:call-template name="substitute-markup">
        <xsl:with-param name="template" select="$template"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$verbose != 0">
      <xsl:message>
        <xsl:text>Xref is only supported to listitems in an</xsl:text>
        <xsl:text> orderedlist: </xsl:text>
        <xsl:value-of select=".//@id|.//@xml:id"/>
      </xsl:message>
      <xsl:text>???</xsl:text>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="question" mode="object.xref.markup">
  <xsl:param name="purpose"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="referrer"/>

  <xsl:variable name="deflabel">
    <xsl:choose>
      <xsl:when test="ancestor-or-self::*[@defaultlabel]">
        <xsl:value-of select="(ancestor-or-self::*[@defaultlabel])[last()]                               /@defaultlabel"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$qanda.defaultlabel"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="template">
    <xsl:choose>
      <!-- This avoids double Q: Q: in xref when defaultlabel=qanda -->
      <xsl:when test="$deflabel = 'qanda' and not(label)">%n</xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="." mode="object.xref.template">
          <xsl:with-param name="purpose" select="$purpose"/>
          <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
          <xsl:with-param name="referrer" select="$referrer"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="substitute-markup">
    <xsl:with-param name="purpose" select="$purpose"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="template" select="$template"/>
  </xsl:call-template>
</xsl:template><xsl:template name="substitute-markup">
  <xsl:param name="template" select="''"/>
  <xsl:param name="allow-anchors" select="'0'"/>
  <xsl:param name="title" select="''"/>
  <xsl:param name="subtitle" select="''"/>
  <xsl:param name="docname" select="''"/>
  <xsl:param name="label" select="''"/>
  <xsl:param name="pagenumber" select="''"/>
  <xsl:param name="purpose"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="referrer"/>
  <xsl:param name="verbose"/>

  <xsl:choose>
    <xsl:when test="contains($template, '%')">
      <xsl:value-of select="substring-before($template, '%')"/>
      <xsl:variable name="candidate" select="substring(substring-after($template, '%'), 1, 1)"/>
      <xsl:choose>
        <xsl:when test="$candidate = 't'">
          <xsl:apply-templates select="." mode="insert.title.markup">
            <xsl:with-param name="purpose" select="$purpose"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="title">
              <xsl:choose>
                <xsl:when test="$title != ''">
                  <xsl:copy-of select="$title"/>
                </xsl:when>
                <xsl:when test="$purpose = 'xref'">
                  <xsl:apply-templates select="." mode="titleabbrev.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                    <xsl:with-param name="verbose" select="$verbose"/>
                  </xsl:apply-templates>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:apply-templates select="." mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                    <xsl:with-param name="verbose" select="$verbose"/>
                  </xsl:apply-templates>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:with-param>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:when test="$candidate = 's'">
          <xsl:apply-templates select="." mode="insert.subtitle.markup">
            <xsl:with-param name="purpose" select="$purpose"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="subtitle">
              <xsl:choose>
                <xsl:when test="$subtitle != ''">
                  <xsl:copy-of select="$subtitle"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:apply-templates select="." mode="subtitle.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                  </xsl:apply-templates>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:with-param>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:when test="$candidate = 'n'">
          <xsl:apply-templates select="." mode="insert.label.markup">
            <xsl:with-param name="purpose" select="$purpose"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="label">
              <xsl:choose>
                <xsl:when test="$label != ''">
                  <xsl:copy-of select="$label"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:apply-templates select="." mode="label.markup"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:with-param>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:when test="$candidate = 'p'">
          <xsl:apply-templates select="." mode="insert.pagenumber.markup">
            <xsl:with-param name="purpose" select="$purpose"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="pagenumber">
              <xsl:choose>
                <xsl:when test="$pagenumber != ''">
                  <xsl:copy-of select="$pagenumber"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:apply-templates select="." mode="pagenumber.markup"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:with-param>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:when test="$candidate = 'o'">
          <!-- olink target document title -->
          <xsl:apply-templates select="." mode="insert.olink.docname.markup">
            <xsl:with-param name="purpose" select="$purpose"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="docname">
              <xsl:choose>
                <xsl:when test="$docname != ''">
                  <xsl:copy-of select="$docname"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:apply-templates select="." mode="olink.docname.markup"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:with-param>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:when test="$candidate = 'd'">
          <xsl:apply-templates select="." mode="insert.direction.markup">
            <xsl:with-param name="purpose" select="$purpose"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="direction">
              <xsl:choose>
                <xsl:when test="$referrer">
                  <xsl:variable name="referent-is-below">
                    <xsl:for-each select="preceding::xref">
                      <xsl:if test="generate-id(.) = generate-id($referrer)">1</xsl:if>
                    </xsl:for-each>
                  </xsl:variable>
                  <xsl:choose>
                    <xsl:when test="$referent-is-below = ''">
                      <xsl:call-template name="gentext">
                        <xsl:with-param name="key" select="'above'"/>
                      </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:call-template name="gentext">
                        <xsl:with-param name="key" select="'below'"/>
                      </xsl:call-template>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:message>Attempt to use %d in gentext with no referrer!</xsl:message>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:with-param>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:when test="$candidate = '%' ">
          <xsl:text>%</xsl:text>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>%</xsl:text><xsl:value-of select="$candidate"/>
        </xsl:otherwise>
      </xsl:choose>
      <!-- recurse with the rest of the template string -->
      <xsl:variable name="rest" select="substring($template,             string-length(substring-before($template, '%'))+3)"/>
      <xsl:call-template name="substitute-markup">
        <xsl:with-param name="template" select="$rest"/>
        <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        <xsl:with-param name="title" select="$title"/>
        <xsl:with-param name="subtitle" select="$subtitle"/>
        <xsl:with-param name="docname" select="$docname"/>
        <xsl:with-param name="label" select="$label"/>
        <xsl:with-param name="pagenumber" select="$pagenumber"/>
        <xsl:with-param name="purpose" select="$purpose"/>
        <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
        <xsl:with-param name="referrer" select="$referrer"/>
        <xsl:with-param name="verbose" select="$verbose"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$template"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="make.gentext.template">
  <xsl:param name="xrefstyle" select="''"/>
  <xsl:param name="purpose"/>
  <xsl:param name="referrer"/>
  <xsl:param name="lang">
    <xsl:call-template name="l10n.language"/>
  </xsl:param>
  <xsl:param name="target.elem" select="local-name(.)"/>

  <!-- parse xrefstyle to get parts -->
  <xsl:variable name="parts" select="substring-after(normalize-space($xrefstyle), 'select:')"/>

  <xsl:variable name="labeltype">
    <xsl:choose>
      <xsl:when test="contains($parts, 'labelnumber')">
         <xsl:text>labelnumber</xsl:text>
      </xsl:when>
      <xsl:when test="contains($parts, 'labelname')">
         <xsl:text>labelname</xsl:text>
      </xsl:when>
      <xsl:when test="contains($parts, 'label')">
         <xsl:text>label</xsl:text>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="titletype">
    <xsl:choose>
      <xsl:when test="contains($parts, 'quotedtitle')">
         <xsl:text>quotedtitle</xsl:text>
      </xsl:when>
      <xsl:when test="contains($parts, 'title')">
         <xsl:text>title</xsl:text>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="pagetype">
    <xsl:choose>
      <xsl:when test="$insert.olink.page.number = 'no' and                       local-name($referrer) = 'olink'">
        <!-- suppress page numbers -->
      </xsl:when>
      <xsl:when test="$insert.xref.page.number = 'no' and                       local-name($referrer) != 'olink'">
        <!-- suppress page numbers -->
      </xsl:when>
      <xsl:when test="contains($parts, 'nopage')">
         <xsl:text>nopage</xsl:text>
      </xsl:when>
      <xsl:when test="contains($parts, 'pagenumber')">
         <xsl:text>pagenumber</xsl:text>
      </xsl:when>
      <xsl:when test="contains($parts, 'pageabbrev')">
         <xsl:text>pageabbrev</xsl:text>
      </xsl:when>
      <xsl:when test="contains($parts, 'Page')">
         <xsl:text>Page</xsl:text>
      </xsl:when>
      <xsl:when test="contains($parts, 'page')">
         <xsl:text>page</xsl:text>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="docnametype">
    <xsl:choose>
      <xsl:when test="($olink.doctitle = 0 or                        $olink.doctitle = 'no') and                       local-name($referrer) = 'olink'">
        <!-- suppress docname -->
      </xsl:when>
      <xsl:when test="contains($parts, 'nodocname')">
         <xsl:text>nodocname</xsl:text>
      </xsl:when>
      <xsl:when test="contains($parts, 'docnamelong')">
         <xsl:text>docnamelong</xsl:text>
      </xsl:when>
      <xsl:when test="contains($parts, 'docname')">
         <xsl:text>docname</xsl:text>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:if test="$labeltype != ''">
    <xsl:choose>
      <xsl:when test="$labeltype = 'labelname'">
        <xsl:call-template name="gentext">
          <xsl:with-param name="key">
            <xsl:choose>
              <xsl:when test="local-name($referrer) = 'olink'">
                <xsl:value-of select="$target.elem"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="local-name(.)"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$labeltype = 'labelnumber'">
        <xsl:text>%n</xsl:text>
      </xsl:when>
      <xsl:when test="$labeltype = 'label'">
        <xsl:call-template name="gentext.template">
          <xsl:with-param name="context" select="'xref-number'"/>
          <xsl:with-param name="name">
            <xsl:choose>
              <xsl:when test="local-name($referrer) = 'olink'">
                <xsl:value-of select="$target.elem"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:call-template name="xpath.location"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
          <xsl:with-param name="purpose" select="$purpose"/>
          <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
          <xsl:with-param name="referrer" select="$referrer"/>
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>

    <xsl:choose>
      <xsl:when test="$titletype != ''">
        <xsl:value-of select="$xref.label-title.separator"/>
      </xsl:when>
      <xsl:when test="$pagetype != '' and $pagetype != 'nopage'">
        <xsl:value-of select="$xref.label-page.separator"/>
      </xsl:when>
    </xsl:choose>
  </xsl:if>

  <xsl:if test="$titletype != ''">
    <xsl:choose>
      <xsl:when test="$titletype = 'title'">
        <xsl:text>%t</xsl:text>
      </xsl:when>
      <xsl:when test="$titletype = 'quotedtitle'">
        <xsl:call-template name="gentext.dingbat">
          <xsl:with-param name="dingbat" select="'startquote'"/>
        </xsl:call-template>
        <xsl:text>%t</xsl:text>
        <xsl:call-template name="gentext.dingbat">
          <xsl:with-param name="dingbat" select="'endquote'"/>
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>

    <xsl:choose>
      <xsl:when test="$pagetype != '' and $pagetype != 'nopage'">
        <xsl:value-of select="$xref.title-page.separator"/>
      </xsl:when>
    </xsl:choose>
  </xsl:if>
  
  <!-- special case: use regular xref template if just turning off page -->
  <xsl:if test="($pagetype = 'nopage' or $docnametype = 'nodocname')                   and local-name($referrer) != 'olink'                   and $labeltype = ''                    and $titletype = ''">
    <xsl:apply-templates select="." mode="object.xref.template">
      <xsl:with-param name="purpose" select="$purpose"/>
      <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
      <xsl:with-param name="referrer" select="$referrer"/>
    </xsl:apply-templates>
  </xsl:if>

  <xsl:if test="$pagetype != ''">
    <xsl:choose>
      <xsl:when test="$pagetype = 'page'">
        <xsl:call-template name="gentext.template">
          <xsl:with-param name="context" select="'xref'"/>
          <xsl:with-param name="name" select="'page'"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$pagetype = 'Page'">
        <xsl:call-template name="gentext.template">
          <xsl:with-param name="context" select="'xref'"/>
          <xsl:with-param name="name" select="'Page'"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$pagetype = 'pageabbrev'">
        <xsl:call-template name="gentext.template">
          <xsl:with-param name="context" select="'xref'"/>
          <xsl:with-param name="name" select="'pageabbrev'"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$pagetype = 'pagenumber'">
        <xsl:text>%p</xsl:text>
      </xsl:when>
    </xsl:choose>

  </xsl:if>

  <!-- Add reference to other document title -->
  <xsl:if test="$docnametype != '' and local-name($referrer) = 'olink'">
    <!-- Any separator should be in the gentext template -->
    <xsl:choose>
      <xsl:when test="$docnametype = 'docnamelong'">
        <xsl:call-template name="gentext.template">
          <xsl:with-param name="context" select="'xref'"/>
          <xsl:with-param name="name" select="'docnamelong'"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$docnametype = 'docname'">
        <xsl:call-template name="gentext.template">
          <xsl:with-param name="context" select="'xref'"/>
          <xsl:with-param name="name" select="'docname'"/>
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>

  </xsl:if>
  
</xsl:template>
<doc:mode xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" mode="collect.targets">
<refpurpose>Collects information for potential cross reference targets</refpurpose>
<refdescription id="collect.targets-desc">
<para>Processing the root element in the
<literal role="mode">collect.targets</literal> mode produces 
a set of target database elements that can be used by
the olink mechanism to resolve external cross references.
The collection process is controlled by the <literal>
collect.xref.targets</literal> parameter, which can be
<literal>yes</literal> to collect targets and process
the document for output, <literal>only</literal> to
only collect the targets, and <literal>no</literal>
(default) to not collect the targets and only process the document.
</para>
<para>
A <literal>targets.filename</literal> parameter must be
specified to receive the output if 
<literal>collect.xref.targets</literal> is
set to <literal>yes</literal> so as to
redirect the target data to a file separate from the
document output.
</para>
</refdescription>
</doc:mode><xsl:template match="*" mode="collect.targets">
  <xsl:choose>
    <xsl:when test="$collect.xref.targets = 'yes' and $targets.filename = ''">
      <xsl:message>
        Must specify a $targets.filename parameter when
        $collect.xref.targets is set to 'yes'.
        The xref targets were not collected.
      </xsl:message>
    </xsl:when> 
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="$targets.filename">
          <xsl:call-template name="write.chunk">
            <xsl:with-param name="filename" select="$targets.filename"/>
            <xsl:with-param name="method" select="'xml'"/>
            <xsl:with-param name="encoding" select="'utf-8'"/>
            <xsl:with-param name="omit-xml-declaration" select="'yes'"/>
            <xsl:with-param name="doctype-public" select="''"/>
            <xsl:with-param name="doctype-system" select="''"/>
            <xsl:with-param name="indent" select="'no'"/>
            <xsl:with-param name="quiet" select="0"/>
            <xsl:with-param name="content">
              <xsl:apply-templates select="." mode="olink.mode"/>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <!-- Else write to standard output -->
          <xsl:apply-templates select="." mode="olink.mode"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="olink.href.target">
  <xsl:param name="nd" select="."/>

  <xsl:value-of select="$olink.base.uri"/>
  <xsl:call-template name="href.target">
    <xsl:with-param name="object" select="$nd"/>
    <xsl:with-param name="context" select="NOTANODE"/>
  </xsl:call-template>
</xsl:template><xsl:template name="attrs">
  <xsl:param name="nd" select="."/>

  <xsl:attribute name="element">
    <xsl:value-of select="local-name(.)"/>
  </xsl:attribute>

  <xsl:attribute name="href">
    <xsl:call-template name="olink.href.target">
      <xsl:with-param name="nd" select="$nd"/>
    </xsl:call-template>
  </xsl:attribute>

  <xsl:variable name="num">
    <xsl:apply-templates select="$nd" mode="label.markup">
      <xsl:with-param name="verbose" select="0"/>
    </xsl:apply-templates>
  </xsl:variable>

  <xsl:if test="$num">
    <xsl:attribute name="number">
      <xsl:value-of select="$num"/>
    </xsl:attribute>
  </xsl:if>

  <xsl:choose>
    <xsl:when test="$nd/@id">
      <xsl:attribute name="targetptr">
        <xsl:value-of select="$nd/@id"/>
      </xsl:attribute>
    </xsl:when>
    <xsl:when test="$nd/@xml:id">
      <xsl:attribute name="targetptr">
        <xsl:value-of select="$nd/@xml:id"/>
      </xsl:attribute>
    </xsl:when>
  </xsl:choose>

  <xsl:if test="$nd/@lang">
    <xsl:attribute name="lang">
      <xsl:value-of select="$nd/@lang"/>
    </xsl:attribute>
  </xsl:if>

</xsl:template><xsl:template name="div">
  <xsl:param name="nd" select="."/>

  <div xmlns="">
    <xsl:call-template name="attrs">
      <xsl:with-param name="nd" select="$nd"/>
    </xsl:call-template>
    <ttl>
      <xsl:apply-templates select="$nd" mode="title.markup">
        <xsl:with-param name="verbose" select="0"/>
      </xsl:apply-templates>
    </ttl>
    <xreftext>
      <xsl:choose>
        <xsl:when test="$nd/@xreflabel">
          <xsl:call-template name="xref.xreflabel">
            <xsl:with-param name="target" select="$nd"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="$nd" mode="xref-to">
            <xsl:with-param name="verbose" select="0"/>
          </xsl:apply-templates>
        </xsl:otherwise>
      </xsl:choose>
    </xreftext>
    <xsl:apply-templates mode="olink.mode"/>
  </div>
</xsl:template><xsl:template name="obj">
  <xsl:param name="nd" select="."/>

  <obj xmlns="">
    <xsl:call-template name="attrs">
      <xsl:with-param name="nd" select="$nd"/>
    </xsl:call-template>
    <ttl>
      <xsl:apply-templates select="$nd" mode="title.markup">
        <xsl:with-param name="verbose" select="0"/>
      </xsl:apply-templates>
    </ttl>
    <xreftext>
      <xsl:choose>
        <xsl:when test="$nd/@xreflabel">
          <xsl:call-template name="xref.xreflabel">
            <xsl:with-param name="target" select="$nd"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="$nd" mode="xref-to">
            <xsl:with-param name="verbose" select="0"/>
          </xsl:apply-templates>
        </xsl:otherwise>
      </xsl:choose>
    </xreftext>
  </obj>
</xsl:template><xsl:template match="text()|processing-instruction()|comment()" mode="olink.mode">
  <!-- nop -->
</xsl:template><xsl:template match="set" mode="olink.mode">
  <xsl:call-template name="div"/>
</xsl:template><xsl:template match="book" mode="olink.mode">
  <xsl:call-template name="div"/>
</xsl:template><xsl:template match="preface|chapter|appendix" mode="olink.mode">
  <xsl:call-template name="div"/>
</xsl:template><xsl:template match="part|reference" mode="olink.mode">
  <xsl:call-template name="div"/>
</xsl:template><xsl:template match="article" mode="olink.mode">
  <xsl:call-template name="div"/>
</xsl:template><xsl:template match="topic" mode="olink.mode">
  <xsl:call-template name="div"/>
</xsl:template><xsl:template match="bibliography|bibliodiv" mode="olink.mode">
  <xsl:call-template name="div"/>
</xsl:template><xsl:template match="biblioentry|bibliomixed" mode="olink.mode">
  <xsl:call-template name="obj"/>
</xsl:template><xsl:template match="refentry" mode="olink.mode">
  <xsl:call-template name="div"/>
</xsl:template><xsl:template match="section|sect1|sect2|sect3|sect4|sect5" mode="olink.mode">
  <xsl:call-template name="div"/>
</xsl:template><xsl:template match="refsection|refsect1|refsect2|refsect3" mode="olink.mode">
  <xsl:call-template name="div"/>
</xsl:template><xsl:template match="figure|example|table" mode="olink.mode">
  <xsl:call-template name="obj"/>
  <xsl:apply-templates mode="olink.mode"/>
</xsl:template><xsl:template match="equation[title or info/title]" mode="olink.mode">
  <xsl:call-template name="obj"/>
</xsl:template><xsl:template match="qandaset|qandaentry" mode="olink.mode">
  <xsl:call-template name="div"/>
</xsl:template><xsl:template match="glossary[@role='auto']" mode="olink.mode" priority="2">
  <xsl:variable name="collection" select="document($glossary.collection, .)"/>
  <xsl:if test="$glossary.collection = ''">
    <xsl:message>
      <xsl:text>Warning: processing automatic glossary </xsl:text>
      <xsl:text>without a glossary.collection file.</xsl:text>
    </xsl:message>
  </xsl:if>

  <xsl:if test="not($collection) and $glossary.collection != ''">
    <xsl:message>
      <xsl:text>Warning: processing automatic glossary but unable to </xsl:text>
      <xsl:text>open glossary.collection file '</xsl:text>
      <xsl:value-of select="$glossary.collection"/>
      <xsl:text>'</xsl:text>
    </xsl:message>
  </xsl:if>


  <xsl:if test="$exsl.node.set.available != 0">
    <xsl:variable name="auto.glossary">
      <xsl:apply-templates select="." mode="assemble.auto.glossary"/>
    </xsl:variable>
    <xsl:variable name="auto.glossary.nodeset" select="exsl:node-set($auto.glossary)"/>
    <xsl:apply-templates select="$auto.glossary.nodeset/*" mode="olink.mode"/>
  </xsl:if>

</xsl:template><xsl:template match="glossary" mode="assemble.auto.glossary">
  <xsl:copy>
    <xsl:copy-of select="@*[not(local-name() = 'role')]"/>
    <xsl:apply-templates select="node()" mode="assemble.auto.glossary"/>
    <xsl:call-template name="select.glossentries"/>
  </xsl:copy>
</xsl:template><xsl:template name="select.glossentries">
  <xsl:param name="collection" select="document($glossary.collection, .)"/>
  <xsl:param name="terms" select="//glossterm[not(parent::glossdef)]|//firstterm"/>

  <xsl:for-each select="$collection//glossentry">
    <xsl:variable name="cterm" select="glossterm"/>
    <xsl:if test="$terms[@baseform = $cterm or . = $cterm]">
      <xsl:copy-of select="."/>
    </xsl:if>
  </xsl:for-each>
</xsl:template><xsl:template match="glossentry" mode="assemble.auto.glossary">
  <!-- skip the dummy entries -->
</xsl:template><xsl:template match="*" mode="assemble.auto.glossary">
  <!-- pass through any titles and intro stuff -->
  <xsl:copy-of select="."/>
</xsl:template><xsl:template match="*" mode="olink.mode">
  <xsl:if test="@id or @xml:id">
    <xsl:call-template name="obj"/>
  </xsl:if> 
  <xsl:apply-templates mode="olink.mode"/>
</xsl:template>
<xsl:key name="targetdoc-key" match="document" use="@targetdoc"/><xsl:key name="targetptr-key" match="div|obj" use="concat(ancestor::document/@targetdoc, '/',                      @targetptr, '/', ancestor::document/@lang)"/>
<xsl:template name="select.target.database">
  <xsl:param name="targetdoc.att" select="''"/>
  <xsl:param name="targetptr.att" select="''"/>
  <xsl:param name="olink.lang" select="''"/>

  <!-- use root's xml:base if exists -->
  <xsl:variable name="xml.base" select="/*/@xml:base"/>

  <!-- This selection can be customized if needed -->
  <xsl:variable name="target.database.filename">
    <xsl:choose>
      <xsl:when test="$xml.base != '' and                    not(starts-with($target.database.document, 'file:/')) and                    not(starts-with($target.database.document, '/'))">
        <xsl:call-template name="systemIdToBaseURI">
          <xsl:with-param name="systemId" select="$xml.base"/>
        </xsl:call-template>
        <xsl:value-of select="$target.database.document"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$target.database.document"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="target.database" select="document($target.database.filename,/)"/>

  <xsl:choose>
    <!-- Was the database document parameter not set? -->
    <xsl:when test="$target.database.document = ''">
      <xsl:message>
        <xsl:text>Olinks not processed: must specify a </xsl:text>
        <xsl:text>$target.database.document parameter
</xsl:text>
        <xsl:text>when using olinks with targetdoc </xsl:text>
        <xsl:text>and targetptr attributes.</xsl:text>
      </xsl:message>
    </xsl:when>
    <xsl:when test="namespace-uri($target.database/*) != ''">
      <xsl:message>
        <xsl:text>Olink error: the targetset element and children in '</xsl:text>
        <xsl:value-of select="$target.database.document"/>
        <xsl:text>' should not be in any namespace.</xsl:text>
      </xsl:message>
    </xsl:when>
    <!-- Did it not open? Should be a targetset element -->
    <xsl:when test="not($target.database/*)">
      <xsl:message>
        <xsl:text>Olink error: could not open target database '</xsl:text>
        <xsl:value-of select="$target.database.filename"/>
        <xsl:text>'.</xsl:text>
      </xsl:message>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$target.database.filename"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="select.olink.key">
  <xsl:param name="targetdoc.att" select="''"/>
  <xsl:param name="targetptr.att" select="''"/>
  <xsl:param name="olink.lang" select="''"/>
  <xsl:param name="target.database"/>

  <xsl:if test="$target.database/*">
    <xsl:variable name="olink.fallback.sequence">
      <xsl:call-template name="select.olink.lang.fallback">
        <xsl:with-param name="olink.lang" select="$olink.lang"/>
      </xsl:call-template>
    </xsl:variable>
  
    <!-- Recurse through the languages until you find a match -->
    <xsl:call-template name="select.olink.key.in.lang">
      <xsl:with-param name="targetdoc.att" select="$targetdoc.att"/>
      <xsl:with-param name="targetptr.att" select="$targetptr.att"/>
      <xsl:with-param name="olink.lang" select="$olink.lang"/>
      <xsl:with-param name="target.database" select="$target.database"/>
      <xsl:with-param name="fallback.index" select="1"/>
      <xsl:with-param name="olink.fallback.sequence" select="$olink.fallback.sequence"/>
    </xsl:call-template>
  </xsl:if>
  
</xsl:template><xsl:template name="select.olink.key.in.lang">
  <xsl:param name="targetdoc.att" select="''"/>
  <xsl:param name="targetptr.att" select="''"/>
  <xsl:param name="olink.lang" select="''"/>
  <xsl:param name="target.database"/>
  <xsl:param name="fallback.index" select="1"/>
  <xsl:param name="olink.fallback.sequence" select="''"/>
  
  <xsl:variable name="target.lang">
    <xsl:call-template name="select.target.lang">
      <xsl:with-param name="fallback.index" select="$fallback.index"/>
      <xsl:with-param name="olink.fallback.sequence" select="$olink.fallback.sequence"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:if test="$olink.debug != 0">
    <xsl:message><xsl:text>Olink debug: cases for targetdoc='</xsl:text>
      <xsl:value-of select="$targetdoc.att"/>
      <xsl:text>' and targetptr='</xsl:text>
      <xsl:value-of select="$targetptr.att"/>
      <xsl:text>' in language '</xsl:text>
      <xsl:value-of select="$target.lang"/>
      <xsl:text>'.</xsl:text>
    </xsl:message>
  </xsl:if>

  <!-- Customize these cases if you want different selection logic -->
  <xsl:variable name="CaseA">
    <!-- targetdoc.att = not blank
         targetptr.att = not blank
    -->
    <xsl:if test="$targetdoc.att != '' and                   $targetptr.att != ''">
      <xsl:for-each select="$target.database">
        <xsl:variable name="key" select="concat($targetdoc.att, '/',                                       $targetptr.att, '/',                                      $target.lang)"/>
        <xsl:choose>
          <xsl:when test="key('targetptr-key', $key)[1]/@href != ''">
            <xsl:value-of select="$key"/>
            <xsl:if test="$olink.debug != 0">
              <xsl:message>Olink debug: CaseA matched.</xsl:message>
            </xsl:if>
          </xsl:when>
          <xsl:when test="$olink.debug != 0">
            <xsl:message>Olink debug: CaseA NOT matched</xsl:message>
          </xsl:when>
        </xsl:choose>
      </xsl:for-each>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="CaseB">
    <!-- targetdoc.att = not blank
         targetptr.att = not blank
         prefer.internal.olink = not zero
         current.docid = not blank 
    -->
    <xsl:if test="$targetdoc.att != '' and                   $targetptr.att != '' and                   $current.docid != '' and                   $prefer.internal.olink != 0">
      <xsl:for-each select="$target.database">
        <xsl:variable name="key" select="concat($current.docid, '/',                                       $targetptr.att, '/',                                      $target.lang)"/>
        <xsl:choose>
          <xsl:when test="key('targetptr-key', $key)[1]/@href != ''">
            <xsl:value-of select="$key"/>
            <xsl:if test="$olink.debug != 0">
              <xsl:message>Olink debug: CaseB matched.</xsl:message>
            </xsl:if>
          </xsl:when>
          <xsl:when test="$olink.debug != 0">
            <xsl:message>Olink debug: CaseB NOT matched</xsl:message>
          </xsl:when>
        </xsl:choose>
      </xsl:for-each>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="CaseC">
    <!-- targetdoc.att = blank
         targetptr.att = not blank
         current.docid = not blank 
    -->
    <xsl:if test="string-length($targetdoc.att) = 0 and                   $targetptr.att != '' and                   $current.docid != ''">
      <!-- Must use a for-each to change context for keys to work -->
      <xsl:for-each select="$target.database">
        <xsl:variable name="key" select="concat($current.docid, '/',                                       $targetptr.att, '/',                                      $target.lang)"/>
        <xsl:choose>
          <xsl:when test="key('targetptr-key', $key)[1]/@href != ''">
            <xsl:value-of select="$key"/>
            <xsl:if test="$olink.debug != 0">
              <xsl:message>Olink debug: CaseC matched.</xsl:message>
            </xsl:if>
          </xsl:when>
          <xsl:when test="$olink.debug != 0">
            <xsl:message>Olink debug: CaseC NOT matched.</xsl:message>
          </xsl:when>
        </xsl:choose>
      </xsl:for-each>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="CaseD">
    <!-- targetdoc.att = blank
         targetptr.att = not blank
         current.docid = blank 
    -->
    <!-- This is possible if only one document in the database -->
    <xsl:if test="string-length($targetdoc.att) = 0 and                   $targetptr.att != '' and                   string-length($current.docid) = 0 and                   count($target.database//document) = 1">
      <xsl:for-each select="$target.database">
        <xsl:variable name="key" select="concat(.//document/@targetdoc, '/',                                       $targetptr.att, '/',                                      $target.lang)"/>
        <xsl:choose>
          <xsl:when test="key('targetptr-key', $key)[1]/@href != ''">
            <xsl:value-of select="$key"/>
            <xsl:if test="$olink.debug != 0">
              <xsl:message>Olink debug: CaseD matched.</xsl:message>
            </xsl:if>
          </xsl:when>
          <xsl:when test="$olink.debug != 0">
            <xsl:message>Olink debug: CaseD NOT matched</xsl:message>
          </xsl:when>
        </xsl:choose>
      </xsl:for-each>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="CaseE">
    <!-- targetdoc.att = not blank
         targetptr.att = blank
    -->
    <xsl:if test="$targetdoc.att != '' and                   string-length($targetptr.att) = 0">

      <!-- Try the document's root element id -->
      <xsl:variable name="rootid">
        <xsl:choose>
          <xsl:when test="$target.lang != ''">
            <xsl:value-of select="$target.database//document[@targetdoc = $targetdoc.att and @lang = $target.lang]/*[1]/@targetptr"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$target.database//document[@targetdoc = $targetdoc.att and not(@lang)]/*[1]/@targetptr"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>

      <xsl:for-each select="$target.database">
        <xsl:variable name="key" select="concat($targetdoc.att, '/',                                       $rootid, '/',                                      $target.lang)"/>
        <xsl:choose>
          <xsl:when test="key('targetptr-key', $key)[1]/@href != ''">
            <xsl:value-of select="$key"/>
            <xsl:if test="$olink.debug != 0">
              <xsl:message>Olink debug: CaseE matched.</xsl:message>
            </xsl:if>
          </xsl:when>
          <xsl:when test="$olink.debug != 0">
            <xsl:message>Olink debug: CaseE NOT matched.</xsl:message>
          </xsl:when>
        </xsl:choose>
      </xsl:for-each>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="CaseF">
    <!-- targetdoc.att = not blank
         targetptr.att = blank
         prefer.internal.olink = not zero
         current.docid = not blank 
    -->
    <xsl:if test="$targetdoc.att != '' and                   string-length($targetptr.att) = 0 and                   $current.docid != '' and                   $prefer.internal.olink != 0">
      <!-- Try the document's root element id -->
      <xsl:variable name="rootid">
        <xsl:choose>
          <xsl:when test="$target.lang != ''">
            <xsl:value-of select="$target.database//document[@targetdoc = $current.docid and @lang = $target.lang]/*[1]/@targetptr"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$target.database//document[@targetdoc = $current.docid and not(@lang)]/*[1]/@targetptr"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>

      <xsl:for-each select="$target.database">
        <xsl:variable name="key" select="concat($current.docid, '/',                                       $rootid, '/',                                      $target.lang)"/>
        <xsl:choose>
          <xsl:when test="key('targetptr-key', $key)[1]/@href != ''">
            <xsl:value-of select="$key"/>
            <xsl:if test="$olink.debug != 0">
              <xsl:message>Olink debug: CaseF matched.</xsl:message>
            </xsl:if>
          </xsl:when>
          <xsl:when test="$olink.debug != 0">
            <xsl:message>Olink debug: CaseF NOT matched.</xsl:message>
          </xsl:when>
        </xsl:choose>
      </xsl:for-each>
    </xsl:if>
  </xsl:variable>

  <!-- Now select the best match. Customize the order if needed -->
  <xsl:variable name="selected.key">
    <xsl:choose>
      <xsl:when test="$CaseB != ''">
        <xsl:value-of select="$CaseB"/>
        <xsl:if test="$olink.debug != 0">
          <xsl:message>
            <xsl:text>Olink debug: CaseB key is the final selection: </xsl:text>
            <xsl:value-of select="$CaseB"/>
          </xsl:message>
        </xsl:if>
      </xsl:when>
      <xsl:when test="$CaseA != ''">
        <xsl:value-of select="$CaseA"/>
        <xsl:if test="$olink.debug != 0">
          <xsl:message>
            <xsl:text>Olink debug: CaseA key is the final selection: </xsl:text>
            <xsl:value-of select="$CaseA"/>
          </xsl:message>
        </xsl:if>
      </xsl:when>
      <xsl:when test="$CaseC != ''">
        <xsl:value-of select="$CaseC"/>
        <xsl:if test="$olink.debug != 0">
          <xsl:message>
            <xsl:text>Olink debug: CaseC key is the final selection: </xsl:text>
            <xsl:value-of select="$CaseC"/>
          </xsl:message>
        </xsl:if>
      </xsl:when>
      <xsl:when test="$CaseD != ''">
        <xsl:value-of select="$CaseD"/>
        <xsl:if test="$olink.debug != 0">
          <xsl:message>
            <xsl:text>Olink debug: CaseD key is the final selection: </xsl:text>
            <xsl:value-of select="$CaseD"/>
          </xsl:message>
        </xsl:if>
      </xsl:when>
      <xsl:when test="$CaseF != ''">
        <xsl:value-of select="$CaseF"/>
        <xsl:if test="$olink.debug != 0">
          <xsl:message>
            <xsl:text>Olink debug: CaseF key is the final selection: </xsl:text>
            <xsl:value-of select="$CaseF"/>
          </xsl:message>
        </xsl:if>
      </xsl:when>
      <xsl:when test="$CaseE != ''">
        <xsl:value-of select="$CaseE"/>
        <xsl:if test="$olink.debug != 0">
          <xsl:message>
            <xsl:text>Olink debug: CaseE key is the final selection: </xsl:text>
            <xsl:value-of select="$CaseE"/>
          </xsl:message>
        </xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <xsl:if test="$olink.debug != 0">
          <xsl:message>
            <xsl:text>Olink debug: No case matched for lang '</xsl:text>
            <xsl:value-of select="$target.lang"/>
            <xsl:text>'.</xsl:text>
          </xsl:message>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$selected.key != ''">
      <xsl:value-of select="$selected.key"/>
    </xsl:when>
    <xsl:when test="string-length($selected.key) = 0 and                      string-length($target.lang) = 0">
      <!-- No match on last try, and we are done -->
    </xsl:when>
    <xsl:otherwise>
      <!-- Recurse through next language -->
      <xsl:call-template name="select.olink.key.in.lang">
        <xsl:with-param name="targetdoc.att" select="$targetdoc.att"/>
        <xsl:with-param name="targetptr.att" select="$targetptr.att"/>
        <xsl:with-param name="olink.lang" select="$olink.lang"/>
        <xsl:with-param name="target.database" select="$target.database"/>
        <xsl:with-param name="fallback.index" select="$fallback.index + 1"/>
        <xsl:with-param name="olink.fallback.sequence" select="$olink.fallback.sequence"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>

</xsl:template><xsl:template name="select.target.lang">
  <xsl:param name="fallback.index" select="1"/>
  <xsl:param name="olink.fallback.sequence" select="''"/>

  <!-- recurse backwards to find the lang matching the index -->
  <xsl:variable name="firstlang" select="substring-before($olink.fallback.sequence, ' ')"/>
  <xsl:variable name="rest" select="substring-after($olink.fallback.sequence, ' ')"/>
  <xsl:choose>
    <xsl:when test="$fallback.index = 1">
      <xsl:value-of select="$firstlang"/>
    </xsl:when>
    <xsl:when test="$fallback.index &gt; 1">
      <xsl:call-template name="select.target.lang">
        <xsl:with-param name="fallback.index" select="$fallback.index - 1"/>
        <xsl:with-param name="olink.fallback.sequence" select="$rest"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="select.olink.lang.fallback">
  <xsl:param name="olink.lang" select="''"/>

  <!-- Prefer language of the olink element -->
  <xsl:value-of select="concat(normalize-space(concat($olink.lang, ' ',                          $olink.lang.fallback.sequence)), ' ')"/>
</xsl:template><xsl:template name="make.olink.href">
  <xsl:param name="olink.key" select="''"/>
  <xsl:param name="target.database"/>

  <xsl:if test="$olink.key != ''">
    <xsl:variable name="target.href">
      <xsl:for-each select="$target.database">
        <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@href"/>
      </xsl:for-each>
    </xsl:variable>
  
    <xsl:variable name="targetdoc">
      <xsl:value-of select="substring-before($olink.key, '/')"/>
    </xsl:variable>
  
    <!-- Does the target database use a sitemap? -->
    <xsl:variable name="use.sitemap">
      <xsl:choose>
        <xsl:when test="$target.database//sitemap">1</xsl:when>
        <xsl:otherwise>0</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
  
  
    <!-- Get the baseuri for this targetptr -->
    <xsl:variable name="baseuri">
      <xsl:choose>
        <!-- Does the database use a sitemap? -->
        <xsl:when test="$use.sitemap != 0">
          <xsl:choose>
            <!-- Was current.docid parameter set? -->
            <xsl:when test="$current.docid != ''">
              <!-- Was it found in the database? -->
              <xsl:variable name="currentdoc.key">
                <xsl:for-each select="$target.database">
                  <xsl:value-of select="key('targetdoc-key',                                         $current.docid)[1]/@targetdoc"/>
                </xsl:for-each>
              </xsl:variable>
              <xsl:choose>
                <xsl:when test="$currentdoc.key != ''">
                  <xsl:for-each select="$target.database">
                    <xsl:call-template name="targetpath">
                      <xsl:with-param name="dirnode" select="key('targetdoc-key', $current.docid)[1]/parent::dir"/>
                      <xsl:with-param name="targetdoc" select="$targetdoc"/>
                    </xsl:call-template>
                  </xsl:for-each>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:message>
                    <xsl:text>Olink error: cannot compute relative </xsl:text>
                    <xsl:text>sitemap path because $current.docid '</xsl:text>
                    <xsl:value-of select="$current.docid"/>
                    <xsl:text>' not found in target database.</xsl:text>
                  </xsl:message>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
              <xsl:message>
                <xsl:text>Olink warning: cannot compute relative </xsl:text>
                <xsl:text>sitemap path without $current.docid parameter</xsl:text>
              </xsl:message>
            </xsl:otherwise>
          </xsl:choose> 
          <!-- In either case, add baseuri from its document entry-->
          <xsl:variable name="docbaseuri">
            <xsl:for-each select="$target.database">
              <xsl:value-of select="key('targetdoc-key', $targetdoc)[1]/@baseuri"/>
            </xsl:for-each>
          </xsl:variable>
          <xsl:if test="$docbaseuri != ''">
            <xsl:value-of select="$docbaseuri"/>
          </xsl:if>
        </xsl:when>
        <!-- No database sitemap in use -->
        <xsl:otherwise>
          <!-- Just use any baseuri from its document entry -->
          <xsl:variable name="docbaseuri">
            <xsl:for-each select="$target.database">
              <xsl:value-of select="key('targetdoc-key', $targetdoc)[1]/@baseuri"/>
            </xsl:for-each>
          </xsl:variable>
          <xsl:if test="$docbaseuri != ''">
            <xsl:value-of select="$docbaseuri"/>
          </xsl:if>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
  
    <!-- Is this olink to be active? -->
    <xsl:variable name="active.olink">
      <xsl:choose>
        <xsl:when test="$activate.external.olinks = 0">
          <xsl:choose>
            <xsl:when test="$current.docid = ''">1</xsl:when>
            <xsl:when test="$targetdoc = ''">1</xsl:when>
            <xsl:when test="$targetdoc = $current.docid">1</xsl:when>
            <xsl:otherwise>0</xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>

    <!-- Form the href information -->
    <xsl:if test="$active.olink != 0">
      <xsl:if test="$baseuri != ''">
        <xsl:value-of select="$baseuri"/>
        <xsl:if test="substring($target.href,1,1) != '#'">
          <!--xsl:text>/</xsl:text-->
        </xsl:if>
      </xsl:if>
      <!-- optionally turn off frag for PDF references -->
      <xsl:if test="not($insert.olink.pdf.frag = 0 and             translate(substring($baseuri, string-length($baseuri) - 3),                       'PDF', 'pdf') = '.pdf'             and starts-with($target.href, '#') )">
        <xsl:value-of select="$target.href"/>
      </xsl:if>
    </xsl:if>
  </xsl:if>
</xsl:template><xsl:template name="olink.from.uri">
  <xsl:param name="target.database"/>
  <xsl:param name="object" select="NotAnElement"/>
  <xsl:param name="object.targetdoc" select="$current.docid"/>
  <xsl:param name="object.lang" select="concat($object/ancestor::*[last()]/@lang,                           $object/ancestor::*[last()]/@xml:lang)"/>

  <xsl:variable name="parent.id">
    <xsl:call-template name="object.id">
      <xsl:with-param name="object" select="$object"/>
    </xsl:call-template>
  </xsl:variable>

  <!-- Get the olink key for the parent of olink element -->
  <xsl:variable name="from.key">
    <xsl:call-template name="select.olink.key">
      <xsl:with-param name="targetdoc.att" select="$object.targetdoc"/>
      <xsl:with-param name="targetptr.att" select="$parent.id"/>
      <xsl:with-param name="olink.lang" select="$object.lang"/>
      <xsl:with-param name="target.database" select="$target.database"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="from.olink.href">
    <xsl:for-each select="$target.database">
      <xsl:value-of select="key('targetptr-key', $from.key)[1]/@href"/>
    </xsl:for-each>
  </xsl:variable>

  <xsl:choose>
    <!-- we found the olink object -->
    <xsl:when test="$from.olink.href != ''">
      <xsl:value-of select="$from.olink.href"/>
    </xsl:when>
    <xsl:when test="not($object/parent::*)">
      <xsl:value-of select="$from.olink.href"/>
    </xsl:when>
    <xsl:otherwise>
      <!-- recurse upward in current document -->
      <xsl:call-template name="olink.from.uri">
        <xsl:with-param name="target.database" select="$target.database"/>
        <xsl:with-param name="object" select="$object/parent::*"/>
        <xsl:with-param name="object.targetdoc" select="$object.targetdoc"/>
        <xsl:with-param name="object.lang" select="$object.lang"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>

</xsl:template><xsl:template name="olink.hottext">
  <xsl:param name="target.database"/>
  <xsl:param name="olink.lang" select="''"/>
  <xsl:param name="olink.key" select="''"/>
  <xsl:param name="referrer" select="."/>
  <xsl:param name="xrefstyle">
    <xsl:choose>
      <xsl:when test="@role and not(@xrefstyle)                        and $use.role.as.xrefstyle != 0">
        <xsl:value-of select="@role"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="@xrefstyle"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:param>

  <xsl:choose>
    <!-- If it has elements or text (not just PI or comment) -->
    <xsl:when test="child::text() or child::*">
      <xsl:apply-templates/>
    </xsl:when>
    <xsl:when test="$olink.key != ''">
      <!-- Get the xref text for this record -->
      <xsl:variable name="xref.text">
        <xsl:for-each select="$target.database">
          <xsl:call-template name="insert.targetdb.data">
            <xsl:with-param name="data" select="key('targetptr-key', $olink.key)[1]/xreftext/node()"/>
          </xsl:call-template>
        </xsl:for-each>
      </xsl:variable>

      <xsl:variable name="xref.number">
        <xsl:for-each select="$target.database">
          <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@number"/>
        </xsl:for-each>
      </xsl:variable>

      <xsl:variable name="target.elem">
        <xsl:for-each select="$target.database">
          <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@element"/>
        </xsl:for-each>
      </xsl:variable>

      <xsl:variable name="lang">
        <xsl:variable name="candidate">
          <xsl:for-each select="$target.database">
            <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@lang"/>
          </xsl:for-each>
        </xsl:variable>
        <xsl:choose>
          <xsl:when test="$candidate != ''">
            <xsl:value-of select="$candidate"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$olink.lang"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>

      <xsl:variable name="targetdoc">
        <xsl:value-of select="substring-before($olink.key, '/')"/>
      </xsl:variable>

      <xsl:choose>
        <xsl:when test="$xrefstyle != '' and                         starts-with(normalize-space($xrefstyle), 'select:') and                         (contains($xrefstyle, 'nodocname') or                         contains($xrefstyle, 'nopage')) and                         not(contains($xrefstyle, 'title')) and                         not(contains($xrefstyle, 'label'))"> 
          <xsl:copy-of select="$xref.text"/>
        </xsl:when>
        <xsl:when test="$xrefstyle != ''">
          <xsl:if test="$olink.debug != 0">
            <xsl:message>
              <xsl:text>xrefstyle is '</xsl:text>
              <xsl:value-of select="$xrefstyle"/>
              <xsl:text>'.</xsl:text>
            </xsl:message>
          </xsl:if>
          <xsl:variable name="template">
            <xsl:choose>
              <xsl:when test="starts-with(normalize-space($xrefstyle),                                           'select:')">
                <xsl:call-template name="make.gentext.template">
                  <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                  <xsl:with-param name="purpose" select="'olink'"/>
                  <xsl:with-param name="referrer" select="."/>
                  <xsl:with-param name="target.elem" select="$target.elem"/>
                </xsl:call-template>
              </xsl:when>
              <xsl:when test="starts-with(normalize-space($xrefstyle),                                           'template:')">
                <xsl:value-of select="substring-after(                                  normalize-space($xrefstyle), 'template:')"/>
              </xsl:when>
              <xsl:otherwise>
                <!-- Look for Gentext template with @style attribute -->
                <!-- Must compare to no style value because gentext.template
                     falls back to no style -->

                <xsl:variable name="xref-context">
                  <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'xref'"/>
                    <xsl:with-param name="name" select="$target.elem"/>
                    <xsl:with-param name="lang" select="$lang"/>
                  </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="styled-xref-context">
                  <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'xref'"/>
                    <xsl:with-param name="name" select="$target.elem"/>
                    <xsl:with-param name="lang" select="$lang"/>
                    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                  </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="xref-number-context">
                  <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'xref-number'"/>
                    <xsl:with-param name="name" select="$target.elem"/>
                    <xsl:with-param name="lang" select="$lang"/>
                  </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="styled-xref-number-context">
                  <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'xref-number'"/>
                    <xsl:with-param name="name" select="$target.elem"/>
                    <xsl:with-param name="lang" select="$lang"/>
                    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                  </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="xref-number-and-title-context">
                  <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'xref-number-and-title'"/>
                    <xsl:with-param name="name" select="$target.elem"/>
                    <xsl:with-param name="lang" select="$lang"/>
                  </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="styled-xref-number-and-title-context">
                  <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'xref-number-and-title'"/>
                    <xsl:with-param name="name" select="$target.elem"/>
                    <xsl:with-param name="lang" select="$lang"/>
                    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                  </xsl:call-template>
                </xsl:variable>

                <xsl:choose>
                  <xsl:when test="$xref-number-and-title-context !=                                   $styled-xref-number-and-title-context and                                  $xref.number != '' and                                  $xref.with.number.and.title != 0">
                    <xsl:value-of select="$styled-xref-number-and-title-context"/>
                  </xsl:when>
                  <xsl:when test="$xref-number-context !=                                   $styled-xref-number-context and                                  $xref.number != ''">
                    <xsl:value-of select="$styled-xref-number-context"/>
                  </xsl:when>
                  <xsl:when test="$xref-context != $styled-xref-context">
                    <xsl:value-of select="$styled-xref-context"/>
                  </xsl:when>
                  <xsl:when test="$xref-number-and-title-context != '' and                                  $xref.number != '' and                                  $xref.with.number.and.title != 0">
                    <xsl:value-of select="$xref-number-and-title-context"/>
                    <xsl:if test="$olink.debug">
                      <xsl:message>
                        <xsl:text>Olink error: no gentext template</xsl:text>
                        <xsl:text> exists for xrefstyle '</xsl:text>
                        <xsl:value-of select="$xrefstyle"/>
                        <xsl:text>' for element '</xsl:text>
                        <xsl:value-of select="$target.elem"/>
                        <xsl:text>' in language '</xsl:text>
                        <xsl:value-of select="$lang"/>
                        <xsl:text>' in context 'xref-number-and-title</xsl:text>
                        <xsl:text>'. Using template without @style.</xsl:text>
                      </xsl:message>
                    </xsl:if>
                  </xsl:when>
                  <xsl:when test="$xref-number-context != '' and                                  $xref.number != ''">
                    <xsl:value-of select="$xref-number-context"/>
                    <xsl:if test="$olink.debug">
                      <xsl:message>
                        <xsl:text>Olink error: no gentext template</xsl:text>
                        <xsl:text> exists for xrefstyle '</xsl:text>
                        <xsl:value-of select="$xrefstyle"/>
                        <xsl:text>' for element '</xsl:text>
                        <xsl:value-of select="$target.elem"/>
                        <xsl:text>' in language '</xsl:text>
                        <xsl:value-of select="$lang"/>
                        <xsl:text>' in context 'xref-number</xsl:text>
                        <xsl:text>'. Using template without @style.</xsl:text>
                      </xsl:message>
                    </xsl:if>
                  </xsl:when>
                  <xsl:when test="$xref-context != ''">
                    <xsl:value-of select="$xref-context"/>
                    <xsl:if test="$olink.debug">
                      <xsl:message>
                        <xsl:text>Olink error: no gentext template</xsl:text>
                        <xsl:text> exists for xrefstyle '</xsl:text>
                        <xsl:value-of select="$xrefstyle"/>
                        <xsl:text>' for element '</xsl:text>
                        <xsl:value-of select="$target.elem"/>
                        <xsl:text>' in language '</xsl:text>
                        <xsl:value-of select="$lang"/>
                        <xsl:text>' in context 'xref</xsl:text>
                        <xsl:text>'. Using template without @style.</xsl:text>
                      </xsl:message>
                    </xsl:if>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:message>
                      <xsl:text>Olink error: no gentext template</xsl:text>
                      <xsl:text> exists for xrefstyle '</xsl:text>
                      <xsl:value-of select="$xrefstyle"/>
                      <xsl:text>' for element '</xsl:text>
                      <xsl:value-of select="$target.elem"/>
                      <xsl:text>' in language '</xsl:text>
                      <xsl:value-of select="$lang"/>
                      <xsl:text>'. Trying '%t'.</xsl:text>
                    </xsl:message>
                    <xsl:value-of select="'%t'"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>

          <xsl:if test="$olink.debug != 0">
            <xsl:message>
              <xsl:text>Olink debug: xrefstyle template is '</xsl:text>
              <xsl:value-of select="$template"/>
              <xsl:text>'.</xsl:text>
            </xsl:message>
          </xsl:if>

          <xsl:call-template name="substitute-markup">
            <xsl:with-param name="template" select="$template"/>
            <xsl:with-param name="title">
              <xsl:for-each select="$target.database">
                <xsl:call-template name="insert.targetdb.data">
                  <xsl:with-param name="data" select="key('targetptr-key', $olink.key)/ttl/node()"/>
                </xsl:call-template>
              </xsl:for-each>
            </xsl:with-param>
            <xsl:with-param name="label">
              <xsl:for-each select="$target.database">
                <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@number"/>
              </xsl:for-each>
            </xsl:with-param>
            <xsl:with-param name="pagenumber">
              <xsl:for-each select="$target.database">
                <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@page"/>
              </xsl:for-each>
            </xsl:with-param>
            <xsl:with-param name="docname">
              <xsl:for-each select="$target.database">
                <xsl:call-template name="insert.targetdb.data">
                  <xsl:with-param name="data" select="key('targetdoc-key', $targetdoc)[1]/div[1]/ttl/node()"/>
                </xsl:call-template>
              </xsl:for-each>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:when>

        <xsl:when test="$use.local.olink.style != 0">

          <!-- Is autonumbering on? -->
          <xsl:variable name="target.number">
            <xsl:for-each select="$target.database">
              <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@number"/>
            </xsl:for-each>
          </xsl:variable>

          <xsl:variable name="autonumber">
            <xsl:choose>
              <xsl:when test="$target.number != ''">1</xsl:when>
              <xsl:otherwise>0</xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
        
          <xsl:variable name="number-and-title-template">
            <xsl:call-template name="gentext.template.exists">
              <xsl:with-param name="context" select="'xref-number-and-title'"/>
              <xsl:with-param name="name" select="$target.elem"/>
            </xsl:call-template>
          </xsl:variable>
        
          <xsl:variable name="number-template">
            <xsl:call-template name="gentext.template.exists">
              <xsl:with-param name="context" select="'xref-number'"/>
              <xsl:with-param name="name" select="$target.elem"/>
            </xsl:call-template>
          </xsl:variable>
        
          <xsl:variable name="context">
            <xsl:choose>
              <xsl:when test="string($autonumber) != 0                                and $number-and-title-template != 0                               and $xref.with.number.and.title != 0">
                 <xsl:value-of select="'xref-number-and-title'"/>
              </xsl:when>
              <xsl:when test="string($autonumber) != 0                                and $number-template != 0">
                 <xsl:value-of select="'xref-number'"/>
              </xsl:when>
              <xsl:otherwise>
                 <xsl:value-of select="'xref'"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
        
          <xsl:variable name="template">
            <xsl:call-template name="gentext.template">
              <xsl:with-param name="context" select="$context"/>
              <xsl:with-param name="name" select="$target.elem"/>
              <xsl:with-param name="lang" select="$lang"/>
            </xsl:call-template>
          </xsl:variable>

          <xsl:call-template name="substitute-markup">
            <xsl:with-param name="template" select="$template"/>
            <xsl:with-param name="title">
              <xsl:for-each select="$target.database">
                <xsl:call-template name="insert.targetdb.data">
                  <xsl:with-param name="data" select="key('targetptr-key', $olink.key)[1]/ttl/node()"/>
                </xsl:call-template>
              </xsl:for-each>
            </xsl:with-param>
            <xsl:with-param name="label">
              <xsl:for-each select="$target.database">
                <xsl:call-template name="insert.targetdb.data">
                  <xsl:with-param name="data" select="key('targetptr-key', $olink.key)[1]/@number"/>
                </xsl:call-template>
              </xsl:for-each>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="$xref.text !=''">
          <xsl:copy-of select="$xref.text"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message>
            <xsl:text>Olink error: no generated text for </xsl:text>
            <xsl:text>targetdoc/targetptr/lang = '</xsl:text>
            <xsl:value-of select="$olink.key"/>
            <xsl:text>'.</xsl:text>
          </xsl:message>
          <xsl:text>????</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:if test="$olink.key != ''">
        <xsl:message>
          <xsl:text>Olink error: no generated text for </xsl:text>
          <xsl:text>targetdoc/targetptr/lang = '</xsl:text>
          <xsl:value-of select="$olink.key"/>
          <xsl:text>'.</xsl:text>
        </xsl:message>
      </xsl:if>
      <xsl:text>????</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="insert.targetdb.data">
  <xsl:param name="data"/>
  <!-- Customize this to massage data further -->
  <xsl:copy-of select="$data"/>
</xsl:template><xsl:template match="*" mode="olink.docname.markup">
  <!-- No-op for now -->
</xsl:template><xsl:template name="targetpath">
  <xsl:param name="dirnode"/>
  <xsl:param name="targetdoc" select="''"/>

<!-- 
<xsl:message>dirnode is <xsl:value-of select="$dirnode/@name"/></xsl:message>
<xsl:message>targetdoc is <xsl:value-of select="$targetdoc"/></xsl:message>
-->
  <!-- recursive template generates path to olink target directory -->
  <xsl:choose>
    <!-- Have we arrived at the final path step? -->
    <xsl:when test="$dirnode/child::document[@targetdoc = $targetdoc]">
      <!-- We are done -->
    </xsl:when>
    <!-- Have we reached the top without a match? -->
    <xsl:when test="local-name($dirnode) != 'dir'">
        <xsl:message>Olink error: cannot locate targetdoc <xsl:value-of select="$targetdoc"/> in sitemap</xsl:message>
    </xsl:when>
    <!-- Is the target in a descendant? -->
    <xsl:when test="$dirnode/descendant::document/@targetdoc = $targetdoc">
      <xsl:variable name="step" select="$dirnode/child::dir[descendant::document/@targetdoc = $targetdoc]"/>
      <xsl:if test="$step">
        <xsl:value-of select="$step/@name"/>
        <xsl:text>/</xsl:text>
      </xsl:if>
      <!-- Now recurse with the child -->
      <xsl:call-template name="targetpath">
        <xsl:with-param name="dirnode" select="$step"/>
        <xsl:with-param name="targetdoc" select="$targetdoc"/>
      </xsl:call-template>
    </xsl:when>
    <!-- Otherwise we need to move up a step -->
    <xsl:otherwise>
      <xsl:if test="$dirnode/parent::dir">
        <xsl:text>../</xsl:text>
      </xsl:if>
      <xsl:call-template name="targetpath">
        <xsl:with-param name="dirnode" select="$dirnode/parent::*"/>
        <xsl:with-param name="targetdoc" select="$targetdoc"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="olink.page.citation">
  <xsl:param name="olink.key" select="''"/>
  <xsl:param name="olink.lang" select="'en'"/>
  <xsl:param name="target.database"/>
  <xsl:param name="linkend" select="''"/>
  <xsl:param name="xrefstyle">
    <xsl:choose>
      <xsl:when test="@role and not(@xrefstyle)                        and $use.role.as.xrefstyle != 0">
        <xsl:value-of select="@role"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="@xrefstyle"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:param>

  <xsl:variable name="targetdoc">
    <xsl:value-of select="substring-before($olink.key, '/')"/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$linkend != ''">
      <xsl:call-template name="xref.page.citation">
        <xsl:with-param name="linkend" select="$linkend"/>
        <xsl:with-param name="target" select="key('id', $linkend)"/>
        <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="not(starts-with(normalize-space($xrefstyle),                         'select:')                  and (contains($xrefstyle, 'page')                      or contains($xrefstyle, 'Page')))                 and $current.docid != ''                  and $current.docid != $targetdoc                 and $insert.olink.page.number = 'yes' ">
  
      <xsl:variable name="page-number">
        <xsl:for-each select="$target.database">
          <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@page"/>
        </xsl:for-each>
      </xsl:variable>
  
      <xsl:if test="$page-number != ''">
        <xsl:call-template name="substitute-markup">
          <xsl:with-param name="template">
            <xsl:call-template name="gentext.template">
              <xsl:with-param name="name" select="'olink.page.citation'"/>
              <xsl:with-param name="context" select="'xref'"/>
              <xsl:with-param name="lang" select="$olink.lang"/>
            </xsl:call-template>
          </xsl:with-param>
          <xsl:with-param name="pagenumber" select="$page-number"/>
        </xsl:call-template>
      </xsl:if>
  
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template name="olink.document.citation">
  <xsl:param name="olink.key" select="''"/>
  <xsl:param name="olink.lang" select="'en'"/>
  <xsl:param name="target.database"/>
  <xsl:param name="xrefstyle">
    <xsl:choose>
      <xsl:when test="@role and not(@xrefstyle)                        and $use.role.as.xrefstyle != 0">
        <xsl:value-of select="@role"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="@xrefstyle"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:param>

  <xsl:variable name="page">
    <xsl:for-each select="$target.database">
      <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@page"/>
    </xsl:for-each>
  </xsl:variable>

  <xsl:variable name="targetdoc">
    <xsl:value-of select="substring-before($olink.key, '/')"/>
  </xsl:variable>

  <xsl:variable name="targetptr">
    <xsl:value-of select="substring-before(substring-after($olink.key, '/'), '/')"/>
  </xsl:variable>

  <!-- Don't add docname if pointing to root element -->
  <xsl:variable name="rootptr">
    <xsl:for-each select="$target.database">
      <xsl:value-of select="key('targetdoc-key', $targetdoc)[1]/div[1]/@targetptr"/>
    </xsl:for-each>
  </xsl:variable>

  <xsl:variable name="docname">
    <xsl:for-each select="$target.database">
      <xsl:call-template name="insert.targetdb.data">
        <xsl:with-param name="data" select="key('targetdoc-key', $targetdoc)[1]/div[1]/ttl/node()"/>
      </xsl:call-template>
    </xsl:for-each>
  </xsl:variable>

  <xsl:if test="not(starts-with(normalize-space($xrefstyle), 'select:')                and (contains($xrefstyle, 'docname')))               and ($olink.doctitle = 'yes' or $olink.doctitle = '1')               and $current.docid != ''                and $rootptr != $targetptr               and $current.docid != $targetdoc               and $docname != ''">
    <xsl:call-template name="substitute-markup">
      <xsl:with-param name="template">
        <xsl:call-template name="gentext.template">
          <xsl:with-param name="name" select="'olink.document.citation'"/>
          <xsl:with-param name="context" select="'xref'"/>
          <xsl:with-param name="lang" select="$olink.lang"/>
        </xsl:call-template>
      </xsl:with-param>
      <xsl:with-param name="docname" select="$docname"/>
      <xsl:with-param name="pagenumber" select="$page"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template name="xref.page.citation">
  <!-- Determine if this xref should have a page citation.
       Context node is the xref or local olink element -->
  <xsl:param name="linkend" select="@linkend"/>
  <xsl:param name="target" select="key('id', $linkend)"/>
  <xsl:param name="xrefstyle">
    <xsl:choose>
      <xsl:when test="@role and not(@xrefstyle)                        and $use.role.as.xrefstyle != 0">
        <xsl:value-of select="@role"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="@xrefstyle"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:param>

  <xsl:if test="not(starts-with(normalize-space($xrefstyle),'select:')                     and (contains($xrefstyle, 'page')                          or contains($xrefstyle, 'Page')))                 and ( $insert.xref.page.number = 'yes'                     or $insert.xref.page.number = '1')                 or local-name($target) = 'para'">
    <xsl:apply-templates select="$target" mode="page.citation">
      <xsl:with-param name="id" select="$linkend"/>
    </xsl:apply-templates>
  </xsl:if>
</xsl:template>
<doc:reference xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0"><info><title>Common Processing Instruction Reference</title>
    <releaseinfo role="meta">
      $Id: pi.xsl 8782 2010-07-27 21:15:17Z mzjn $
    </releaseinfo>
  </info>
  <partintro id="partintro">
    <title>Introduction</title>
    <para>This is generated reference documentation for all
      user-specifiable processing instructions (PIs) in the
      â€œcommonâ€ part of the DocBook XSL stylesheets.
      <note>
        <para>You add these PIs at particular points in a document to
          cause specific â€œexceptionsâ€ to formatting/output behavior. To
          make global changes in formatting/output behavior across an
          entire document, itâ€™s better to do it by setting an
          appropriate stylesheet parameter (if there is one).</para>
      </note>
    </para>
  </partintro>
</doc:reference><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbchoice_choice">
  <refpurpose>Generates a localized choice separator</refpurpose>
  <refdescription id="select.choice.separator-desc">
    <para>Use the <tag class="xmlpi">dbchoice choice</tag> PI to
      generate an appropriate localized â€œchoiceâ€ separator (for
      example, <literal>and</literal> or <literal>or</literal>)
      before the final item in an inline <tag>simplelist</tag></para>
    <warning>
      <para>This PI is a less-than-ideal hack; support for it may
        disappear in the future (particularly if and when a more
        appropriate means for marking up "choice" lists becomes
        available in DocBook).</para>
    </warning>
  </refdescription>
  <refsynopsisdiv>
    <synopsis><tag class="xmlpi">dbchoice choice="and"|"or"|<replaceable>string</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter>
    <variablelist>
      <varlistentry><term>choice="and"</term>
        <listitem>
          <para>generates a localized <literal>and</literal> separator</para>
        </listitem>
      </varlistentry>
      <varlistentry><term>choice="or"</term>
        <listitem>
          <para>generates a localized <literal>or</literal> separator</para>
        </listitem>
      </varlistentry>
      <varlistentry><term>choice="<replaceable>string</replaceable>"</term>
        <listitem>
          <para>generates a literal <replaceable>string</replaceable> separator</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
</doc:pi><xsl:template name="pi.dbchoice_choice">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="pi-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbchoice')"/>
    <xsl:with-param name="attribute">choice</xsl:with-param>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbtimestamp">
  <refpurpose>Inserts a date timestamp</refpurpose>
  <refdescription>
    <para>Use the <tag class="xmlpi">dbtimestamp</tag> PI at any point in a
      source document to cause a date timestamp (a formatted
      string representing the current date and time) to be
      inserted in output of the document.</para>
  </refdescription>
  <refsynopsisdiv>
    <synopsis><tag class="xmlpi">dbtimestamp format="<replaceable>formatstring</replaceable>" [padding="0"|"1"]</tag></synopsis>
  </refsynopsisdiv>
  <refparameter>
    <variablelist>
      <varlistentry><term>format="<replaceable>formatstring</replaceable>"</term>
        <listitem>
          <para>Specifies format in which the date and time are
            output</para>
        <note>
          <para>For details of the content of the format string,
            see <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Datetime.html">Date and time</link>.</para>
        </note>
        </listitem>
      </varlistentry>
      <varlistentry><term>padding="0"|"1"</term>
        <listitem>
          <para>Specifies padding behavior; if non-zero, padding is is added</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
</doc:pi><xsl:template name="pi.dbtimestamp">
  <xsl:variable name="format">
    <xsl:variable name="pi-format">
      <xsl:call-template name="pi-attribute">
        <xsl:with-param name="pis" select="."/>
        <xsl:with-param name="attribute">format</xsl:with-param>
      </xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$pi-format != ''">
        <xsl:value-of select="$pi-format"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="gentext.template">
          <xsl:with-param name="context" select="'datetime'"/>
          <xsl:with-param name="name" select="'format'"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable> 
  <xsl:variable name="padding">
    <xsl:variable name="pi-padding">
      <xsl:call-template name="pi-attribute">
        <xsl:with-param name="pis" select="."/>
        <xsl:with-param name="attribute">padding</xsl:with-param>
      </xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$pi-padding != ''">
        <xsl:value-of select="$pi-padding"/>
      </xsl:when>
      <xsl:otherwise>1</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:variable name="date">
    <xsl:choose>
      <xsl:when test="function-available('date:date-time')">
        <xsl:value-of select="date:date-time()"/>
      </xsl:when>
      <xsl:when test="function-available('date:dateTime')">
        <!-- Xalan quirk -->
        <xsl:value-of select="date:dateTime()"/>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>
  <xsl:choose>
    <xsl:when test="function-available('date:date-time') or       function-available('date:dateTime')">
      <xsl:call-template name="datetime.format">
        <xsl:with-param name="date" select="$date"/>
        <xsl:with-param name="format" select="$format"/>
        <xsl:with-param name="padding" select="$padding"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:message>
        Timestamp processing requires XSLT processor with EXSLT date support.
      </xsl:message>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbtex_delims">
  <refpurpose>Generates delimiters around embedded TeX equations
    in output</refpurpose>
  <refdescription>
    <para>Use the <tag class="xmlpi">dbtex delims</tag> PI as a
      child of a <tag>textobject</tag> containing embedded TeX
      markup, to cause that markup to be surrounded by
      <literal>$</literal> delimiter characters in output.</para>
      <warning>
       <para>This feature is useful for print/PDF output only if you
       use the obsolete and now unsupported PassiveTeX XSL-FO
       engine.</para>
      </warning>
  </refdescription>
  <refsynopsisdiv>
    <synopsis><tag class="xmlpi">dbtex delims="no"|"yes"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter>
    <variablelist>
      <varlistentry><term>dbtex delims="no"|"yes"</term>
        <listitem>
          <para>Specifies whether delimiters are output</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>

  <refsee role="params">
    <para><parameter>tex.math.delims</parameter></para>
  </refsee>
 
</doc:pi><xsl:template name="pi.dbtex_delims">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="pi-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbtex')"/>
    <xsl:with-param name="attribute" select="'delims'"/>
  </xsl:call-template>
</xsl:template><xsl:template match="processing-instruction()" mode="titlepage.mode">
  <!-- * Als process PIs on title pages -->
  <xsl:apply-templates select="."/>
</xsl:template><xsl:template match="processing-instruction('dbtimestamp')">
  <xsl:call-template name="pi.dbtimestamp"/>
</xsl:template><xsl:template name="datetime.format">
  <xsl:param name="date"/>
  <xsl:param name="format"/>
  <xsl:param name="padding" select="1"/>
  <xsl:if test="$format != ''">
    <!-- replace any whitespace in the format string with a non-breaking space -->
    <xsl:variable name="format-nbsp" select="translate($format,       ' &#9;&#13;&#10;',       '&#xA0;&#xA0;&#xA0;&#xA0;')"/>
    <xsl:variable name="tokenized-format-string">
      <xsl:call-template name="str.tokenize.keep.delimiters">
        <xsl:with-param name="string" select="$format-nbsp"/>
        <xsl:with-param name="delimiters" select="'&#xA0;,./-()[]:'"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$exsl.node.set.available != 0">
        <!-- We must preserve context node in order to get valid language -->
        <xsl:variable name="context" select="."/>
        <xsl:for-each select="exsl:node-set($tokenized-format-string)/node()">
          <xsl:variable name="token">
            <xsl:value-of select="."/>
          </xsl:variable>
          <!-- Restore context node -->
          <xsl:for-each select="$context">
            <xsl:choose>
              <xsl:when test="$token = 'a'">
                <xsl:call-template name="gentext.template">
                  <xsl:with-param name="context" select="'datetime-abbrev'"/>
                  <xsl:with-param name="name" select="date:day-abbreviation($date)"/>
                </xsl:call-template>
              </xsl:when>
              <xsl:when test="$token = 'A'">
                <xsl:call-template name="gentext.template">
                  <xsl:with-param name="context" select="'datetime-full'"/>
                  <xsl:with-param name="name" select="date:day-name($date)"/>
                </xsl:call-template>
              </xsl:when>
              <xsl:when test="$token = 'b'">
                <xsl:call-template name="gentext.template">
                  <xsl:with-param name="context" select="'datetime-abbrev'"/>
                  <xsl:with-param name="name" select="date:month-abbreviation($date)"/>
                </xsl:call-template>
              </xsl:when>
              <xsl:when test="$token = 'c'">
                <xsl:value-of select="date:date($date)"/>
                <xsl:text> </xsl:text>
                <xsl:value-of select="date:time($date)"/>
              </xsl:when>
              <xsl:when test="$token = 'B'">
                <xsl:call-template name="gentext.template">
                  <xsl:with-param name="context" select="'datetime-full'"/>
                  <xsl:with-param name="name" select="date:month-name($date)"/>
                </xsl:call-template>
              </xsl:when>
              <xsl:when test="$token = 'd'">
                <xsl:if test="$padding = 1 and                   string-length(date:day-in-month($date)) = 1">0</xsl:if>
                <xsl:value-of select="date:day-in-month($date)"/>
              </xsl:when>
              <xsl:when test="$token = 'H'">
                <xsl:if test="$padding = 1 and string-length(date:hour-in-day($date)) = 1">0</xsl:if>
                <xsl:value-of select="date:hour-in-day($date)"/>
              </xsl:when>
              <xsl:when test="$token = 'j'">
                <xsl:value-of select="date:day-in-year($date)"/>
              </xsl:when>
              <xsl:when test="$token = 'm'">
                <xsl:if test="$padding = 1 and string-length(date:month-in-year($date)) = 1">0</xsl:if>
                <xsl:value-of select="date:month-in-year($date)"/>
              </xsl:when>
              <xsl:when test="$token = 'M'">
                <xsl:if test="string-length(date:minute-in-hour($date)) = 1">0</xsl:if>
                <xsl:value-of select="date:minute-in-hour($date)"/>
              </xsl:when>
              <xsl:when test="$token = 'S'">
                <xsl:if test="string-length(date:second-in-minute($date)) = 1">0</xsl:if>
                <xsl:value-of select="date:second-in-minute($date)"/>
              </xsl:when>
              <xsl:when test="$token = 'U'">
                <xsl:value-of select="date:week-in-year($date)"/>
              </xsl:when>
              <xsl:when test="$token = 'w'">
                <xsl:value-of select="date:day-in-week($date)"/>
              </xsl:when>
              <xsl:when test="$token = 'x'">
                <xsl:value-of select="date:date($date)"/>
              </xsl:when>
              <xsl:when test="$token = 'X'">
                <xsl:value-of select="date:time($date)"/>
              </xsl:when>
              <xsl:when test="$token = 'Y'">
                <xsl:value-of select="date:year($date)"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="$token"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:for-each>
        </xsl:for-each>
      </xsl:when>
      <xsl:otherwise>
        <xsl:message>
          Timestamp processing requires an XSLT processor with support
          for the EXSLT node-set() function.
        </xsl:message>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
</xsl:template>
<xsl:variable name="toc.listitem.type">
  <xsl:choose>
    <xsl:when test="$toc.list.type = 'dl'">dt</xsl:when>
    <xsl:otherwise>li</xsl:otherwise>
  </xsl:choose>
</xsl:variable><xsl:variable name="toc.dd.type">
  <xsl:choose>
    <xsl:when test="$toc.list.type = 'dl'">dd</xsl:when>
    <xsl:otherwise/>
  </xsl:choose>
</xsl:variable><xsl:template name="make.toc">
  <xsl:param name="toc-context" select="."/>
  <xsl:param name="toc.title.p" select="true()"/>
  <xsl:param name="nodes" select="/NOT-AN-ELEMENT"/>

  <xsl:variable name="nodes.plus" select="$nodes | qandaset"/>

  <xsl:variable name="toc.title">
    <xsl:if test="$toc.title.p">
      <xsl:choose>
        <xsl:when test="$make.clean.html != 0">
          <div class="toc-title">
            <xsl:call-template name="gentext">
              <xsl:with-param name="key">TableofContents</xsl:with-param>
            </xsl:call-template>
          </div>
        </xsl:when>
        <xsl:otherwise>
          <p>
            <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
              <xsl:call-template name="gentext">
                <xsl:with-param name="key">TableofContents</xsl:with-param>
              </xsl:call-template>
            </strong>
          </p>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$manual.toc != ''">
      <xsl:variable name="id">
        <xsl:call-template name="object.id"/>
      </xsl:variable>
      <xsl:variable name="toc" select="document($manual.toc, .)"/>
      <xsl:variable name="tocentry" select="$toc//tocentry[@linkend=$id]"/>
      <xsl:if test="$tocentry and $tocentry/*">
        <div class="toc">
          <xsl:copy-of select="$toc.title"/>
          <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="toc.list.attributes">
              <xsl:with-param name="toc-context" select="$toc-context"/>
              <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
              <xsl:with-param name="nodes" select="$nodes"/>
            </xsl:call-template>
            <xsl:call-template name="manual-toc">
              <xsl:with-param name="tocentry" select="$tocentry/*[1]"/>
            </xsl:call-template>
          </xsl:element>
        </div>
      </xsl:if>
    </xsl:when>
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="$qanda.in.toc != 0">
          <xsl:if test="$nodes.plus">
            <div class="toc">
              <xsl:copy-of select="$toc.title"/>
              <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
                <xsl:call-template name="toc.list.attributes">
                  <xsl:with-param name="toc-context" select="$toc-context"/>
                  <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
                  <xsl:with-param name="nodes" select="$nodes"/>
                </xsl:call-template>
                <xsl:apply-templates select="$nodes.plus" mode="toc">
                  <xsl:with-param name="toc-context" select="$toc-context"/>
                </xsl:apply-templates>
              </xsl:element>
            </div>
          </xsl:if>
        </xsl:when>
        <xsl:otherwise>
          <xsl:if test="$nodes">
            <div class="toc">
              <xsl:copy-of select="$toc.title"/>
              <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
                <xsl:call-template name="toc.list.attributes">
                  <xsl:with-param name="toc-context" select="$toc-context"/>
                  <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
                  <xsl:with-param name="nodes" select="$nodes"/>
                </xsl:call-template>
                <xsl:apply-templates select="$nodes" mode="toc">
                  <xsl:with-param name="toc-context" select="$toc-context"/>
                </xsl:apply-templates>
              </xsl:element>
            </div>
          </xsl:if>
        </xsl:otherwise>
      </xsl:choose>

    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="toc.list.attributes">
  <xsl:param name="toc-context" select="."/>
  <xsl:param name="toc.title.p" select="true()"/>
  <xsl:param name="nodes" select="/NOT-AN-ELEMENT"/>

  <xsl:attribute name="class">toc</xsl:attribute>
</xsl:template><xsl:template name="make.lots">
  <xsl:param name="toc.params" select="''"/>
  <xsl:param name="toc"/>

  <xsl:if test="contains($toc.params, 'toc')">
    <xsl:copy-of select="$toc"/>
  </xsl:if>

  <xsl:if test="contains($toc.params, 'figure')">
    <xsl:call-template name="list.of.titles">
      <xsl:with-param name="titles" select="'figure'"/>
      <xsl:with-param name="nodes" select=".//figure"/>
    </xsl:call-template>
  </xsl:if>

  <xsl:if test="contains($toc.params, 'table')">
    <xsl:call-template name="list.of.titles">
      <xsl:with-param name="titles" select="'table'"/>
      <xsl:with-param name="nodes" select=".//table[not(@tocentry = 0)]"/>
    </xsl:call-template>
  </xsl:if>

  <xsl:if test="contains($toc.params, 'example')">
    <xsl:call-template name="list.of.titles">
      <xsl:with-param name="titles" select="'example'"/>
      <xsl:with-param name="nodes" select=".//example"/>
    </xsl:call-template>
  </xsl:if>

  <xsl:if test="contains($toc.params, 'equation')">
    <xsl:call-template name="list.of.titles">
      <xsl:with-param name="titles" select="'equation'"/>
      <xsl:with-param name="nodes" select=".//equation[title or info/title]"/>
    </xsl:call-template>
  </xsl:if>

  <xsl:if test="contains($toc.params, 'procedure')">
    <xsl:call-template name="list.of.titles">
      <xsl:with-param name="titles" select="'procedure'"/>
      <xsl:with-param name="nodes" select=".//procedure[title]"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template name="set.toc">
  <xsl:param name="toc-context" select="."/>
  <xsl:param name="toc.title.p" select="true()"/>

  <xsl:call-template name="make.toc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
    <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
    <xsl:with-param name="nodes" select="book|setindex|set"/>
  </xsl:call-template>
</xsl:template><xsl:template name="division.toc">
  <xsl:param name="toc-context" select="."/>
  <xsl:param name="toc.title.p" select="true()"/>

  <xsl:call-template name="make.toc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
    <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
    <xsl:with-param name="nodes" select="part|reference                                          |preface|chapter|appendix                                          |article                                          |topic                                          |bibliography|glossary|index                                          |refentry                                          |bridgehead[$bridgehead.in.toc != 0]"/>

  </xsl:call-template>
</xsl:template><xsl:template name="component.toc">
  <xsl:param name="toc-context" select="."/>
  <xsl:param name="toc.title.p" select="true()"/>

  <xsl:call-template name="make.toc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
    <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
    <xsl:with-param name="nodes" select="section|sect1                                          |simplesect[$simplesect.in.toc != 0]                                          |topic                                          |refentry                                          |article|bibliography|glossary                                          |appendix|index                                          |bridgehead[not(@renderas)                                                      and $bridgehead.in.toc != 0]                                          |.//bridgehead[@renderas='sect1'                                                         and $bridgehead.in.toc != 0]"/>
  </xsl:call-template>
</xsl:template><xsl:template name="component.toc.separator">
  <!-- Customize to output something between
       component.toc and first output -->
</xsl:template><xsl:template name="section.toc">
  <xsl:param name="toc-context" select="."/>
  <xsl:param name="toc.title.p" select="true()"/>

  <xsl:call-template name="make.toc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
    <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
    <xsl:with-param name="nodes" select="section|sect1|sect2|sect3|sect4|sect5|refentry                            |bridgehead[$bridgehead.in.toc != 0]"/>

  </xsl:call-template>
</xsl:template><xsl:template name="section.toc.separator">
  <!-- Customize to output something between
       section.toc and first output -->
</xsl:template><xsl:template name="subtoc">
  <xsl:param name="toc-context" select="."/>
  <xsl:param name="nodes" select="NOT-AN-ELEMENT"/>

  <xsl:variable name="nodes.plus" select="$nodes | qandaset"/>

  <xsl:variable name="subtoc">
    <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
      <xsl:choose>
        <xsl:when test="$qanda.in.toc != 0">
          <xsl:apply-templates mode="toc" select="$nodes.plus">
            <xsl:with-param name="toc-context" select="$toc-context"/>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates mode="toc" select="$nodes">
            <xsl:with-param name="toc-context" select="$toc-context"/>
          </xsl:apply-templates>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:element>
  </xsl:variable>

  <xsl:variable name="depth">
    <xsl:choose>
      <xsl:when test="local-name(.) = 'section'">
        <xsl:value-of select="count(ancestor::section) + 1"/>
      </xsl:when>
      <xsl:when test="local-name(.) = 'sect1'">1</xsl:when>
      <xsl:when test="local-name(.) = 'sect2'">2</xsl:when>
      <xsl:when test="local-name(.) = 'sect3'">3</xsl:when>
      <xsl:when test="local-name(.) = 'sect4'">4</xsl:when>
      <xsl:when test="local-name(.) = 'sect5'">5</xsl:when>
      <xsl:when test="local-name(.) = 'refsect1'">1</xsl:when>
      <xsl:when test="local-name(.) = 'refsect2'">2</xsl:when>
      <xsl:when test="local-name(.) = 'refsect3'">3</xsl:when>
      <xsl:when test="local-name(.) = 'topic'">1</xsl:when>
      <xsl:when test="local-name(.) = 'simplesect'">
        <!-- sigh... -->
        <xsl:choose>
          <xsl:when test="local-name(..) = 'section'">
            <xsl:value-of select="count(ancestor::section)"/>
          </xsl:when>
          <xsl:when test="local-name(..) = 'sect1'">2</xsl:when>
          <xsl:when test="local-name(..) = 'sect2'">3</xsl:when>
          <xsl:when test="local-name(..) = 'sect3'">4</xsl:when>
          <xsl:when test="local-name(..) = 'sect4'">5</xsl:when>
          <xsl:when test="local-name(..) = 'sect5'">6</xsl:when>
          <xsl:when test="local-name(..) = 'topic'">2</xsl:when>
          <xsl:when test="local-name(..) = 'refsect1'">2</xsl:when>
          <xsl:when test="local-name(..) = 'refsect2'">3</xsl:when>
          <xsl:when test="local-name(..) = 'refsect3'">4</xsl:when>
          <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>0</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="depth.from.context" select="count(ancestor::*)-count($toc-context/ancestor::*)"/>

  <xsl:variable name="subtoc.list">
    <xsl:choose>
      <xsl:when test="$toc.dd.type = ''">
        <xsl:copy-of select="$subtoc"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="{$toc.dd.type}" namespace="http://www.w3.org/1999/xhtml">
          <xsl:copy-of select="$subtoc"/>
        </xsl:element>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:element name="{$toc.listitem.type}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:call-template name="toc.line">
      <xsl:with-param name="toc-context" select="$toc-context"/>
    </xsl:call-template>
    <xsl:if test="$toc.listitem.type = 'li' and                   ( (self::set or self::book or self::part) or                          $toc.section.depth &gt; $depth) and                    ( ($qanda.in.toc = 0 and count($nodes)&gt;0) or                     ($qanda.in.toc != 0 and count($nodes.plus)&gt;0) )                   and $toc.max.depth &gt; $depth.from.context">
      <xsl:copy-of select="$subtoc.list"/>
    </xsl:if>
  </xsl:element>
  <xsl:if test="$toc.listitem.type != 'li' and                   ( (self::set or self::book or self::part) or                          $toc.section.depth &gt; $depth) and                  ( ($qanda.in.toc = 0 and count($nodes)&gt;0) or                   ($qanda.in.toc != 0 and count($nodes.plus)&gt;0) )                 and $toc.max.depth &gt; $depth.from.context">
    <xsl:copy-of select="$subtoc.list"/>
  </xsl:if>
</xsl:template><xsl:template name="toc.line">
  <xsl:param name="toc-context" select="."/>
  <xsl:param name="depth" select="1"/>
  <xsl:param name="depth.from.context" select="8"/>

 <span>
  <xsl:attribute name="class"><xsl:value-of select="local-name(.)"/></xsl:attribute>

  <!-- * if $autotoc.label.in.hyperlink is zero, then output the label -->
  <!-- * before the hyperlinked title (as the DSSSL stylesheet does) -->
  <xsl:if test="$autotoc.label.in.hyperlink = 0">
    <xsl:variable name="label">
      <xsl:apply-templates select="." mode="label.markup"/>
    </xsl:variable>
    <xsl:copy-of select="$label"/>
    <xsl:if test="$label != ''">
      <xsl:value-of select="$autotoc.label.separator"/>
    </xsl:if>
  </xsl:if>

  <a>
    <xsl:attribute name="href">
      <xsl:call-template name="href.target">
        <xsl:with-param name="context" select="$toc-context"/>
        <xsl:with-param name="toc-context" select="$toc-context"/>
      </xsl:call-template>
    </xsl:attribute>
    
  <!-- * if $autotoc.label.in.hyperlink is non-zero, then output the label -->
  <!-- * as part of the hyperlinked title -->
  <xsl:if test="not($autotoc.label.in.hyperlink = 0)">
    <xsl:variable name="label">
      <xsl:apply-templates select="." mode="label.markup"/>
    </xsl:variable>
    <xsl:copy-of select="$label"/>
    <xsl:if test="$label != ''">
      <xsl:value-of select="$autotoc.label.separator"/>
    </xsl:if>
  </xsl:if>

    <xsl:apply-templates select="." mode="titleabbrev.markup"/>
  </a>
  </span>
</xsl:template><xsl:template match="book" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <xsl:call-template name="subtoc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
    <xsl:with-param name="nodes" select="part|reference                                          |preface|chapter|appendix                                          |article                                          |topic                                          |bibliography|glossary|index                                          |refentry                                          |bridgehead[$bridgehead.in.toc != 0]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="setindex" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <!-- If the setindex tag is not empty, it should be it in the TOC -->
  <xsl:if test="* or $generate.index != 0">
    <xsl:call-template name="subtoc">
      <xsl:with-param name="toc-context" select="$toc-context"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template match="part|reference" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <xsl:call-template name="subtoc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
    <xsl:with-param name="nodes" select="appendix|chapter|article|topic                                          |index|glossary|bibliography                                          |preface|reference|refentry                                          |bridgehead[$bridgehead.in.toc != 0]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="preface|chapter|appendix|article|topic" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <xsl:call-template name="subtoc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
    <xsl:with-param name="nodes" select="section|sect1                                          |simplesect[$simplesect.in.toc != 0]                                          |topic                                          |refentry                                          |glossary|bibliography|index                                          |bridgehead[$bridgehead.in.toc != 0]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="sect1" mode="toc">
  <xsl:param name="toc-context" select="."/>
  <xsl:call-template name="subtoc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
    <xsl:with-param name="nodes" select="sect2                                          |bridgehead[$bridgehead.in.toc != 0]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="sect2" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <xsl:call-template name="subtoc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
    <xsl:with-param name="nodes" select="sect3                                          |bridgehead[$bridgehead.in.toc != 0]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="sect3" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <xsl:call-template name="subtoc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
    <xsl:with-param name="nodes" select="sect4                                          |bridgehead[$bridgehead.in.toc != 0]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="sect4" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <xsl:call-template name="subtoc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
    <xsl:with-param name="nodes" select="sect5                                          |bridgehead[$bridgehead.in.toc != 0]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="sect5" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <xsl:call-template name="subtoc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
  </xsl:call-template>
</xsl:template><xsl:template match="simplesect" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <xsl:call-template name="subtoc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
  </xsl:call-template>
</xsl:template><xsl:template match="section" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <xsl:call-template name="subtoc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
    <xsl:with-param name="nodes" select="section|refentry                                          |simplesect[$simplesect.in.toc != 0]                                          |bridgehead[$bridgehead.in.toc != 0]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="topic" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <xsl:call-template name="subtoc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
    <xsl:with-param name="nodes" select="section|refentry                                          |simplesect[$simplesect.in.toc != 0]                                          |bridgehead[$bridgehead.in.toc != 0]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="bridgehead" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <xsl:if test="$bridgehead.in.toc != 0">
    <xsl:call-template name="subtoc">
      <xsl:with-param name="toc-context" select="$toc-context"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template match="bibliography|glossary" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <xsl:call-template name="subtoc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
  </xsl:call-template>
</xsl:template><xsl:template match="index" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <!-- If the index tag is not empty, it should be it in the TOC -->
  <xsl:if test="* or $generate.index != 0">
    <xsl:call-template name="subtoc">
      <xsl:with-param name="toc-context" select="$toc-context"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template match="refentry" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <xsl:variable name="refmeta" select=".//refmeta"/>
  <xsl:variable name="refentrytitle" select="$refmeta//refentrytitle"/>
  <xsl:variable name="refnamediv" select=".//refnamediv"/>
  <xsl:variable name="refname" select="$refnamediv//refname"/>
  <xsl:variable name="refdesc" select="$refnamediv//refdescriptor"/>
  <xsl:variable name="title">
    <xsl:choose>
      <xsl:when test="$refentrytitle">
        <xsl:apply-templates select="$refentrytitle[1]" mode="titleabbrev.markup"/>
      </xsl:when>
      <xsl:when test="$refdesc">
        <xsl:apply-templates select="$refdesc" mode="titleabbrev.markup"/>
      </xsl:when>
      <xsl:when test="$refname">
        <xsl:apply-templates select="$refname[1]" mode="titleabbrev.markup"/>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:element name="{$toc.listitem.type}" namespace="http://www.w3.org/1999/xhtml">
    <span class="refentrytitle">
      <a>
        <xsl:attribute name="href">
          <xsl:call-template name="href.target">
            <xsl:with-param name="toc-context" select="$toc-context"/>
          </xsl:call-template>
        </xsl:attribute>
        <xsl:copy-of select="$title"/>
      </a>
    </span>
    <span class="refpurpose">
      <xsl:if test="$annotate.toc != 0">
        <!-- * DocBook 5 says inlinemediaobject (among other things) -->
        <!-- * is allowed in refpurpose; so we need to run -->
        <!-- * apply-templates on refpurpose here, instead of value-of  -->
        <xsl:apply-templates select="refnamediv/refpurpose" mode="no.anchor.mode"/>
      </xsl:if>
    </span>
  </xsl:element>
</xsl:template><xsl:template match="title" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <a>
    <xsl:attribute name="href">
      <xsl:call-template name="href.target">
        <xsl:with-param name="object" select=".."/>
        <xsl:with-param name="toc-context" select="$toc-context"/>
      </xsl:call-template>
    </xsl:attribute>
    <xsl:apply-templates/>
  </a>
</xsl:template><xsl:template name="manual-toc">
  <xsl:param name="toc-context" select="."/>
  <xsl:param name="tocentry"/>
  <xsl:param name="toc.title.p" select="true()"/>
  <xsl:param name="nodes" select="/NOT-AN-ELEMENT"/>

  <!-- be careful, we don't want to change the current document to the other tree! -->

  <xsl:if test="$tocentry">
    <xsl:variable name="node" select="key('id', $tocentry/@linkend)"/>

    <xsl:element name="{$toc.listitem.type}" namespace="http://www.w3.org/1999/xhtml">
      <xsl:variable name="label">
        <xsl:apply-templates select="$node" mode="label.markup"/>
      </xsl:variable>
      <xsl:copy-of select="$label"/>
      <xsl:if test="$label != ''">
        <xsl:value-of select="$autotoc.label.separator"/>
      </xsl:if>
      <a>
        <xsl:attribute name="href">
          <xsl:call-template name="href.target">
            <xsl:with-param name="object" select="$node"/>
            <xsl:with-param name="toc-context" select="$toc-context"/>
          </xsl:call-template>
        </xsl:attribute>
        <xsl:apply-templates select="$node" mode="titleabbrev.markup"/>
      </a>
    </xsl:element>

    <xsl:if test="$tocentry/*">
      <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
        <xsl:call-template name="toc.list.attributes">
          <xsl:with-param name="toc-context" select="$toc-context"/>
          <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
          <xsl:with-param name="nodes" select="$nodes"/>
        </xsl:call-template>
        <xsl:call-template name="manual-toc">
          <xsl:with-param name="tocentry" select="$tocentry/*[1]"/>
        </xsl:call-template>
      </xsl:element>
    </xsl:if>

    <xsl:if test="$tocentry/following-sibling::*">
      <xsl:call-template name="manual-toc">
        <xsl:with-param name="tocentry" select="$tocentry/following-sibling::*[1]"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:if>
</xsl:template><xsl:template name="list.of.titles">
  <xsl:param name="toc-context" select="."/>
  <xsl:param name="titles" select="'table'"/>
  <xsl:param name="nodes" select=".//table"/>

  <xsl:if test="$nodes">
    <div class="list-of-{$titles}s">
      <xsl:choose>
        <xsl:when test="$make.clean.html != 0">
          <div class="toc-title">
            <xsl:call-template name="gentext">
              <xsl:with-param name="key">
                <xsl:choose>
                  <xsl:when test="$titles='table'">ListofTables</xsl:when>
                  <xsl:when test="$titles='figure'">ListofFigures</xsl:when>
                  <xsl:when test="$titles='equation'">ListofEquations</xsl:when>
                  <xsl:when test="$titles='example'">ListofExamples</xsl:when>
                  <xsl:when test="$titles='procedure'">ListofProcedures</xsl:when>
                  <xsl:otherwise>ListofUnknown</xsl:otherwise>
                </xsl:choose>
              </xsl:with-param>
            </xsl:call-template>
          </div>
        </xsl:when>
        <xsl:otherwise>
          <p>
            <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
              <xsl:call-template name="gentext">
                <xsl:with-param name="key">
                  <xsl:choose>
                    <xsl:when test="$titles='table'">ListofTables</xsl:when>
                    <xsl:when test="$titles='figure'">ListofFigures</xsl:when>
                    <xsl:when test="$titles='equation'">ListofEquations</xsl:when>
                    <xsl:when test="$titles='example'">ListofExamples</xsl:when>
                    <xsl:when test="$titles='procedure'">ListofProcedures</xsl:when>
                    <xsl:otherwise>ListofUnknown</xsl:otherwise>
                  </xsl:choose>
                </xsl:with-param>
              </xsl:call-template>
            </strong>
          </p>
        </xsl:otherwise>
      </xsl:choose>

      <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
        <xsl:apply-templates select="$nodes" mode="toc">
          <xsl:with-param name="toc-context" select="$toc-context"/>
        </xsl:apply-templates>
      </xsl:element>
    </div>
  </xsl:if>
</xsl:template><xsl:template match="figure|table|example|equation|procedure" mode="toc">
  <xsl:param name="toc-context" select="."/>

  <xsl:element name="{$toc.listitem.type}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:variable name="label">
      <xsl:apply-templates select="." mode="label.markup"/>
    </xsl:variable>
    <xsl:copy-of select="$label"/>
    <xsl:if test="$label != ''">
      <xsl:value-of select="$autotoc.label.separator"/>
    </xsl:if>
    <a>
      <xsl:attribute name="href">
        <xsl:call-template name="href.target">
          <xsl:with-param name="toc-context" select="$toc-context"/>
        </xsl:call-template>
      </xsl:attribute>
      <xsl:apply-templates select="." mode="titleabbrev.markup"/>
    </a>
  </xsl:element>
</xsl:template><xsl:template match="qandaset" mode="toc">
  <xsl:param name="toc-context" select="."/>
  <xsl:call-template name="subtoc">
    <xsl:with-param name="toc-context" select="$toc-context"/>
    <xsl:with-param name="nodes" select="qandadiv | qandaentry"/>
  </xsl:call-template>
</xsl:template><xsl:template match="qandadiv|qandaentry" mode="toc">
  <xsl:apply-templates select="." mode="qandatoc.mode"/>
</xsl:template>
<xsl:variable name="kimber.imported" select="0"/><xsl:variable name="kosek.imported" select="0"/><xsl:key name="letter" match="indexterm" use="translate(substring(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 1, 1),'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;','AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/><xsl:key name="primary" match="indexterm" use="normalize-space(concat(primary/@sortas, &quot; &quot;, primary))"/><xsl:key name="secondary" match="indexterm" use="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)))"/><xsl:key name="tertiary" match="indexterm" use="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)))"/><xsl:key name="endofrange" match="indexterm[@class='endofrange']" use="@startref"/><xsl:key name="primary-section" match="indexterm[not(secondary) and not(see)]" use="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, generate-id((ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()]))"/><xsl:key name="secondary-section" match="indexterm[not(tertiary) and not(see)]" use="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, generate-id((ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()]))"/><xsl:key name="tertiary-section" match="indexterm[not(see)]" use="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)), &quot; &quot;, generate-id((ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()]))"/><xsl:key name="see-also" match="indexterm[seealso]" use="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)), &quot; &quot;, seealso)"/><xsl:key name="see" match="indexterm[see]" use="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)), &quot; &quot;, see)"/><xsl:key name="sections" match="*[@id or @xml:id]" use="@id|@xml:id"/><xsl:template name="generate-index">
  <xsl:param name="scope" select="(ancestor::book|/)[last()]"/>

  <xsl:choose>
    <xsl:when test="$index.method = 'kosek'">
      <xsl:call-template name="generate-kosek-index">
        <xsl:with-param name="scope" select="$scope"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$index.method = 'kimber'">
      <xsl:call-template name="generate-kimber-index">
        <xsl:with-param name="scope" select="$scope"/>
      </xsl:call-template>
    </xsl:when>

    <xsl:otherwise>
      <xsl:call-template name="generate-basic-index">
        <xsl:with-param name="scope" select="$scope"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="generate-basic-index">
  <xsl:param name="scope" select="NOTANODE"/>

  <xsl:variable name="role">
    <xsl:if test="$index.on.role != 0">
      <xsl:value-of select="@role"/>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="type">
    <xsl:if test="$index.on.type != 0">
      <xsl:value-of select="@type"/>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="terms" select="//indexterm                         [count(.|key('letter',                           translate(substring(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 1, 1),                              'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;',                              'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'))                           [count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1                           and not(@class = 'endofrange')]"/>

  <xsl:variable name="alphabetical" select="$terms[contains(concat('Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'),                                         substring(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 1, 1))]"/>

  <xsl:variable name="others" select="$terms[not(contains(concat('Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;',                                                  'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'),                                              substring(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 1, 1)))]"/>
  <div class="index">
    <xsl:if test="$others">
      <xsl:choose>
        <xsl:when test="normalize-space($type) != '' and                          $others[@type = $type][count(.|key('primary', normalize-space(concat(primary/@sortas, &quot; &quot;, primary)))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1]">
          <div class="indexdiv">
            <h3>
              <xsl:call-template name="gentext">
                <xsl:with-param name="key" select="'index symbols'"/>
              </xsl:call-template>
            </h3>
            <dl>
              <xsl:apply-templates select="$others[count(.|key('primary', normalize-space(concat(primary/@sortas, &quot; &quot;, primary)))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1]" mode="index-symbol-div">
                <xsl:with-param name="position" select="position()"/>                                
                <xsl:with-param name="scope" select="$scope"/>
                <xsl:with-param name="role" select="$role"/>
                <xsl:with-param name="type" select="$type"/>
                <xsl:sort select="translate(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
              </xsl:apply-templates>
            </dl>
          </div>
        </xsl:when>
        <xsl:when test="normalize-space($type) != ''"> 
          <!-- Output nothing, as there isn't a match for $other using this $type -->
        </xsl:when>  
        <xsl:otherwise>
          <div class="indexdiv">
            <h3>
              <xsl:call-template name="gentext">
                <xsl:with-param name="key" select="'index symbols'"/>
              </xsl:call-template>
            </h3>
            <dl>
              <xsl:apply-templates select="$others[count(.|key('primary',                                           normalize-space(concat(primary/@sortas, &quot; &quot;, primary)))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1]" mode="index-symbol-div">
                <xsl:with-param name="position" select="position()"/>                                
                <xsl:with-param name="scope" select="$scope"/>
                <xsl:with-param name="role" select="$role"/>
                <xsl:with-param name="type" select="$type"/>
                <xsl:sort select="translate(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
              </xsl:apply-templates>
            </dl>
          </div>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>

    <xsl:apply-templates select="$alphabetical[count(.|key('letter',                                  translate(substring(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 1, 1),                                            'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;','AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1]" mode="index-div-basic">
      <xsl:with-param name="position" select="position()"/>
      <xsl:with-param name="scope" select="$scope"/>
      <xsl:with-param name="role" select="$role"/>
      <xsl:with-param name="type" select="$type"/>
      <xsl:sort select="translate(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
    </xsl:apply-templates>
  </div>
</xsl:template><xsl:template name="generate-kosek-index">
  <xsl:param name="scope" select="NOTANODE"/>

  <xsl:variable name="vendor" select="system-property('xsl:vendor')"/>
  <xsl:if test="contains($vendor, 'libxslt')">
    <xsl:message terminate="yes">
      <xsl:text>ERROR: the 'kosek' index method does not </xsl:text>
      <xsl:text>work with the xsltproc XSLT processor.</xsl:text>
    </xsl:message>
  </xsl:if>


  <xsl:if test="$exsl.node.set.available = 0">
    <xsl:message terminate="yes">
      <xsl:text>ERROR: the 'kosek' index method requires the </xsl:text>
      <xsl:text>exslt:node-set() function. Use a processor that </xsl:text>
      <xsl:text>has it, or use a different index method.</xsl:text>
    </xsl:message>
  </xsl:if>

  <xsl:if test="$kosek.imported = 0">
    <xsl:message terminate="yes">
      <xsl:text>ERROR: the 'kosek' index method requires the
</xsl:text>
      <xsl:text>kosek index extensions be imported:
</xsl:text>
      <xsl:text>  xsl:import href="html/autoidx-kosek.xsl"</xsl:text>
    </xsl:message>
  </xsl:if>

</xsl:template><xsl:template name="generate-kimber-index">
  <xsl:param name="scope" select="NOTANODE"/>

  <xsl:variable name="vendor" select="system-property('xsl:vendor')"/>
  <xsl:if test="not(contains($vendor, 'SAXON '))">
    <xsl:message terminate="yes">
      <xsl:text>ERROR: the 'kimber' index method requires the </xsl:text>
      <xsl:text>Saxon version 6 or 8 XSLT processor.</xsl:text>
    </xsl:message>
  </xsl:if>

  <xsl:if test="$kimber.imported = 0">
    <xsl:message terminate="yes">
      <xsl:text>ERROR: the 'kimber' index method requires the
</xsl:text>
      <xsl:text>kimber index extensions be imported:
</xsl:text>
      <xsl:text>  xsl:import href="html/autoidx-kimber.xsl"</xsl:text>
    </xsl:message>
  </xsl:if>

</xsl:template><xsl:template match="indexterm" mode="index-div-basic">
  <xsl:param name="scope" select="."/>
  <xsl:param name="role" select="''"/>
  <xsl:param name="type" select="''"/>

  <xsl:variable name="key" select="translate(substring(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 1, 1),                          'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;','AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>

  <xsl:if test="key('letter', $key)[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]                 [count(.|key('primary', normalize-space(concat(primary/@sortas, &quot; &quot;, primary)))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1]">
    <div class="indexdiv">
      <xsl:if test="contains(concat('Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'), $key)">
        <h3>
          <xsl:value-of select="translate($key, 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
        </h3>
      </xsl:if>
      <dl>
        <xsl:apply-templates select="key('letter', $key)[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]                                      [count(.|key('primary', normalize-space(concat(primary/@sortas, &quot; &quot;, primary)))                                      [count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])=1]" mode="index-primary">
          <xsl:with-param name="position" select="position()"/>
          <xsl:with-param name="scope" select="$scope"/>
          <xsl:with-param name="role" select="$role"/>
          <xsl:with-param name="type" select="$type"/>
          <xsl:sort select="translate(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
        </xsl:apply-templates>
      </dl>
    </div>
  </xsl:if>
</xsl:template><xsl:template match="indexterm" mode="index-symbol-div">
  <xsl:param name="scope" select="/"/>
  <xsl:param name="role" select="''"/>
  <xsl:param name="type" select="''"/>

  <xsl:variable name="key" select="translate(substring(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 1, 1),                                              'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;','AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>

  <xsl:apply-templates select="key('letter', $key)                                [count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][count(.|key('primary', normalize-space(concat(primary/@sortas, &quot; &quot;, primary)))[1]) = 1]" mode="index-primary">
    <xsl:with-param name="position" select="position()"/>
    <xsl:with-param name="scope" select="$scope"/>
    <xsl:with-param name="role" select="$role"/>
    <xsl:with-param name="type" select="$type"/>
    <xsl:sort select="translate(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="indexterm" mode="index-primary">
  <xsl:param name="scope" select="."/>
  <xsl:param name="role" select="''"/>
  <xsl:param name="type" select="''"/>

  <xsl:variable name="key" select="normalize-space(concat(primary/@sortas, &quot; &quot;, primary))"/>
  <xsl:variable name="refs" select="key('primary', $key)[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]"/>
  <dt>
    <xsl:for-each select="$refs/primary">
      <xsl:if test="@id or @xml:id">
        <xsl:choose>
          <xsl:when test="$generate.id.attributes = 0">
            <a id="{(@id|@xml:id)[1]}"/>
          </xsl:when>
          <xsl:otherwise>
            <span>
              <xsl:call-template name="id.attribute"/>
            </span>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
    </xsl:for-each>
    <xsl:value-of select="primary"/>
    <xsl:choose>
      <xsl:when test="$index.links.to.section = 1">
        <xsl:for-each select="$refs[@zone != '' or generate-id() = generate-id(key('primary-section', concat($key, &quot; &quot;, generate-id((ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()])))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]">
          <xsl:apply-templates select="." mode="reference">
            <xsl:with-param name="position" select="position()"/>
            <xsl:with-param name="scope" select="$scope"/>
            <xsl:with-param name="role" select="$role"/>
            <xsl:with-param name="type" select="$type"/>
          </xsl:apply-templates>
        </xsl:for-each>
      </xsl:when>
      <xsl:otherwise>
        <xsl:for-each select="$refs[not(see)                                and not(secondary)][count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]">
          <xsl:apply-templates select="." mode="reference">
            <xsl:with-param name="position" select="position()"/>
            <xsl:with-param name="scope" select="$scope"/>
            <xsl:with-param name="role" select="$role"/>
            <xsl:with-param name="type" select="$type"/>
          </xsl:apply-templates>
        </xsl:for-each>
      </xsl:otherwise>
    </xsl:choose>

    <xsl:if test="$refs[not(secondary)]/*[self::see]">
      <xsl:apply-templates select="$refs[generate-id() = generate-id(key('see', concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, &quot; &quot;, &quot; &quot;, see))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]" mode="index-see">
        <xsl:with-param name="position" select="position()"/>
        <xsl:with-param name="scope" select="$scope"/>
        <xsl:with-param name="role" select="$role"/>
        <xsl:with-param name="type" select="$type"/>
        <xsl:sort select="translate(see, 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
      </xsl:apply-templates>
    </xsl:if>
  </dt>
  <xsl:choose>
    <xsl:when test="$refs/secondary or $refs[not(secondary)]/*[self::seealso]">
      <dd>
        <dl>
          <xsl:apply-templates select="$refs[generate-id() = generate-id(key('see-also', concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, &quot; &quot;, &quot; &quot;, seealso))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]" mode="index-seealso">
            <xsl:with-param name="position" select="position()"/>
            <xsl:with-param name="scope" select="$scope"/>
            <xsl:with-param name="role" select="$role"/>
            <xsl:with-param name="type" select="$type"/>
            <xsl:sort select="translate(seealso, 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
          </xsl:apply-templates>
          <xsl:apply-templates select="$refs[secondary and count(.|key('secondary', concat($key, &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary))))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1]" mode="index-secondary">
            <xsl:with-param name="position" select="position()"/>
            <xsl:with-param name="scope" select="$scope"/>
            <xsl:with-param name="role" select="$role"/>
            <xsl:with-param name="type" select="$type"/>
            <xsl:sort select="translate(normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
          </xsl:apply-templates>
        </dl>
      </dd>
    </xsl:when>
    <!-- HTML5 requires dd for each dt -->
    <xsl:when test="$div.element = 'section'">
      <dd/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="indexterm" mode="index-secondary">
  <xsl:param name="scope" select="."/>
  <xsl:param name="role" select="''"/>
  <xsl:param name="type" select="''"/>

  <xsl:variable name="key" select="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)))"/>
  <xsl:variable name="refs" select="key('secondary', $key)[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]"/>
  <dt>
    <xsl:for-each select="$refs/secondary">
      <xsl:if test="@id or @xml:id">
        <xsl:choose>
          <xsl:when test="$generate.id.attributes = 0">
            <a id="{(@id|@xml:id)[1]}"/>
          </xsl:when>
          <xsl:otherwise>
            <span>
              <xsl:call-template name="id.attribute"/>
            </span>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
    </xsl:for-each>
    <xsl:value-of select="secondary"/>
    <xsl:choose>
      <xsl:when test="$index.links.to.section = 1">
        <xsl:for-each select="$refs[@zone != '' or generate-id() = generate-id(key('secondary-section', concat($key, &quot; &quot;, generate-id((ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()])))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]">
          <xsl:apply-templates select="." mode="reference">
            <xsl:with-param name="position" select="position()"/>
            <xsl:with-param name="scope" select="$scope"/>
            <xsl:with-param name="role" select="$role"/>
            <xsl:with-param name="type" select="$type"/>
          </xsl:apply-templates>
        </xsl:for-each>
      </xsl:when>
      <xsl:otherwise>
        <xsl:for-each select="$refs[not(see)                                  and not(tertiary)][count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]">
          <xsl:apply-templates select="." mode="reference">
            <xsl:with-param name="position" select="position()"/>
            <xsl:with-param name="scope" select="$scope"/>
            <xsl:with-param name="role" select="$role"/>
            <xsl:with-param name="type" select="$type"/>
          </xsl:apply-templates>
        </xsl:for-each>
      </xsl:otherwise>
    </xsl:choose>

    <xsl:if test="$refs[not(tertiary)]/*[self::see]">
      <xsl:apply-templates select="$refs[generate-id() = generate-id(key('see', concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, &quot; &quot;, see))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]" mode="index-see">
        <xsl:with-param name="position" select="position()"/>
        <xsl:with-param name="scope" select="$scope"/>
        <xsl:with-param name="role" select="$role"/>
        <xsl:with-param name="type" select="$type"/>
        <xsl:sort select="translate(see, 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
      </xsl:apply-templates>
    </xsl:if>
  </dt>
  <xsl:choose>
    <xsl:when test="$refs/tertiary or $refs[not(tertiary)]/*[self::seealso]">
      <dd>
        <dl>
          <xsl:apply-templates select="$refs[generate-id() = generate-id(key('see-also', concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, &quot; &quot;, seealso))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]" mode="index-seealso">
            <xsl:with-param name="position" select="position()"/>
            <xsl:with-param name="scope" select="$scope"/>
            <xsl:with-param name="role" select="$role"/>
            <xsl:with-param name="type" select="$type"/>
            <xsl:sort select="translate(seealso, 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
          </xsl:apply-templates>
          <xsl:apply-templates select="$refs[tertiary and count(.|key('tertiary', concat($key, &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary))))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1]" mode="index-tertiary">
            <xsl:with-param name="position" select="position()"/>
            <xsl:with-param name="scope" select="$scope"/>
            <xsl:with-param name="role" select="$role"/>
            <xsl:with-param name="type" select="$type"/>
            <xsl:sort select="translate(normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
          </xsl:apply-templates>
        </dl>
      </dd>
    </xsl:when>
    <!-- HTML5 requires dd for each dt -->
    <xsl:when test="$div.element = 'section'">
      <dd/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="indexterm" mode="index-tertiary">
  <xsl:param name="scope" select="."/>
  <xsl:param name="role" select="''"/>
  <xsl:param name="type" select="''"/>

  <xsl:variable name="key" select="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)))"/>
  <xsl:variable name="refs" select="key('tertiary', $key)[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]"/>
  <dt>
    <xsl:for-each select="$refs/tertiary">
      <xsl:if test="@id or @xml:id">
        <xsl:choose>
          <xsl:when test="$generate.id.attributes = 0">
            <a id="{(@id|@xml:id)[1]}"/>
          </xsl:when>
          <xsl:otherwise>
            <span>
              <xsl:call-template name="id.attribute"/>
            </span>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
    </xsl:for-each>
    <xsl:value-of select="tertiary"/>
    <xsl:choose>
      <xsl:when test="$index.links.to.section = 1">
        <xsl:for-each select="$refs[@zone != '' or generate-id() = generate-id(key('tertiary-section', concat($key, &quot; &quot;, generate-id((ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()])))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]">
          <xsl:apply-templates select="." mode="reference">
            <xsl:with-param name="position" select="position()"/>
            <xsl:with-param name="scope" select="$scope"/>
            <xsl:with-param name="role" select="$role"/>
            <xsl:with-param name="type" select="$type"/>
          </xsl:apply-templates>
        </xsl:for-each>
      </xsl:when>
      <xsl:otherwise>
        <xsl:for-each select="$refs[not(see)][count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]">
          <xsl:apply-templates select="." mode="reference">
            <xsl:with-param name="position" select="position()"/>
            <xsl:with-param name="scope" select="$scope"/>
            <xsl:with-param name="role" select="$role"/>
            <xsl:with-param name="type" select="$type"/>
          </xsl:apply-templates>
        </xsl:for-each>
      </xsl:otherwise>
    </xsl:choose>

    <xsl:if test="$refs/see">
      <xsl:apply-templates select="$refs[generate-id() = generate-id(key('see', concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)), &quot; &quot;, see))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]" mode="index-see">
        <xsl:with-param name="position" select="position()"/>
        <xsl:with-param name="scope" select="$scope"/>
        <xsl:with-param name="role" select="$role"/>
        <xsl:with-param name="type" select="$type"/>
        <xsl:sort select="translate(see, 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
      </xsl:apply-templates>
    </xsl:if>
  </dt>
  <xsl:choose>
    <xsl:when test="$refs/seealso">
      <dd>
        <dl>
          <xsl:apply-templates select="$refs[generate-id() = generate-id(key('see-also', concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)), &quot; &quot;, seealso))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]" mode="index-seealso">
            <xsl:with-param name="position" select="position()"/>
            <xsl:with-param name="scope" select="$scope"/>
            <xsl:with-param name="role" select="$role"/>
            <xsl:with-param name="type" select="$type"/>
            <xsl:sort select="translate(seealso, 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
          </xsl:apply-templates>
        </dl>
      </dd>
    </xsl:when>
    <!-- HTML5 requires dd for each dt -->
    <xsl:when test="$div.element = 'section'">
      <dd/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="indexterm" mode="reference">
  <xsl:param name="scope" select="."/>
  <xsl:param name="role" select="''"/>
  <xsl:param name="type" select="''"/>
  <xsl:param name="position"/>
  <xsl:param name="separator" select="''"/>
  
  <xsl:variable name="term.separator">
    <xsl:call-template name="index.separator">
      <xsl:with-param name="key" select="'index.term.separator'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="number.separator">
    <xsl:call-template name="index.separator">
      <xsl:with-param name="key" select="'index.number.separator'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="range.separator">
    <xsl:call-template name="index.separator">
      <xsl:with-param name="key" select="'index.range.separator'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$separator != ''">
      <xsl:value-of select="$separator"/>
    </xsl:when>
    <xsl:when test="$position = 1">
      <xsl:value-of select="$term.separator"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$number.separator"/>
    </xsl:otherwise>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="@zone and string(@zone)">
      <xsl:call-template name="reference">
        <xsl:with-param name="zones" select="normalize-space(@zone)"/>
        <xsl:with-param name="position" select="position()"/>
        <xsl:with-param name="scope" select="$scope"/>
        <xsl:with-param name="role" select="$role"/>
        <xsl:with-param name="type" select="$type"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <a>
        <xsl:apply-templates select="." mode="class.attribute"/>
        <xsl:variable name="title">
          <xsl:choose>
            <xsl:when test="$index.prefer.titleabbrev != 0">
              <xsl:apply-templates select="(ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()]" mode="titleabbrev.markup"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:apply-templates select="(ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()]" mode="title.markup"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>

        <xsl:attribute name="href">
          <xsl:choose>
            <xsl:when test="$index.links.to.section = 1">
              <xsl:call-template name="href.target">
                <xsl:with-param name="object" select="(ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()]"/>
                <xsl:with-param name="context" select="(//index[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))] | //setindex[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))])[1]"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:call-template name="href.target">
                <xsl:with-param name="object" select="."/>
                <xsl:with-param name="context" select="(//index[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))] | //setindex[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))])[1]"/>
              </xsl:call-template>
            </xsl:otherwise>
          </xsl:choose>

        </xsl:attribute>

        <xsl:value-of select="$title"/> <!-- text only -->
      </a>

      <xsl:variable name="id" select="(@id|@xml:id)[1]"/>
      <xsl:if test="key('endofrange', $id)[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]">
        <xsl:apply-templates select="key('endofrange', $id)[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][last()]" mode="reference">
          <xsl:with-param name="position" select="position()"/>
          <xsl:with-param name="scope" select="$scope"/>
          <xsl:with-param name="role" select="$role"/>
          <xsl:with-param name="type" select="$type"/>
          <xsl:with-param name="separator" select="$range.separator"/>
        </xsl:apply-templates>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="reference">
  <xsl:param name="scope" select="."/>
  <xsl:param name="role" select="''"/>
  <xsl:param name="type" select="''"/>
  <xsl:param name="zones"/>

  <xsl:choose>
    <xsl:when test="contains($zones, ' ')">
      <xsl:variable name="zone" select="substring-before($zones, ' ')"/>
      <xsl:variable name="target" select="key('sections', $zone)"/>

      <a>
        <xsl:apply-templates select="." mode="class.attribute"/>
        <xsl:call-template name="id.attribute"/>
        <xsl:attribute name="href">
          <xsl:call-template name="href.target">
            <xsl:with-param name="object" select="$target[1]"/>
            <xsl:with-param name="context" select="//index[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]"/>
          </xsl:call-template>
        </xsl:attribute>
        <xsl:apply-templates select="$target[1]" mode="index-title-content"/>
      </a>
      <xsl:text>, </xsl:text>
      <xsl:call-template name="reference">
        <xsl:with-param name="zones" select="substring-after($zones, ' ')"/>
        <xsl:with-param name="position" select="position()"/>
        <xsl:with-param name="scope" select="$scope"/>
        <xsl:with-param name="role" select="$role"/>
        <xsl:with-param name="type" select="$type"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="zone" select="$zones"/>
      <xsl:variable name="target" select="key('sections', $zone)"/>

      <a>
        <xsl:apply-templates select="." mode="class.attribute"/>
        <xsl:call-template name="id.attribute"/>
        <xsl:attribute name="href">
          <xsl:call-template name="href.target">
            <xsl:with-param name="object" select="$target[1]"/>
            <xsl:with-param name="context" select="//index[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]"/>
          </xsl:call-template>
        </xsl:attribute>
        <xsl:apply-templates select="$target[1]" mode="index-title-content"/>
      </a>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="indexterm" mode="index-see">
  <xsl:param name="scope" select="."/>
  <xsl:param name="role" select="''"/>
  <xsl:param name="type" select="''"/>

  <xsl:text> (</xsl:text>
  <xsl:call-template name="gentext">
    <xsl:with-param name="key" select="'see'"/>
  </xsl:call-template>
  <xsl:text> </xsl:text>
  <xsl:value-of select="see"/>
  <xsl:text>)</xsl:text>
</xsl:template><xsl:template match="indexterm" mode="index-seealso">
  <xsl:param name="scope" select="."/>
  <xsl:param name="role" select="''"/>
  <xsl:param name="type" select="''"/>

  <xsl:for-each select="seealso">
    <xsl:sort select="translate(., 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
    <dt>
    <xsl:text>(</xsl:text>
    <xsl:call-template name="gentext">
      <xsl:with-param name="key" select="'seealso'"/>
    </xsl:call-template>
    <xsl:text> </xsl:text>
    <xsl:value-of select="."/>
    <xsl:text>)</xsl:text>
    </dt>
    <xsl:if test="$div.element = 'section'">
      <dd/>
    </xsl:if>
  </xsl:for-each>
</xsl:template><xsl:template match="*" mode="index-title-content">
  <xsl:variable name="title">
    <xsl:apply-templates select="(ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()]" mode="title.markup"/>
  </xsl:variable>

  <xsl:value-of select="$title"/>
</xsl:template><xsl:template name="index.separator">
  <xsl:param name="key" select="''"/>
  <xsl:param name="lang">
    <xsl:call-template name="l10n.language"/>
  </xsl:param>

  <xsl:choose>
    <xsl:when test="$key = 'index.term.separator'">
      <xsl:choose>
        <!-- Use the override if not blank -->
        <xsl:when test="$index.term.separator != ''">
          <xsl:copy-of select="$index.term.separator"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="lang" select="$lang"/>
            <xsl:with-param name="context">index</xsl:with-param>
            <xsl:with-param name="name">term-separator</xsl:with-param>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:when test="$key = 'index.number.separator'">
      <xsl:choose>
        <!-- Use the override if not blank -->
        <xsl:when test="$index.number.separator != ''">
          <xsl:copy-of select="$index.number.separator"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="lang" select="$lang"/>
            <xsl:with-param name="context">index</xsl:with-param>
            <xsl:with-param name="name">number-separator</xsl:with-param>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:when test="$key = 'index.range.separator'">
      <xsl:choose>
        <!-- Use the override if not blank -->
        <xsl:when test="$index.range.separator != ''">
          <xsl:copy-of select="$index.range.separator"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="lang" select="$lang"/>
            <xsl:with-param name="context">index</xsl:with-param>
            <xsl:with-param name="name">range-separator</xsl:with-param>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
  </xsl:choose>
</xsl:template>
<xsl:template match="itemizedlist/title">
  <!-- nop -->
</xsl:template><xsl:template match="itemizedlist/listitem">
  <xsl:variable name="mark" select="../@mark"/>
  <xsl:variable name="override" select="@override"/>

  <xsl:variable name="usemark">
    <xsl:choose>
      <xsl:when test="$override != ''">
        <xsl:value-of select="$override"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$mark"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="cssmark">
    <xsl:choose>
      <xsl:when test="$usemark = 'opencircle'">circle</xsl:when>
      <xsl:when test="$usemark = 'bullet'">disc</xsl:when>
      <xsl:when test="$usemark = 'box'">square</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$usemark"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <li>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:if test="$css.decoration = '1' and $cssmark != ''">
      <xsl:attribute name="style">
        <xsl:text>list-style-type: </xsl:text>
        <xsl:value-of select="$cssmark"/>
      </xsl:attribute>
    </xsl:if>

    <!-- we can't just drop the anchor in since some browsers (Opera)
         get confused about line breaks if we do. So if the first child
         is a para, assume the para will put in the anchor. Otherwise,
         put the anchor in anyway. -->
    <xsl:if test="local-name(child::*[1]) != 'para'">
      <xsl:call-template name="anchor"/>
    </xsl:if>

    <xsl:choose>
      <xsl:when test="$show.revisionflag != 0 and @revisionflag">
        <div class="{@revisionflag}">
          <xsl:apply-templates/>
        </div>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates/>
      </xsl:otherwise>
    </xsl:choose>
  </li>
</xsl:template>
<xsl:template match="orderedlist/title">
  <!-- nop -->
</xsl:template><xsl:template match="orderedlist/listitem">
  <li>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:if test="@override">
      <xsl:attribute name="value">
        <xsl:value-of select="@override"/>
      </xsl:attribute>
    </xsl:if>

    <!-- we can't just drop the anchor in since some browsers (Opera)
         get confused about line breaks if we do. So if the first child
         is a para, assume the para will put in the anchor. Otherwise,
         put the anchor in anyway. -->
    <xsl:if test="local-name(child::*[1]) != 'para'">
      <xsl:call-template name="anchor"/>
    </xsl:if>

    <xsl:choose>
      <xsl:when test="$show.revisionflag != 0 and @revisionflag">
        <div class="{@revisionflag}">
          <xsl:apply-templates/>
        </div>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates/>
      </xsl:otherwise>
    </xsl:choose>
  </li>
</xsl:template><xsl:template match="orderedlist/listitem" mode="orderedlist-table">
  <tr>
    <td>
      <xsl:apply-templates select="." mode="item-number"/>
    </td>
    <td>
      <xsl:if test="local-name(child::*[1]) != 'para'">
        <xsl:call-template name="id.attribute"/>
        <xsl:call-template name="anchor"/>
      </xsl:if>

      <xsl:choose>
        <xsl:when test="$show.revisionflag != 0 and @revisionflag">
          <div class="{@revisionflag}">
            <xsl:apply-templates/>
          </div>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates/>
        </xsl:otherwise>
      </xsl:choose>
    </td>
  </tr>
</xsl:template><xsl:template match="variablelist">
  <xsl:variable name="pi-presentation">
    <xsl:call-template name="pi.dbhtml_list-presentation"/>
  </xsl:variable>
  <!-- Handle spacing="compact" as multiple class attribute instead
       of the deprecated HTML compact attribute -->
  <xsl:variable name="default.class">
    <xsl:value-of select="local-name()"/>
    <xsl:if test="@spacing = 'compact'">
      <xsl:text> compact</xsl:text>
    </xsl:if>
  </xsl:variable>
  

  <xsl:variable name="presentation">
    <xsl:choose>
      <xsl:when test="$pi-presentation != ''">
        <xsl:value-of select="$pi-presentation"/>
      </xsl:when>
      <xsl:when test="$variablelist.as.table != 0">
        <xsl:value-of select="'table'"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="'list'"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="list-width">
    <xsl:call-template name="pi.dbhtml_list-width"/>
  </xsl:variable>

  <xsl:variable name="term-width">
    <xsl:call-template name="pi.dbhtml_term-width"/>
  </xsl:variable>

  <xsl:variable name="table-summary">
    <xsl:call-template name="pi.dbhtml_table-summary"/>
  </xsl:variable>

  <div>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:if test="title|info/title">
      <xsl:call-template name="formal.object.heading"/>
    </xsl:if>

    <xsl:choose>
      <xsl:when test="$presentation = 'table'">
        <!-- Preserve order of PIs and comments -->
        <xsl:apply-templates select="*[not(self::varlistentry                     or self::title                     or self::titleabbrev)]                   |comment()[not(preceding-sibling::varlistentry)]                   |processing-instruction()[not(preceding-sibling::varlistentry)]"/>
        <table border="{$table.border.off}">
          <xsl:call-template name="generate.class.attribute">
            <xsl:with-param name="class" select="$default.class"/>
          </xsl:call-template>
          <xsl:if test="$list-width != ''">
            <xsl:attribute name="width">
              <xsl:value-of select="$list-width"/>
            </xsl:attribute>
          </xsl:if>
          <xsl:if test="$table-summary != ''">
            <xsl:attribute name="summary">
              <xsl:value-of select="$table-summary"/>
            </xsl:attribute>
          </xsl:if>
          <colgroup>
            <col align="{$direction.align.start}" valign="top">
              <xsl:if test="$term-width != ''">
                <xsl:attribute name="width">
                  <xsl:value-of select="$term-width"/>
                </xsl:attribute>
              </xsl:if>
            </col>
            <col/>
          </colgroup>
          <tbody>
            <xsl:apply-templates mode="varlist-table" select="varlistentry                       |comment()[preceding-sibling::varlistentry]                       |processing-instruction()[preceding-sibling::varlistentry]"/>
          </tbody>
        </table>
      </xsl:when>
      <xsl:otherwise>
        <!-- Preserve order of PIs and comments -->
        <xsl:apply-templates select="*[not(self::varlistentry                     or self::title                     or self::titleabbrev)]                   |comment()[not(preceding-sibling::varlistentry)]                   |processing-instruction()[not(preceding-sibling::varlistentry)]"/>
        <dl>
          <xsl:call-template name="generate.class.attribute">
            <xsl:with-param name="class" select="$default.class"/>
          </xsl:call-template>
          <xsl:apply-templates select="varlistentry                       |comment()[preceding-sibling::varlistentry]                       |processing-instruction()[preceding-sibling::varlistentry]"/>
        </dl>
      </xsl:otherwise>
    </xsl:choose>
  </div>
</xsl:template><xsl:template match="variablelist/title">
  <!-- nop -->
</xsl:template><xsl:template match="itemizedlist/titleabbrev|orderedlist/titleabbrev">
  <!--nop-->
</xsl:template><xsl:template match="variablelist/titleabbrev">
  <!--nop-->
</xsl:template><xsl:template match="listitem" mode="xref">
  <xsl:number format="1"/>
</xsl:template><xsl:template match="listitem/simpara" priority="2">
  <!-- If a listitem contains only a single simpara, don't output
       the <p> wrapper; this has the effect of creating an li
       with simple text content. -->
  <xsl:choose>
    <xsl:when test="not(preceding-sibling::*)                     and not (following-sibling::*)">
      <xsl:call-template name="anchor"/>
      <xsl:apply-templates/>
    </xsl:when>
    <xsl:otherwise>
      <p>
        <xsl:call-template name="id.attribute"/>
        <xsl:choose>
          <xsl:when test="@role and $para.propagates.style != 0">
            <xsl:call-template name="common.html.attributes">
              <xsl:with-param name="class" select="@role"/>
            </xsl:call-template>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="common.html.attributes"/>
          </xsl:otherwise>
        </xsl:choose>

        <xsl:call-template name="anchor"/>
        <xsl:apply-templates/>
      </p>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="varlistentry">
  <dt>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:apply-templates select="term"/>
  </dt>
  <dd>
    <xsl:apply-templates select="listitem"/>
  </dd>
</xsl:template><xsl:template match="varlistentry" mode="varlist-table">
  <xsl:variable name="presentation">
    <xsl:call-template name="pi.dbhtml_term-presentation">
      <xsl:with-param name="node" select=".."/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="separator">
    <xsl:call-template name="pi.dbhtml_term-separator">
      <xsl:with-param name="node" select=".."/>
    </xsl:call-template>
  </xsl:variable>
  <tr>
    <xsl:call-template name="tr.attributes">
      <xsl:with-param name="rownum">
        <xsl:number from="variablelist" count="varlistentry"/>
      </xsl:with-param>
    </xsl:call-template>

    <td>
      <xsl:call-template name="id.attribute"/>
      <p>
      <xsl:call-template name="anchor"/>
      <xsl:choose>
        <xsl:when test="$presentation = 'bold'">
          <strong>
            <xsl:apply-templates select="term"/>
            <xsl:value-of select="$separator"/>
          </strong>
        </xsl:when>
        <xsl:when test="$presentation = 'italic'">
          <em>
            <xsl:apply-templates select="term"/>
            <xsl:value-of select="$separator"/>
          </em>
        </xsl:when>
        <xsl:when test="$presentation = 'bold-italic'">
          <strong>
            <em>
              <xsl:apply-templates select="term"/>
              <xsl:value-of select="$separator"/>
            </em>
          </strong>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="term"/>
          <xsl:value-of select="$separator"/>
        </xsl:otherwise>
      </xsl:choose>
      </p>
    </td>
    <td>
      <xsl:apply-templates select="listitem"/>
    </td>
  </tr>
</xsl:template><xsl:template match="varlistentry/term">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:apply-templates/>
      </xsl:with-param>
    </xsl:call-template>
    <xsl:choose>
      <xsl:when test="position() = last()"/> <!-- do nothing -->
      <xsl:otherwise>
        <!-- * if we have multiple terms in the same varlistentry, generate -->
        <!-- * a separator (", " by default) and/or an additional line -->
        <!-- * break after each one except the last -->
        <xsl:value-of select="$variablelist.term.separator"/>
        <xsl:if test="not($variablelist.term.break.after = '0')">
          <br/>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>
  </span>
</xsl:template><xsl:template match="varlistentry/listitem">
  <!-- we can't just drop the anchor in since some browsers (Opera)
       get confused about line breaks if we do. So if the first child
       is a para, assume the para will put in the anchor. Otherwise,
       put the anchor in anyway. -->
  <xsl:if test="local-name(child::*[1]) != 'para'">
    <xsl:call-template name="anchor"/>
  </xsl:if>

  <xsl:choose>
    <xsl:when test="$show.revisionflag != 0 and @revisionflag">
      <div class="{@revisionflag}">
        <xsl:apply-templates/>
      </div>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="simplelist">
  <!-- with no type specified, the default is 'vert' -->
  <xsl:call-template name="anchor"/>
  <table border="{$table.border.off}">
    <xsl:if test="$div.element != 'section'">
      <xsl:attribute name="summary">Simple list</xsl:attribute>
    </xsl:if>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="simplelist.vert">
      <xsl:with-param name="cols">
        <xsl:choose>
          <xsl:when test="@columns">
            <xsl:value-of select="@columns"/>
          </xsl:when>
          <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
      </xsl:with-param>
    </xsl:call-template>
  </table>
</xsl:template><xsl:template match="simplelist[@type='inline']">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <!-- if dbchoice PI exists, use that to determine the choice separator -->
    <!-- (that is, equivalent of "and" or "or" in current locale), or literal -->
    <!-- value of "choice" otherwise -->
    <xsl:variable name="localized-choice-separator">
      <xsl:choose>
        <xsl:when test="processing-instruction('dbchoice')">
          <xsl:call-template name="select.choice.separator"/>
        </xsl:when>
        <xsl:otherwise>
          <!-- empty -->
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
  
    <xsl:for-each select="member">
      <xsl:call-template name="simple.xlink">
        <xsl:with-param name="content">
          <xsl:apply-templates/>
        </xsl:with-param>
      </xsl:call-template>
      <xsl:choose>
        <xsl:when test="position() = last()"/> <!-- do nothing -->
        <xsl:otherwise>
          <xsl:text>, </xsl:text>
          <xsl:if test="position() = last() - 1">
            <xsl:if test="$localized-choice-separator != ''">
              <xsl:value-of select="$localized-choice-separator"/>
              <xsl:text> </xsl:text>
            </xsl:if>
          </xsl:if>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
  </span>
</xsl:template><xsl:template match="simplelist[@type='horiz']">
  <xsl:call-template name="anchor"/>
  <table border="{$table.border.off}">
    <xsl:if test="$div.element != 'section'">
      <xsl:attribute name="summary">Simple list</xsl:attribute>
    </xsl:if>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="simplelist.horiz">
      <xsl:with-param name="cols">
        <xsl:choose>
          <xsl:when test="@columns">
            <xsl:value-of select="@columns"/>
          </xsl:when>
          <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
      </xsl:with-param>
    </xsl:call-template>
  </table>
</xsl:template><xsl:template match="simplelist[@type='vert']">
  <xsl:call-template name="anchor"/>
  <table border="{$table.border.off}">
    <xsl:if test="$div.element != 'section'">
      <xsl:attribute name="summary">Simple list</xsl:attribute>
    </xsl:if>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="simplelist.vert">
      <xsl:with-param name="cols">
        <xsl:choose>
          <xsl:when test="@columns">
            <xsl:value-of select="@columns"/>
          </xsl:when>
          <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
      </xsl:with-param>
    </xsl:call-template>
  </table>
</xsl:template><xsl:template name="simplelist.horiz">
  <xsl:param name="cols">1</xsl:param>
  <xsl:param name="cell">1</xsl:param>
  <xsl:param name="members" select="./member"/>

  <xsl:if test="$cell &lt;= count($members)">
    <tr>
      <xsl:call-template name="tr.attributes">
        <xsl:with-param name="row" select="$members[1]"/>
        <xsl:with-param name="rownum" select="(($cell - 1) div $cols) + 1"/>
      </xsl:call-template>

      <xsl:call-template name="simplelist.horiz.row">
        <xsl:with-param name="cols" select="$cols"/>
        <xsl:with-param name="cell" select="$cell"/>
        <xsl:with-param name="members" select="$members"/>
      </xsl:call-template>
   </tr>
    <xsl:call-template name="simplelist.horiz">
      <xsl:with-param name="cols" select="$cols"/>
      <xsl:with-param name="cell" select="$cell + $cols"/>
      <xsl:with-param name="members" select="$members"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template name="simplelist.horiz.row">
  <xsl:param name="cols">1</xsl:param>
  <xsl:param name="cell">1</xsl:param>
  <xsl:param name="members" select="./member"/>
  <xsl:param name="curcol">1</xsl:param>

  <xsl:if test="$curcol &lt;= $cols">
    <td>
      <xsl:choose>
        <xsl:when test="$members[position()=$cell]">
          <xsl:apply-templates select="$members[position()=$cell]"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>Â </xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </td>
    <xsl:call-template name="simplelist.horiz.row">
      <xsl:with-param name="cols" select="$cols"/>
      <xsl:with-param name="cell" select="$cell+1"/>
      <xsl:with-param name="members" select="$members"/>
      <xsl:with-param name="curcol" select="$curcol+1"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template name="simplelist.vert">
  <xsl:param name="cols">1</xsl:param>
  <xsl:param name="cell">1</xsl:param>
  <xsl:param name="members" select="./member"/>
  <xsl:param name="rows" select="floor((count($members)+$cols - 1) div $cols)"/>

  <xsl:if test="$cell &lt;= $rows">
    <tr>
      <xsl:call-template name="tr.attributes">
        <xsl:with-param name="row" select="$members[1]"/>
        <xsl:with-param name="rownum" select="$cell"/>
      </xsl:call-template>

      <xsl:call-template name="simplelist.vert.row">
        <xsl:with-param name="cols" select="$cols"/>
        <xsl:with-param name="rows" select="$rows"/>
        <xsl:with-param name="cell" select="$cell"/>
        <xsl:with-param name="members" select="$members"/>
      </xsl:call-template>
    </tr>
    <xsl:call-template name="simplelist.vert">
      <xsl:with-param name="cols" select="$cols"/>
      <xsl:with-param name="cell" select="$cell+1"/>
      <xsl:with-param name="members" select="$members"/>
      <xsl:with-param name="rows" select="$rows"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template name="simplelist.vert.row">
  <xsl:param name="cols">1</xsl:param>
  <xsl:param name="rows">1</xsl:param>
  <xsl:param name="cell">1</xsl:param>
  <xsl:param name="members" select="./member"/>
  <xsl:param name="curcol">1</xsl:param>

  <xsl:if test="$curcol &lt;= $cols">
    <td>
      <xsl:choose>
        <xsl:when test="$members[position()=$cell]">
          <xsl:apply-templates select="$members[position()=$cell]"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>Â </xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </td>
    <xsl:call-template name="simplelist.vert.row">
      <xsl:with-param name="cols" select="$cols"/>
      <xsl:with-param name="rows" select="$rows"/>
      <xsl:with-param name="cell" select="$cell+$rows"/>
      <xsl:with-param name="members" select="$members"/>
      <xsl:with-param name="curcol" select="$curcol+1"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template match="member">
  <xsl:call-template name="anchor"/>
  <xsl:call-template name="simple.xlink">
    <xsl:with-param name="content">
      <xsl:apply-templates/>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template>
<xsl:template match="procedure/title">
  <!-- nop -->
</xsl:template>
<xsl:template match="step">
  <li>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:apply-templates/>
  </li>
</xsl:template><xsl:template match="stepalternatives">
  <xsl:call-template name="anchor"/>
  <ul>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates/>
  </ul>
</xsl:template><xsl:template match="step/title">
  <p>
    <xsl:call-template name="common.html.attributes"/>
    <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
      <xsl:apply-templates/>
    </strong>
  </p>
</xsl:template><xsl:template match="segmentedlist">
  <xsl:variable name="presentation">
    <xsl:call-template name="pi.dbhtml_list-presentation"/>
  </xsl:variable>

  <div>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>

    <xsl:choose>
      <xsl:when test="$presentation = 'table'">
        <xsl:apply-templates select="." mode="seglist-table"/>
      </xsl:when>
      <xsl:when test="$presentation = 'list'">
        <xsl:apply-templates/>
      </xsl:when>
      <xsl:when test="$segmentedlist.as.table != 0">
        <xsl:apply-templates select="." mode="seglist-table"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates/>
      </xsl:otherwise>
    </xsl:choose>
  </div>
</xsl:template><xsl:template match="segmentedlist/title">
  <div>
    <xsl:call-template name="common.html.attributes"/>
    <strong>
      <span>
        <xsl:call-template name="generate.class.attribute"/>
        <xsl:apply-templates/>
      </span>
    </strong>
  </div>
</xsl:template><xsl:template match="segtitle">
</xsl:template><xsl:template match="segtitle" mode="segtitle-in-seg">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="seglistitem">
  <div>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="seg">
  <xsl:variable name="segnum" select="count(preceding-sibling::seg)+1"/>
  <xsl:variable name="seglist" select="ancestor::segmentedlist"/>
  <xsl:variable name="segtitles" select="$seglist/segtitle"/>

  <!--
     Note: segtitle is only going to be the right thing in a well formed
     SegmentedList.  If there are too many Segs or too few SegTitles,
     you'll get something odd...maybe an error
  -->

  <div>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <strong>
      <span class="segtitle">
        <xsl:apply-templates select="$segtitles[$segnum=position()]" mode="segtitle-in-seg"/>
        <xsl:text>: </xsl:text>
      </span>
    </strong>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="segmentedlist" mode="seglist-table">
  <xsl:variable name="table-summary">
    <xsl:call-template name="pi.dbhtml_table-summary"/>
  </xsl:variable>

  <xsl:variable name="list-width">
    <xsl:call-template name="pi.dbhtml_list-width"/>
  </xsl:variable>

  <xsl:apply-templates select="title"/>

  <table border="{$table.border.off}">
    <xsl:if test="$list-width != ''">
      <xsl:attribute name="width">
        <xsl:value-of select="$list-width"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="$table-summary != '' and $div.element != 'section'">
      <xsl:attribute name="summary">
        <xsl:value-of select="$table-summary"/>
      </xsl:attribute>
    </xsl:if>
    <thead>
      <tr class="segtitle">
        <xsl:call-template name="tr.attributes">
          <xsl:with-param name="row" select="segtitle[1]"/>
          <xsl:with-param name="rownum" select="1"/>
        </xsl:call-template>
        <xsl:apply-templates select="segtitle" mode="seglist-table"/>
      </tr>
    </thead>
    <tbody>
      <xsl:apply-templates select="seglistitem" mode="seglist-table"/>
    </tbody>
  </table>
</xsl:template><xsl:template match="segtitle" mode="seglist-table">
  <th><xsl:apply-templates/></th>
</xsl:template><xsl:template match="seglistitem" mode="seglist-table">
  <xsl:variable name="seglinum">
    <xsl:number from="segmentedlist" count="seglistitem"/>
  </xsl:variable>

  <tr>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="tr.attributes">
      <xsl:with-param name="rownum" select="$seglinum + 1"/>
    </xsl:call-template>
    <xsl:apply-templates mode="seglist-table"/>
  </tr>
</xsl:template><xsl:template match="seg" mode="seglist-table">
  <td>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates/>
  </td>
</xsl:template><xsl:template match="seg[1]" mode="seglist-table">
  <td>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor">
      <xsl:with-param name="node" select="ancestor::seglistitem"/>
    </xsl:call-template>
    <xsl:apply-templates/>
  </td>
</xsl:template><xsl:template match="calloutlist">
  <div>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:if test="title|info/title">
      <xsl:call-template name="formal.object.heading"/>
    </xsl:if>

    <!-- Preserve order of PIs and comments -->
    <xsl:apply-templates select="*[not(self::callout or self::title or self::titleabbrev)]                    |comment()[not(preceding-sibling::callout)]                    |processing-instruction()[not(preceding-sibling::callout)]"/>

    <xsl:choose>
      <xsl:when test="$callout.list.table != 0">
        <table border="{$table.border.off}">
          <xsl:if test="$div.element != 'section'">
            <xsl:attribute name="summary">Callout list</xsl:attribute>
          </xsl:if>
          <xsl:apply-templates select="callout                                 |comment()[preceding-sibling::callout]                                 |processing-instruction()[preceding-sibling::callout]"/>
        </table>
      </xsl:when>
      <xsl:otherwise>
        <dl>
          <xsl:apply-templates select="." mode="class.attribute"/>
          <xsl:apply-templates select="callout                                 |comment()[preceding-sibling::callout]                                 |processing-instruction()[preceding-sibling::callout]"/>
        </dl>
      </xsl:otherwise>
    </xsl:choose>
  </div>
</xsl:template><xsl:template match="calloutlist/title">
</xsl:template><xsl:template match="callout">
  <xsl:choose>
    <xsl:when test="$callout.list.table != 0">
      <tr>
        <xsl:call-template name="tr.attributes">
          <xsl:with-param name="rownum">
            <xsl:number from="calloutlist" count="callout"/>
          </xsl:with-param>
        </xsl:call-template>

        <td width="5%" valign="top" align="{$direction.align.start}">
          <xsl:call-template name="id.attribute"/>
          <p>
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="callout.arearefs">
              <xsl:with-param name="arearefs" select="@arearefs"/>
            </xsl:call-template>
          </p>
        </td>
        <td valign="top" align="{$direction.align.start}">
          <xsl:apply-templates/>
        </td>
      </tr>
    </xsl:when>
    <xsl:otherwise>
      <dt>
        <xsl:call-template name="id.attribute"/>
        <xsl:call-template name="anchor"/>
        <xsl:call-template name="callout.arearefs">
          <xsl:with-param name="arearefs" select="@arearefs"/>
        </xsl:call-template>
      </dt>
      <dd><xsl:apply-templates/></dd>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="callout/simpara" priority="2">
  <!-- If a callout contains only a single simpara, don't output
       the <p> wrapper; this has the effect of creating an li
       with simple text content. -->
  <xsl:choose>
    <xsl:when test="not(preceding-sibling::*)                     and not (following-sibling::*)">
      <xsl:call-template name="anchor"/>
      <xsl:apply-templates/>
    </xsl:when>
    <xsl:otherwise>
      <p>
        <xsl:call-template name="id.attribute"/>
        <xsl:if test="@role and $para.propagates.style != 0">
          <xsl:choose>
            <xsl:when test="@role and $para.propagates.style != 0">
              <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="class" select="@role"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:call-template name="common.html.attributes"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:if>

        <xsl:call-template name="anchor"/>
        <xsl:apply-templates/>
      </p>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="callout.arearefs">
  <xsl:param name="arearefs"/>
  <xsl:if test="$arearefs!=''">
    <xsl:choose>
      <xsl:when test="substring-before($arearefs,' ')=''">
        <xsl:call-template name="callout.arearef">
          <xsl:with-param name="arearef" select="$arearefs"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="callout.arearef">
          <xsl:with-param name="arearef" select="substring-before($arearefs,' ')"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:call-template name="callout.arearefs">
      <xsl:with-param name="arearefs" select="substring-after($arearefs,' ')"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template name="callout.arearef">
  <xsl:param name="arearef"/>
  <xsl:variable name="targets" select="key('id',$arearef)"/>
  <xsl:variable name="target" select="$targets[1]"/>

  <xsl:call-template name="check.id.unique">
    <xsl:with-param name="linkend" select="$arearef"/>
  </xsl:call-template>

  <xsl:choose>
    <xsl:when test="count($target)=0">
      <xsl:text>???</xsl:text>
    </xsl:when>
    <xsl:when test="local-name($target)='co'">
      <a>
        <xsl:attribute name="href">
          <xsl:text>#</xsl:text>
          <xsl:value-of select="$arearef"/>
        </xsl:attribute>
        <xsl:apply-templates select="$target" mode="callout-bug"/>
      </a>
      <xsl:text> </xsl:text>
    </xsl:when>
    <xsl:when test="local-name($target)='areaset'">
      <xsl:call-template name="callout-bug">
        <xsl:with-param name="conum">
          <xsl:apply-templates select="$target" mode="conumber"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="local-name($target)='area'">
      <xsl:choose>
        <xsl:when test="$target/parent::areaset">
          <xsl:call-template name="callout-bug">
            <xsl:with-param name="conum">
              <xsl:apply-templates select="$target/parent::areaset" mode="conumber"/>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="callout-bug">
            <xsl:with-param name="conum">
              <xsl:apply-templates select="$target" mode="conumber"/>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>???</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="orderedlist-starting-number">
  <xsl:param name="list" select="."/>
  <xsl:variable name="pi-start">
    <xsl:call-template name="pi.dbhtml_start">
      <xsl:with-param name="node" select="$list"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:call-template name="output-orderedlist-starting-number">
    <xsl:with-param name="list" select="$list"/>
    <xsl:with-param name="pi-start" select="$pi-start"/>
  </xsl:call-template>
</xsl:template>
<lxslt:component xmlns:lxslt="http://xml.apache.org/xslt" prefix="xverb" functions="insertCallouts"/><xsl:template match="areaspec|areaset|area">
</xsl:template><xsl:template match="areaset" mode="conumber">
  <xsl:number count="area|areaset" format="1"/>
</xsl:template><xsl:template match="area" mode="conumber">
  <xsl:number count="area|areaset" format="1"/>
</xsl:template><xsl:template match="coref">
  <!-- tricky; this relies on the fact that we can process the "co" that's -->
  <!-- "over there" as if it were "right here" -->

  <xsl:variable name="co" select="key('id', @linkend)"/>
  <xsl:choose>
    <xsl:when test="not($co)">
      <xsl:message>
        <xsl:text>Error: coref link is broken: </xsl:text>
        <xsl:value-of select="@linkend"/>
      </xsl:message>
    </xsl:when>
    <xsl:when test="local-name($co) != 'co'">
      <xsl:message>
        <xsl:text>Error: coref doesn't point to a co: </xsl:text>
        <xsl:value-of select="@linkend"/>
      </xsl:message>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="$co"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<lxslt:component xmlns:lxslt="http://xml.apache.org/xslt" prefix="xverb" functions="numberLines"/><xsl:template match="programlisting|screen|synopsis">
  <xsl:param name="suppress-numbers" select="'0'"/>

  <xsl:call-template name="anchor"/>

  <xsl:variable name="div.element">pre</xsl:variable>

  <xsl:if test="$shade.verbatim != 0">
    <xsl:message>
      <xsl:text>The shade.verbatim parameter is deprecated. </xsl:text>
      <xsl:text>Use CSS instead,</xsl:text>
    </xsl:message>
    <xsl:message>
      <xsl:text>for example: pre.</xsl:text>
      <xsl:value-of select="local-name(.)"/>
      <xsl:text> { background-color: #E0E0E0; }</xsl:text>
    </xsl:message>
  </xsl:if>

  <xsl:choose>
    <xsl:when test="$suppress-numbers = '0'                     and @linenumbering = 'numbered'                     and $use.extensions != '0'                     and $linenumbering.extension != '0'">
      <xsl:variable name="rtf">
        <xsl:choose>
          <xsl:when test="$highlight.source != 0">
            <xsl:call-template name="apply-highlighting"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:apply-templates/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:call-template name="id.attribute"/>
        <xsl:if test="@width != ''">
          <xsl:attribute name="width">
            <xsl:value-of select="@width"/>
          </xsl:attribute>
        </xsl:if>
        <xsl:call-template name="number.rtf.lines">
          <xsl:with-param name="rtf" select="$rtf"/>
        </xsl:call-template>
      </xsl:element>
    </xsl:when>
    <xsl:otherwise>
      <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:call-template name="id.attribute"/>
        <xsl:if test="@width != ''">
          <xsl:attribute name="width">
            <xsl:value-of select="@width"/>
          </xsl:attribute>
        </xsl:if>
        <xsl:choose>
          <xsl:when test="$highlight.source != 0">
            <xsl:call-template name="apply-highlighting"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:apply-templates/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:element>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="literallayout">
  <xsl:param name="suppress-numbers" select="'0'"/>

  <xsl:variable name="rtf">
    <xsl:apply-templates/>
  </xsl:variable>

  <xsl:if test="$shade.verbatim != 0 and @class='monospaced'">
    <xsl:message>
      <xsl:text>The shade.verbatim parameter is deprecated. </xsl:text>
      <xsl:text>Use CSS instead,</xsl:text>
    </xsl:message>
    <xsl:message>
      <xsl:text>for example: pre.</xsl:text>
      <xsl:value-of select="local-name(.)"/>
      <xsl:text> { background-color: #E0E0E0; }</xsl:text>
    </xsl:message>
  </xsl:if>

  <xsl:choose>
    <xsl:when test="$suppress-numbers = '0'                     and @linenumbering = 'numbered'                     and $use.extensions != '0'                     and $linenumbering.extension != '0'">
      <xsl:choose>
        <xsl:when test="@class='monospaced'">
          <pre>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="number.rtf.lines">
              <xsl:with-param name="rtf" select="$rtf"/>
            </xsl:call-template>
          </pre>
        </xsl:when>
        <xsl:otherwise>
          <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <p>
              <xsl:call-template name="number.rtf.lines">
                <xsl:with-param name="rtf" select="$rtf"/>
              </xsl:call-template>
            </p>
          </div>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="@class='monospaced'">
          <pre>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:copy-of select="$rtf"/>
          </pre>
        </xsl:when>
        <xsl:otherwise>
          <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <p>
              <xsl:call-template name="make-verbatim">
                <xsl:with-param name="rtf" select="$rtf"/>
              </xsl:call-template>
            </p>
          </div>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="address">
  <xsl:param name="suppress-numbers" select="'0'"/>

  <xsl:variable name="rtf">
    <xsl:apply-templates/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$suppress-numbers = '0'                     and @linenumbering = 'numbered'                     and $use.extensions != '0'                     and $linenumbering.extension != '0'">
      <div>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:call-template name="id.attribute"/>
        <p>
          <xsl:call-template name="number.rtf.lines">
            <xsl:with-param name="rtf" select="$rtf"/>
          </xsl:call-template>
        </p>
      </div>
    </xsl:when>

    <xsl:otherwise>
      <div>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:call-template name="id.attribute"/>
        <p>
          <xsl:call-template name="make-verbatim">
            <xsl:with-param name="rtf" select="$rtf"/>
          </xsl:call-template>
        </p>
      </div>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="make-verbatim">
  <xsl:param name="rtf"/>

  <!-- I want to make this RTF verbatim. There are two possibilities: either
       I have access to the exsl:node-set extension function and I can "do it right"
       or I have to rely on CSS. -->

  <xsl:choose>
    <xsl:when test="$exsl.node.set.available != 0">
      <xsl:apply-templates select="exsl:node-set($rtf)" mode="make.verbatim.mode"/>
    </xsl:when>
    <xsl:otherwise>
      <span style="white-space: pre;">
        <xsl:copy-of select="$rtf"/>
      </span>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="lastLineNumber">
  <xsl:param name="listings"/>
  <xsl:param name="number" select="0"/>

  <xsl:variable name="lines">
    <xsl:call-template name="countLines">
      <xsl:with-param name="listing" select="string($listings[1])"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="not($listings)">
      <xsl:value-of select="$number"/>
    </xsl:when>
    <xsl:when test="$listings[1]/@startinglinenumber">
      <xsl:value-of select="$number + $listings[1]/@startinglinenumber + $lines - 1"/>
    </xsl:when>
    <xsl:when test="$listings[1]/@continuation='continues'">
      <xsl:call-template name="lastLineNumber">
        <xsl:with-param name="listings" select="$listings[position() &gt; 1]"/>
        <xsl:with-param name="number" select="$number + $lines"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$lines"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="countLines">
  <xsl:param name="listing"/>
  <xsl:param name="count" select="1"/>

  <xsl:choose>
    <xsl:when test="contains($listing, '&#10;')">
      <xsl:call-template name="countLines">
        <xsl:with-param name="listing" select="substring-after($listing, '&#10;')"/>
        <xsl:with-param name="count" select="$count + 1"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$count"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<lxslt:component xmlns:lxslt="http://xml.apache.org/xslt" prefix="xtext" elements="insertfile"/><lxslt:component xmlns:lxslt="http://xml.apache.org/xslt" prefix="ximg" functions="new getWidth getDepth"/><xsl:template name="is.graphic.format">
  <xsl:param name="format"/>
  <xsl:if test="$format = 'SVG'                 or $format = 'PNG'                 or $format = 'JPG'                 or $format = 'JPEG'                 or $format = 'linespecific'                 or $format = 'GIF'                 or $format = 'GIF87a'                 or $format = 'GIF89a'                 or $format = 'BMP'">1</xsl:if>
</xsl:template><xsl:template name="is.graphic.extension">
  <xsl:param name="ext"/>
  <xsl:variable name="lcext" select="translate($ext,                                        'ABCDEFGHIJKLMNOPQRSTUVWXYZ',                                        'abcdefghijklmnopqrstuvwxyz')"/>
  <xsl:if test="$lcext = 'svg'              or $lcext = 'png'              or $lcext = 'jpeg'              or $lcext = 'jpg'              or $lcext = 'avi'              or $lcext = 'mpg'              or $lcext = 'mp4'              or $lcext = 'mpeg'              or $lcext = 'qt'              or $lcext = 'gif'              or $lcext = 'acc'              or $lcext = 'mp1'              or $lcext = 'mp2'              or $lcext = 'mp3'              or $lcext = 'mp4'              or $lcext = 'm4v'              or $lcext = 'm4a'              or $lcext = 'wav'              or $lcext = 'ogv'              or $lcext = 'ogg'              or $lcext = 'webm'              or $lcext = 'bmp'">1</xsl:if>
</xsl:template><xsl:template match="screenshot">
  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="screenshot/title">
  <xsl:call-template name="formal.object.heading">
    <xsl:with-param name="object" select=".."/>
  </xsl:call-template>
</xsl:template><xsl:template match="screeninfo">
</xsl:template><xsl:template name="process.image.attributes">
  <xsl:param name="alt"/>
  <xsl:param name="html.width"/>
  <xsl:param name="html.depth"/>
  <xsl:param name="longdesc"/>
  <xsl:param name="scale"/>
  <xsl:param name="scalefit"/>
  <xsl:param name="scaled.contentdepth"/>
  <xsl:param name="scaled.contentwidth"/>
  <xsl:param name="viewport"/>

  <xsl:choose>
    <xsl:when test="@contentwidth or @contentdepth">
      <!-- ignore @width/@depth, @scale, and @scalefit if specified -->
      <xsl:if test="@contentwidth and $scaled.contentwidth != ''">
        <xsl:attribute name="width">
          <xsl:value-of select="$scaled.contentwidth"/>
        </xsl:attribute>
      </xsl:if>
      <xsl:if test="@contentdepth and $scaled.contentdepth != ''">
        <xsl:attribute name="height">
          <xsl:value-of select="$scaled.contentdepth"/>
        </xsl:attribute>
      </xsl:if>
    </xsl:when>

    <xsl:when test="number($scale) != 1.0">
      <!-- scaling is always uniform, so we only have to specify one dimension -->
      <!-- ignore @scalefit if specified -->
      <xsl:attribute name="width">
        <xsl:value-of select="$scaled.contentwidth"/>
      </xsl:attribute>
    </xsl:when>

    <xsl:when test="$scalefit != 0">
      <xsl:choose>
        <xsl:when test="contains($html.width, '%')">
          <xsl:choose>
            <xsl:when test="$viewport != 0">
              <!-- The *viewport* will be scaled, so use 100% here! -->
              <xsl:attribute name="width">
                <xsl:value-of select="'100%'"/>
              </xsl:attribute>
            </xsl:when>
            <xsl:otherwise>
              <xsl:attribute name="width">
                <xsl:value-of select="$html.width"/>
              </xsl:attribute>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>

        <xsl:when test="contains($html.depth, '%')">
          <!-- HTML doesn't deal with this case very well...do nothing -->
        </xsl:when>

        <xsl:when test="$scaled.contentwidth != '' and $html.width != ''                         and $scaled.contentdepth != '' and $html.depth != ''">
          <!-- scalefit should not be anamorphic; figure out which direction -->
          <!-- has the limiting scale factor and scale in that direction -->
          <xsl:choose>
            <xsl:when test="$html.width div $scaled.contentwidth &gt;                             $html.depth div $scaled.contentdepth">
              <xsl:attribute name="height">
                <xsl:value-of select="$html.depth"/>
              </xsl:attribute>
            </xsl:when>
            <xsl:otherwise>
              <xsl:attribute name="width">
                <xsl:value-of select="$html.width"/>
              </xsl:attribute>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>

        <xsl:when test="$scaled.contentwidth != '' and $html.width != ''">
          <xsl:attribute name="width">
            <xsl:value-of select="$html.width"/>
          </xsl:attribute>
        </xsl:when>

        <xsl:when test="$scaled.contentdepth != '' and $html.depth != ''">
          <xsl:attribute name="height">
            <xsl:value-of select="$html.depth"/>
          </xsl:attribute>
        </xsl:when>
      </xsl:choose>
    </xsl:when>
  </xsl:choose>

  <xsl:if test="$alt != ''">
    <xsl:attribute name="alt">
      <xsl:value-of select="normalize-space($alt)"/>
    </xsl:attribute>
  </xsl:if>

  <!-- Turn off longdesc attribute since not supported by browsers
  <xsl:if test="$longdesc != ''">
    <xsl:attribute name="longdesc">
      <xsl:value-of select="$longdesc"/>
    </xsl:attribute>
  </xsl:if>
  -->

  <xsl:if test="@align and $viewport = 0">
    <xsl:attribute name="align">
      <xsl:choose>
        <xsl:when test="@align = 'center'">middle</xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="@align"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:attribute>
  </xsl:if>

  <xsl:call-template name="extension.process.image.attributes"/>
</xsl:template><xsl:template name="extension.process.image.attributes"/><xsl:template match="graphic">
  <xsl:choose>
    <xsl:when test="parent::inlineequation">
      <span>
        <xsl:call-template name="id.attribute"/>
        <xsl:call-template name="anchor"/>
        <xsl:call-template name="process.image"/>
      </span>
    </xsl:when>
    <xsl:otherwise>
      <div>
        <xsl:call-template name="id.attribute"/>
        <xsl:if test="@align">
          <xsl:attribute name="align">
            <xsl:value-of select="@align"/>
          </xsl:attribute>
        </xsl:if>
        <xsl:call-template name="anchor"/>
        <xsl:call-template name="process.image"/>
      </div>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="inlinegraphic">
  <xsl:variable name="filename">
    <xsl:choose>
      <xsl:when test="@entityref">
        <xsl:value-of select="unparsed-entity-uri(@entityref)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="@fileref"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="anchor"/>

  <xsl:choose>
    <xsl:when test="@format='linespecific'">
      <xsl:choose>
        <xsl:when test="$use.extensions != '0'                         and $textinsert.extension != '0'">
          <xsl:choose>
            <xsl:when test="element-available('stext:insertfile')">
              <stext:insertfile xmlns:stext="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.TextFactory" href="{$filename}" encoding="{$textdata.default.encoding}"/>
            </xsl:when>
            <xsl:when test="element-available('xtext:insertfile')">
              <xtext:insertfile xmlns:xtext="xalan://com.nwalsh.xalan.Text" href="{$filename}"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:message terminate="yes">
                <xsl:text>No insertfile extension available.</xsl:text>
              </xsl:message>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
	  <xsl:message terminate="yes">
	    <xsl:text>Cannot insert </xsl:text><xsl:value-of select="$filename"/>
	    <xsl:text>. Check use.extensions and textinsert.extension parameters.</xsl:text> 
	  </xsl:message>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="process.image"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="mediaobject|mediaobjectco">

  <xsl:variable name="olist" select="imageobject|imageobjectco                      |videoobject|audioobject                      |textobject"/>

  <xsl:variable name="object.index">
    <xsl:call-template name="select.mediaobject.index">
      <xsl:with-param name="olist" select="$olist"/>
      <xsl:with-param name="count" select="1"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="object" select="$olist[position() = $object.index]"/>

  <xsl:variable name="align">
    <xsl:value-of select="$object/descendant::imagedata[@align][1]/@align"/>
  </xsl:variable>

  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:if test="$align != '' ">
      <xsl:attribute name="align">
        <xsl:value-of select="$align"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>

    <xsl:apply-templates select="$object"/>
    <xsl:apply-templates select="caption"/>
  </div>
</xsl:template><xsl:template match="inlinemediaobject">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="select.mediaobject"/>
  </span>
</xsl:template><xsl:template match="programlisting/inlinemediaobject                      |screen/inlinemediaobject" priority="2">
  <!-- the additional span causes problems in some cases -->
  <xsl:call-template name="select.mediaobject"/>
</xsl:template><xsl:template match="imageobjectco">
  <xsl:call-template name="anchor"/>
  <xsl:choose>
    <!-- select one imageobject? -->
    <xsl:when test="$use.role.for.mediaobject != 0 and                     count(imageobject) &gt; 1 and                     imageobject[@role]">
      <xsl:variable name="olist" select="imageobject"/>
    
      <xsl:variable name="object.index">
        <xsl:call-template name="select.mediaobject.index">
          <xsl:with-param name="olist" select="$olist"/>
          <xsl:with-param name="count" select="1"/>
        </xsl:call-template>
      </xsl:variable>
    
      <xsl:variable name="object" select="$olist[position() = $object.index]"/>
    
      <xsl:apply-templates select="$object"/>
    </xsl:when>
    <xsl:otherwise>
      <!-- otherwise process them all -->
      <xsl:apply-templates select="imageobject"/>
    </xsl:otherwise>
  </xsl:choose>

  <xsl:apply-templates select="calloutlist"/>

</xsl:template><xsl:template match="imageobject">
  <xsl:apply-templates select="imagedata"/>
</xsl:template>
<xsl:template name="longdesc.uri">
  <xsl:param name="mediaobject" select="."/>
  <xsl:if test="$html.longdesc">
    <xsl:if test="$mediaobject/textobject[not(phrase)]">
      <xsl:variable name="dbhtml.dir">
        <xsl:call-template name="dbhtml-dir"/>
      </xsl:variable>
      <xsl:variable name="filename">
        <xsl:call-template name="make-relative-filename">
          <xsl:with-param name="base.dir">
            <xsl:choose>
              <xsl:when test="$dbhtml.dir != ''">
                <xsl:value-of select="$dbhtml.dir"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="$chunk.base.dir"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
          <xsl:with-param name="base.name">
            <xsl:choose>
              <xsl:when test="                 $mediaobject/@*[local-name() = 'id']                 and not($use.id.as.filename = 0)">
                <!-- * if this mediaobject has an ID, then we use the -->
                <!-- * value of that ID as basename for the "longdesc" -->
                <!-- * file (that is, without prepending an "ld-" too it) -->
                <xsl:value-of select="$mediaobject/@*[local-name() = 'id']"/>
                <xsl:value-of select="$html.ext"/>
              </xsl:when>
              <xsl:otherwise>
                <!-- * otherwise, if this mediaobject does not have an -->
                <!-- * ID, then we generate an ID... -->
                <xsl:variable name="image-id">
                  <xsl:call-template name="object.id">
                    <xsl:with-param name="object" select="$mediaobject"/>
                  </xsl:call-template>
                </xsl:variable>
                <!-- * ...and then we take that generated ID, prepend an -->
                <!-- * "ld-" to it, and use that as the basename for the file -->
                <xsl:value-of select="concat('ld-',$image-id,$html.ext)"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
        </xsl:call-template>
      </xsl:variable>

      <xsl:value-of select="$filename"/>
    </xsl:if>
  </xsl:if>
</xsl:template><xsl:template name="write.longdesc">
  <xsl:param name="mediaobject" select="."/>
  <xsl:if test="$html.longdesc != 0 and $mediaobject/textobject[not(phrase)]">
    <xsl:variable name="filename">
      <xsl:call-template name="longdesc.uri">
        <xsl:with-param name="mediaobject" select="$mediaobject"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:value-of select="$filename"/>

    <xsl:call-template name="write.chunk">
      <xsl:with-param name="filename" select="$filename"/>
      <xsl:with-param name="quiet" select="$chunk.quietly"/>
      <xsl:with-param name="content">
      <xsl:call-template name="user.preroot"/>
        <html>
          <head>
            <xsl:call-template name="system.head.content"/>
            <xsl:call-template name="head.content">
              <xsl:with-param name="title" select="'Long Description'"/>
            </xsl:call-template>
            <xsl:call-template name="user.head.content"/>
          </head>
          <body>
            <xsl:call-template name="body.attributes"/>
            <xsl:for-each select="$mediaobject/textobject[not(phrase)]">
              <xsl:apply-templates select="./*"/>
            </xsl:for-each>
          </body>
        </html>
        <xsl:value-of select="$chunk.append"/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template match="mediaobject/alt">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="videoobject">
  <xsl:apply-templates select="videodata"/>
</xsl:template><xsl:template match="videodata">
  <xsl:call-template name="process.image">
    <xsl:with-param name="tag" select="'embed'"/>
    <xsl:with-param name="alt">
      <xsl:choose>
        <xsl:when test="ancestor::mediaobject/alt">
          <xsl:apply-templates select="ancestor::mediaobject/alt"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="(ancestor::mediaobject/textobject/phrase)[1]"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template><xsl:template match="audioobject">
  <xsl:apply-templates select="audiodata"/>
</xsl:template><xsl:template match="audiodata">
  <xsl:call-template name="process.image">
    <xsl:with-param name="tag" select="'embed'"/>
    <xsl:with-param name="alt">
      <xsl:choose>
        <xsl:when test="ancestor::mediaobject/alt">
          <xsl:apply-templates select="ancestor::mediaobject/alt"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="(ancestor::mediaobject/textobject/phrase)[1]"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template><xsl:template match="textobject">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="textdata">
  <xsl:variable name="filename">
    <xsl:choose>
      <xsl:when test="@entityref">
        <xsl:value-of select="unparsed-entity-uri(@entityref)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="@fileref"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="encoding">
    <xsl:choose>
      <xsl:when test="@encoding">
        <xsl:value-of select="@encoding"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$textdata.default.encoding"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$use.extensions != '0'                     and $textinsert.extension != '0'">
      <xsl:choose>
        <xsl:when test="element-available('stext:insertfile')">
          <stext:insertfile xmlns:stext="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.TextFactory" href="{$filename}" encoding="{$encoding}"/>
        </xsl:when>
        <xsl:when test="element-available('xtext:insertfile')">
          <xtext:insertfile xmlns:xtext="xalan://com.nwalsh.xalan.Text" href="{$filename}"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message terminate="yes">
            <xsl:text>No insertfile extension available.</xsl:text>
          </xsl:message>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:message terminate="yes">
	<xsl:text>Cannot insert </xsl:text><xsl:value-of select="$filename"/>
	<xsl:text>. Check use.extensions and textinsert.extension parameters.</xsl:text> 
      </xsl:message>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="caption">
  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:if test="@align = 'right' or @align = 'left' or @align='center'">
      <xsl:attribute name="align"><xsl:value-of select="@align"/></xsl:attribute>
    </xsl:if>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template xmlns:svg="http://www.w3.org/2000/svg" match="svg:*">
  <xsl:copy>
    <xsl:copy-of select="@*"/>
    <xsl:apply-templates/>
  </xsl:copy>
</xsl:template><xsl:template match="@fileref">
  <!-- need a check for absolute urls -->
  <xsl:choose>
    <xsl:when test="contains(., ':')">
      <!-- it has a uri scheme so it is an absolute uri -->
      <xsl:value-of select="."/>
    </xsl:when>
    <xsl:when test="$keep.relative.image.uris != 0">
      <!-- leave it alone -->
      <xsl:value-of select="."/>
    </xsl:when>
    <xsl:otherwise>
      <!-- its a relative uri that needs xml:base processing -->
      <xsl:call-template name="relative-uri">
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<xsl:variable name="xolink.role">http://docbook.org/xlink/role/olink</xsl:variable><xsl:template match="anchor">
  <xsl:choose>
    <xsl:when test="$generate.id.attributes = 0">
      <xsl:call-template name="anchor"/>
    </xsl:when>
    <xsl:otherwise>
      <span>
        <xsl:call-template name="id.attribute"/>
      </span>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="xref" name="xref">
  <xsl:param name="xhref" select="@xlink:href"/>
  <!-- is the @xlink:href a local idref link? -->
  <xsl:param name="xlink.idref">
    <xsl:if test="starts-with($xhref,'#')                   and (not(contains($xhref,'('))                   or starts-with($xhref, '#xpointer(id('))">
      <xsl:call-template name="xpointer.idref">
        <xsl:with-param name="xpointer" select="$xhref"/>
      </xsl:call-template>
   </xsl:if>
  </xsl:param>
  <xsl:param name="xlink.targets" select="key('id',$xlink.idref)"/>
  <xsl:param name="linkend.targets" select="key('id',@linkend)"/>
  <xsl:param name="target" select="($xlink.targets | $linkend.targets)[1]"/>

  <xsl:variable name="xrefstyle">
    <xsl:choose>
      <xsl:when test="@role and not(@xrefstyle)                        and $use.role.as.xrefstyle != 0">
        <xsl:value-of select="@role"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="@xrefstyle"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="anchor"/>

  <xsl:variable name="content">
    <xsl:choose>
  
      <xsl:when test="@endterm">
        <xsl:variable name="etargets" select="key('id',@endterm)"/>
        <xsl:variable name="etarget" select="$etargets[1]"/>
        <xsl:choose>
          <xsl:when test="count($etarget) = 0">
            <xsl:message>
              <xsl:value-of select="count($etargets)"/>
              <xsl:text>Endterm points to nonexistent ID: </xsl:text>
              <xsl:value-of select="@endterm"/>
            </xsl:message>
            <xsl:text>???</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:apply-templates select="$etarget" mode="endterm"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
  
      <xsl:when test="$target/@xreflabel">
        <xsl:call-template name="xref.xreflabel">
          <xsl:with-param name="target" select="$target"/>
        </xsl:call-template>
      </xsl:when>
  
      <xsl:when test="$target">
        <xsl:if test="not(parent::citation)">
          <xsl:apply-templates select="$target" mode="xref-to-prefix"/>
        </xsl:if>
  
        <xsl:apply-templates select="$target" mode="xref-to">
          <xsl:with-param name="referrer" select="."/>
          <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
        </xsl:apply-templates>
  
        <xsl:if test="not(parent::citation)">
          <xsl:apply-templates select="$target" mode="xref-to-suffix"/>
        </xsl:if>
      </xsl:when>

      <xsl:otherwise>
        <xsl:message>
          <xsl:text>ERROR: xref linking to </xsl:text>
          <xsl:value-of select="@linkend|@xlink:href"/>
          <xsl:text> has no generated link text.</xsl:text>
        </xsl:message>
        <xsl:text>???</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="simple.xlink">
    <xsl:with-param name="content" select="$content"/>
  </xsl:call-template>

</xsl:template><xsl:template match="biblioref">
  <xsl:variable name="targets" select="key('id',@linkend)"/>
  <xsl:variable name="target" select="$targets[1]"/>
  <xsl:variable name="refelem" select="local-name($target)"/>

  <xsl:call-template name="check.id.unique">
    <xsl:with-param name="linkend" select="@linkend"/>
  </xsl:call-template>

  <xsl:call-template name="anchor"/>

  <xsl:choose>
    <xsl:when test="count($target) = 0">
      <xsl:message>
        <xsl:text>XRef to nonexistent id: </xsl:text>
        <xsl:value-of select="@linkend"/>
      </xsl:message>
      <xsl:text>???</xsl:text>
    </xsl:when>

    <xsl:when test="@endterm">
      <xsl:variable name="href">
        <xsl:call-template name="href.target">
          <xsl:with-param name="object" select="$target"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:variable name="etargets" select="key('id',@endterm)"/>
      <xsl:variable name="etarget" select="$etargets[1]"/>
      <xsl:choose>
        <xsl:when test="count($etarget) = 0">
          <xsl:message>
            <xsl:value-of select="count($etargets)"/>
            <xsl:text>Endterm points to nonexistent ID: </xsl:text>
            <xsl:value-of select="@endterm"/>
          </xsl:message>
          <a href="{$href}">
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:text>???</xsl:text>
          </a>
        </xsl:when>
        <xsl:otherwise>
          <a href="{$href}">
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates select="$etarget" mode="endterm"/>
          </a>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>

    <xsl:when test="$target/@xreflabel">
      <a>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:attribute name="href">
          <xsl:call-template name="href.target">
            <xsl:with-param name="object" select="$target"/>
          </xsl:call-template>
        </xsl:attribute>
        <xsl:call-template name="xref.xreflabel">
          <xsl:with-param name="target" select="$target"/>
        </xsl:call-template>
      </a>
    </xsl:when>

    <xsl:otherwise>
      <xsl:variable name="href">
        <xsl:call-template name="href.target">
          <xsl:with-param name="object" select="$target"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:if test="not(parent::citation)">
        <xsl:apply-templates select="$target" mode="xref-to-prefix"/>
      </xsl:if>

      <a href="{$href}">
        <xsl:apply-templates select="." mode="class.attribute"/>
        <xsl:if test="$target/title or $target/info/title">
          <xsl:attribute name="title">
            <xsl:apply-templates select="$target" mode="xref-title"/>
          </xsl:attribute>
        </xsl:if>
        <xsl:apply-templates select="$target" mode="xref-to">
          <xsl:with-param name="referrer" select="."/>
          <xsl:with-param name="xrefstyle">
            <xsl:choose>
              <xsl:when test="@role and not(@xrefstyle) and $use.role.as.xrefstyle != 0">
                <xsl:value-of select="@role"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="@xrefstyle"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
        </xsl:apply-templates>
      </a>

      <xsl:if test="not(parent::citation)">
        <xsl:apply-templates select="$target" mode="xref-to-suffix"/>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="*" mode="endterm">
  <!-- Process the children of the endterm element -->
  <xsl:variable name="endterm">
    <xsl:apply-templates select="child::node()" mode="no.anchor.mode"/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$exsl.node.set.available != 0">
      <xsl:apply-templates select="exsl:node-set($endterm)" mode="remove-ids"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="$endterm"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="*" mode="remove-ids">
  <xsl:choose>
    <!-- handle html or xhtml -->
    <xsl:when test="local-name(.) = 'a'                     and (namespace-uri(.) = ''                          or namespace-uri(.) = 'http://www.w3.org/1999/xhtml')">
      <xsl:choose>
        <xsl:when test="(@name and count(@*) = 1)                         or (@id and count(@*) = 1)                         or (@xml:id and count(@*) = 1)                         or (@xml:id and @name and count(@*) = 2)                         or (@id and @name and count(@*) = 2)">
          <xsl:message>suppress anchor</xsl:message>
          <!-- suppress the whole thing -->
        </xsl:when>
        <xsl:otherwise>
          <xsl:copy>
            <xsl:for-each select="@*">
              <xsl:choose>
                <xsl:when test="local-name(.) != 'name' and local-name(.) != 'id'">
                  <xsl:copy/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:message>removing <xsl:value-of select="local-name(.)"/></xsl:message>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:for-each>
          </xsl:copy>
          <xsl:apply-templates mode="remove-ids"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy>
        <xsl:for-each select="@*">
          <xsl:choose>
            <xsl:when test="local-name(.) != 'id'">
              <xsl:copy/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:message>removing <xsl:value-of select="local-name(.)"/></xsl:message>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:for-each>
        <xsl:apply-templates mode="remove-ids"/>
      </xsl:copy>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="*" mode="xref-to-prefix"/><xsl:template match="*" mode="xref-to-suffix"/><xsl:template match="*" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:if test="$verbose">
    <xsl:message>
      <xsl:text>Don't know what gentext to create for xref to: "</xsl:text>
      <xsl:value-of select="name(.)"/>
      <xsl:text>", ("</xsl:text>
      <xsl:value-of select="(@id|@xml:id)[1]"/>
      <xsl:text>")</xsl:text>
    </xsl:message>
  </xsl:if>
  <xsl:text>???</xsl:text>
</xsl:template><xsl:template match="title" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <!-- if you xref to a title, xref to the parent... -->
  <xsl:choose>
    <!-- FIXME: how reliable is this? -->
    <xsl:when test="contains(local-name(parent::*), 'info')">
      <xsl:apply-templates select="parent::*[2]" mode="xref-to">
        <xsl:with-param name="referrer" select="$referrer"/>
        <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
        <xsl:with-param name="verbose" select="$verbose"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="parent::*" mode="xref-to">
        <xsl:with-param name="referrer" select="$referrer"/>
        <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
        <xsl:with-param name="verbose" select="$verbose"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="abstract|authorblurb|personblurb|bibliodiv|bibliomset                      |biblioset|blockquote|calloutlist|caution|colophon                      |constraintdef|formalpara|glossdiv|important|indexdiv                      |itemizedlist|legalnotice|lot|msg|msgexplan|msgmain                      |msgrel|msgset|msgsub|note|orderedlist|partintro                      |productionset|qandadiv|refsynopsisdiv|screenshot|segmentedlist                      |set|setindex|sidebar|tip|toc|variablelist|warning" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <!-- catch-all for things with (possibly optional) titles -->
  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="author|editor|othercredit|personname" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>

  <xsl:call-template name="person.name"/>
</xsl:template><xsl:template match="authorgroup" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>

  <xsl:call-template name="person.name.list"/>
</xsl:template><xsl:template match="figure|example|table|equation" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="procedure" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose"/>

  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="task" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose"/>

  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="cmdsynopsis" mode="xref-to">
  <xsl:apply-templates select="(.//command)[1]" mode="xref"/>
</xsl:template><xsl:template match="funcsynopsis" mode="xref-to">
  <xsl:apply-templates select="(.//function)[1]" mode="xref"/>
</xsl:template><xsl:template match="dedication|acknowledgements|preface|chapter|appendix|article" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="bibliography" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="biblioentry|bibliomixed" mode="xref-to-prefix">
  <xsl:text>[</xsl:text>
</xsl:template><xsl:template match="biblioentry|bibliomixed" mode="xref-to-suffix">
  <xsl:text>]</xsl:text>
</xsl:template><xsl:template match="biblioentry|bibliomixed" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <!-- handles both biblioentry and bibliomixed -->
  <xsl:choose>
    <xsl:when test="string(.) = ''">
      <xsl:variable name="bib" select="document($bibliography.collection,.)"/>
      <xsl:variable name="id" select="(@id|@xml:id)[1]"/>
      <xsl:variable name="entry" select="$bib/bibliography/                                     *[@id=$id or @xml:id=$id][1]"/>
      <xsl:choose>
        <xsl:when test="$entry">
          <xsl:choose>
            <xsl:when test="$bibliography.numbered != 0">
              <xsl:number from="bibliography" count="biblioentry|bibliomixed" level="any" format="1"/>
            </xsl:when>
            <xsl:when test="local-name($entry/*[1]) = 'abbrev'">
              <xsl:apply-templates select="$entry/*[1]" mode="no.anchor.mode"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="(@id|@xml:id)[1]"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message>
            <xsl:text>No bibliography entry: </xsl:text>
            <xsl:value-of select="$id"/>
            <xsl:text> found in </xsl:text>
            <xsl:value-of select="$bibliography.collection"/>
          </xsl:message>
          <xsl:value-of select="(@id|@xml:id)[1]"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="$bibliography.numbered != 0">
          <xsl:number from="bibliography" count="biblioentry|bibliomixed" level="any" format="1"/>
        </xsl:when>
        <xsl:when test="local-name(*[1]) = 'abbrev'">
          <xsl:apply-templates select="*[1]" mode="no.anchor.mode"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="(@id|@xml:id)[1]"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="glossary" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="glossentry" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>
  <xsl:choose>
    <xsl:when test="$glossentry.show.acronym = 'primary'">
      <xsl:choose>
        <xsl:when test="acronym|abbrev">
          <xsl:apply-templates select="(acronym|abbrev)[1]" mode="no.anchor.mode"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="glossterm[1]" mode="xref-to">
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
          </xsl:apply-templates>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="glossterm[1]" mode="xref-to">
        <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
        <xsl:with-param name="referrer" select="$referrer"/>
        <xsl:with-param name="verbose" select="$verbose"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="glossterm|firstterm" mode="xref-to">
  <xsl:apply-templates mode="no.anchor.mode"/>
</xsl:template><xsl:template match="index" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="listitem" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose"/>

  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="section|simplesect                      |sect1|sect2|sect3|sect4|sect5                      |refsect1|refsect2|refsect3|refsection" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
  <!-- FIXME: What about "in Chapter X"? -->
</xsl:template><xsl:template match="topic" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="bridgehead" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
  <!-- FIXME: What about "in Chapter X"? -->
</xsl:template><xsl:template match="qandaset" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="qandaentry" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates select="question[1]" mode="xref-to">
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="question|answer" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:choose>
    <xsl:when test="string-length(label) != 0">
      <xsl:apply-templates select="." mode="label.markup"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="." mode="object.xref.markup">
        <xsl:with-param name="purpose" select="'xref'"/>
        <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
        <xsl:with-param name="referrer" select="$referrer"/>
        <xsl:with-param name="verbose" select="$verbose"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="part|reference" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="refentry" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>

  <xsl:choose>
    <xsl:when test="refmeta/refentrytitle">
      <xsl:apply-templates select="refmeta/refentrytitle" mode="no.anchor.mode"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="refnamediv/refname[1]" mode="no.anchor.mode"/>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:apply-templates select="refmeta/manvolnum" mode="no.anchor.mode"/>
</xsl:template><xsl:template match="refnamediv" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates select="refname[1]" mode="xref-to">
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="refname" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates mode="xref-to"/>
</xsl:template><xsl:template match="step" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>

  <xsl:call-template name="gentext">
    <xsl:with-param name="key" select="'Step'"/>
  </xsl:call-template>
  <xsl:text> </xsl:text>
  <xsl:apply-templates select="." mode="number"/>
</xsl:template><xsl:template match="varlistentry" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates select="term[1]" mode="xref-to">
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="primary|secondary|tertiary" mode="xref-to">
  <xsl:value-of select="."/>
</xsl:template><xsl:template match="indexterm" mode="xref-to">
  <xsl:value-of select="primary"/>
</xsl:template><xsl:template match="varlistentry/term" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>

  <xsl:apply-templates mode="no.anchor.mode"/>
</xsl:template><xsl:template match="co" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>

  <xsl:apply-templates select="." mode="callout-bug"/>
</xsl:template><xsl:template match="area|areaset" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>

  <xsl:call-template name="callout-bug">
    <xsl:with-param name="conum">
      <xsl:apply-templates select="." mode="conumber"/>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template><xsl:template match="book" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:apply-templates select="." mode="object.xref.markup">
    <xsl:with-param name="purpose" select="'xref'"/>
    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
    <xsl:with-param name="referrer" select="$referrer"/>
    <xsl:with-param name="verbose" select="$verbose"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="para|phrase|simpara|anchor|quote" mode="xref-to">
  <xsl:param name="referrer"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="verbose" select="1"/>

  <xsl:variable name="context" select="(ancestor::simplesect                                        |ancestor::section                                        |ancestor::sect1                                        |ancestor::sect2                                        |ancestor::sect3                                        |ancestor::sect4                                        |ancestor::sect5                                        |ancestor::topic                                        |ancestor::refsection                                        |ancestor::refsect1                                        |ancestor::refsect2                                        |ancestor::refsect3                                        |ancestor::chapter                                        |ancestor::appendix                                        |ancestor::preface                                        |ancestor::partintro                                        |ancestor::dedication                                        |ancestor::acknowledgements                                        |ancestor::colophon                                        |ancestor::bibliography                                        |ancestor::index                                        |ancestor::glossary                                        |ancestor::glossentry                                        |ancestor::listitem                                        |ancestor::varlistentry)[last()]"/>

  <xsl:choose>
    <xsl:when test="$xrefstyle != ''">
      <xsl:apply-templates select="." mode="object.xref.markup">
        <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
        <xsl:with-param name="referrer" select="$referrer"/>
        <xsl:with-param name="verbose" select="$verbose"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="$context" mode="xref-to">
        <xsl:with-param name="purpose" select="'xref'"/>
        <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
        <xsl:with-param name="referrer" select="$referrer"/>
        <xsl:with-param name="verbose" select="$verbose"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="*" mode="xref-title">
  <xsl:variable name="title">
    <xsl:apply-templates select="." mode="object.title.markup"/>
  </xsl:variable>

  <xsl:value-of select="$title"/>
</xsl:template><xsl:template match="author" mode="xref-title">
  <xsl:variable name="title">
    <xsl:call-template name="person.name"/>
  </xsl:variable>

  <xsl:value-of select="$title"/>
</xsl:template><xsl:template match="authorgroup" mode="xref-title">
  <xsl:variable name="title">
    <xsl:call-template name="person.name.list"/>
  </xsl:variable>

  <xsl:value-of select="$title"/>
</xsl:template><xsl:template match="cmdsynopsis" mode="xref-title">
  <xsl:variable name="title">
    <xsl:apply-templates select="(.//command)[1]" mode="xref"/>
  </xsl:variable>

  <xsl:value-of select="$title"/>
</xsl:template><xsl:template match="funcsynopsis" mode="xref-title">
  <xsl:variable name="title">
    <xsl:apply-templates select="(.//function)[1]" mode="xref"/>
  </xsl:variable>

  <xsl:value-of select="$title"/>
</xsl:template><xsl:template match="biblioentry|bibliomixed" mode="xref-title">
  <!-- handles both biblioentry and bibliomixed -->
  <xsl:variable name="title">
    <xsl:text>[</xsl:text>
    <xsl:choose>
      <xsl:when test="local-name(*[1]) = 'abbrev'">
        <xsl:apply-templates select="*[1]" mode="no.anchor.mode"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="(@id|@xml:id)[1]"/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text>]</xsl:text>
  </xsl:variable>

  <xsl:value-of select="$title"/>
</xsl:template><xsl:template match="step" mode="xref-title">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key" select="'Step'"/>
  </xsl:call-template>
  <xsl:text> </xsl:text>
  <xsl:apply-templates select="." mode="number"/>
</xsl:template><xsl:template match="step[not(./title)]" mode="title.markup">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key" select="'Step'"/>
  </xsl:call-template>
  <xsl:text> </xsl:text>
  <xsl:apply-templates select="." mode="number"/>
</xsl:template><xsl:template match="co" mode="xref-title">
  <xsl:variable name="title">
    <xsl:apply-templates select="." mode="callout-bug"/>
  </xsl:variable>

  <xsl:value-of select="$title"/>
</xsl:template><xsl:template match="link" name="link">
  <xsl:param name="linkend" select="@linkend"/>
  <xsl:param name="a.target"/>
  <xsl:param name="xhref" select="@xlink:href"/>

  <xsl:variable name="content">
    <xsl:call-template name="anchor"/>
    <xsl:choose>
      <xsl:when test="count(child::node()) &gt; 0">
        <!-- If it has content, use it -->
        <xsl:apply-templates mode="no.anchor.mode"/>
      </xsl:when>
      <!-- else look for an endterm -->
      <xsl:when test="@endterm">
        <xsl:variable name="etargets" select="key('id',@endterm)"/>
        <xsl:variable name="etarget" select="$etargets[1]"/>
        <xsl:choose>
          <xsl:when test="count($etarget) = 0">
            <xsl:message>
              <xsl:value-of select="count($etargets)"/>
              <xsl:text>Endterm points to nonexistent ID: </xsl:text>
              <xsl:value-of select="@endterm"/>
            </xsl:message>
            <xsl:text>???</xsl:text>
          </xsl:when>
          <xsl:otherwise>
              <xsl:apply-templates select="$etarget" mode="endterm"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <!-- Use the xlink:href if no other text -->
      <xsl:when test="@xlink:href">
        <xsl:value-of select="@xlink:href"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:message>
          <xsl:text>Link element has no content and no Endterm. </xsl:text>
          <xsl:text>Nothing to show in the link to </xsl:text>
          <xsl:value-of select="(@xlink:href|@linkend)[1]"/>
        </xsl:message>
        <xsl:text>???</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="simple.xlink">
    <xsl:with-param name="node" select="."/>
    <xsl:with-param name="linkend" select="$linkend"/>
    <xsl:with-param name="content" select="$content"/>
    <xsl:with-param name="a.target" select="$a.target"/>
    <xsl:with-param name="xhref" select="$xhref"/>
  </xsl:call-template>

</xsl:template><xsl:template match="olink" name="olink">
  <!-- olink content may be passed in from xlink olink -->
  <xsl:param name="content" select="NOTANELEMENT"/>

  <xsl:call-template name="anchor"/>

  <xsl:choose>
    <!-- olinks resolved by stylesheet and target database -->
    <xsl:when test="@targetdoc or @targetptr or                     (@xlink:role=$xolink.role and                      contains(@xlink:href, '#') )">

      <xsl:variable name="targetdoc.att">
        <xsl:choose>
          <xsl:when test="@targetdoc != ''">
            <xsl:value-of select="@targetdoc"/>
          </xsl:when>
          <xsl:when test="@xlink:role=$xolink.role and                        contains(@xlink:href, '#')">
            <xsl:value-of select="substring-before(@xlink:href, '#')"/>
          </xsl:when>
        </xsl:choose>
      </xsl:variable>

      <xsl:variable name="targetptr.att">
        <xsl:choose>
          <xsl:when test="@targetptr != ''">
            <xsl:value-of select="@targetptr"/>
          </xsl:when>
          <xsl:when test="@xlink:role=$xolink.role and                        contains(@xlink:href, '#')">
            <xsl:value-of select="substring-after(@xlink:href, '#')"/>
          </xsl:when>
        </xsl:choose>
      </xsl:variable>

      <xsl:variable name="olink.lang">
        <xsl:call-template name="l10n.language">
          <xsl:with-param name="xref-context" select="true()"/>
        </xsl:call-template>
      </xsl:variable>
    
      <xsl:variable name="target.database.filename">
        <xsl:call-template name="select.target.database">
          <xsl:with-param name="targetdoc.att" select="$targetdoc.att"/>
          <xsl:with-param name="targetptr.att" select="$targetptr.att"/>
          <xsl:with-param name="olink.lang" select="$olink.lang"/>
        </xsl:call-template>
      </xsl:variable>
    
      <xsl:variable name="target.database" select="document($target.database.filename,/)"/>
    
      <xsl:if test="$olink.debug != 0">
        <xsl:message>
          <xsl:text>Olink debug: root element of target.database '</xsl:text>
          <xsl:value-of select="$target.database.filename"/>
          <xsl:text>' is '</xsl:text>
          <xsl:value-of select="local-name($target.database/*[1])"/>
          <xsl:text>'.</xsl:text>
        </xsl:message>
      </xsl:if>
    
      <xsl:variable name="olink.key">
        <xsl:call-template name="select.olink.key">
          <xsl:with-param name="targetdoc.att" select="$targetdoc.att"/>
          <xsl:with-param name="targetptr.att" select="$targetptr.att"/>
          <xsl:with-param name="olink.lang" select="$olink.lang"/>
          <xsl:with-param name="target.database" select="$target.database"/>
        </xsl:call-template>
      </xsl:variable>
    
      <xsl:if test="string-length($olink.key) = 0">
        <xsl:message>
          <xsl:text>Error: unresolved olink: </xsl:text>
          <xsl:text>targetdoc/targetptr = '</xsl:text>
          <xsl:value-of select="$targetdoc.att"/>
          <xsl:text>/</xsl:text>
          <xsl:value-of select="$targetptr.att"/>
          <xsl:text>'.</xsl:text>
        </xsl:message>
      </xsl:if>

      <xsl:variable name="href">
        <xsl:call-template name="make.olink.href">
          <xsl:with-param name="olink.key" select="$olink.key"/>
          <xsl:with-param name="target.database" select="$target.database"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:variable name="hottext">
        <xsl:choose>
          <xsl:when test="string-length($content) != 0">
            <xsl:copy-of select="$content"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="olink.hottext">
              <xsl:with-param name="olink.key" select="$olink.key"/>
              <xsl:with-param name="olink.lang" select="$olink.lang"/>
              <xsl:with-param name="target.database" select="$target.database"/>
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>

      <xsl:variable name="olink.docname.citation">
        <xsl:call-template name="olink.document.citation">
          <xsl:with-param name="olink.key" select="$olink.key"/>
          <xsl:with-param name="target.database" select="$target.database"/>
          <xsl:with-param name="olink.lang" select="$olink.lang"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:variable name="olink.page.citation">
        <xsl:call-template name="olink.page.citation">
          <xsl:with-param name="olink.key" select="$olink.key"/>
          <xsl:with-param name="target.database" select="$target.database"/>
          <xsl:with-param name="olink.lang" select="$olink.lang"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:choose>
        <xsl:when test="$href != ''">
          <a href="{$href}">
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:copy-of select="$hottext"/>
          </a>
          <xsl:copy-of select="$olink.page.citation"/>
          <xsl:copy-of select="$olink.docname.citation"/>
        </xsl:when>
        <xsl:otherwise>
          <span class="olink">
            <xsl:call-template name="id.attribute"/>
            <xsl:copy-of select="$hottext"/>
          </span>
          <xsl:copy-of select="$olink.page.citation"/>
          <xsl:copy-of select="$olink.docname.citation"/>
        </xsl:otherwise>
      </xsl:choose>

    </xsl:when>

    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="@linkmode or @targetdocent or @localinfo">
          <!-- old olink mechanism -->
          <xsl:message>
            <xsl:text>ERROR: olink using obsolete attributes </xsl:text>
            <xsl:text>@linkmode, @targetdocent, @localinfo are </xsl:text>
            <xsl:text>not supported.</xsl:text>
          </xsl:message>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message>
            <xsl:text>ERROR: olink is missing linking attributes.</xsl:text>
          </xsl:message>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="*" mode="pagenumber.markup">
  <!-- no-op in HTML -->
</xsl:template><xsl:template name="xref.xreflabel">
  <!-- called to process an xreflabel...you might use this to make  -->
  <!-- xreflabels come out in the right font for different targets, -->
  <!-- for example. -->
  <xsl:param name="target" select="."/>
  <xsl:value-of select="$target/@xreflabel"/>
</xsl:template><xsl:template match="title" mode="xref">
  <xsl:apply-templates mode="no.anchor.mode"/>
</xsl:template><xsl:template match="command" mode="xref">
  <xsl:call-template name="inline.boldseq"/>
</xsl:template><xsl:template match="function" mode="xref">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="*" mode="insert.title.markup">
  <xsl:param name="purpose"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="title"/>

  <xsl:choose>
    <xsl:when test="$purpose = 'xref'">
      <xsl:copy-of select="$title"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="$title"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="chapter|appendix" mode="insert.title.markup">
  <xsl:param name="purpose"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="title"/>

  <xsl:choose>
    <xsl:when test="$purpose = 'xref'">
      <em xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
        <xsl:copy-of select="$title"/>
      </em>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="$title"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="*" mode="insert.subtitle.markup">
  <xsl:param name="purpose"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="subtitle"/>

  <xsl:copy-of select="$subtitle"/>
</xsl:template><xsl:template match="*" mode="insert.label.markup">
  <xsl:param name="purpose"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="label"/>

  <xsl:copy-of select="$label"/>
</xsl:template><xsl:template match="*" mode="insert.pagenumber.markup">
  <xsl:param name="purpose"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="pagenumber"/>

  <xsl:copy-of select="$pagenumber"/>
</xsl:template><xsl:template match="*" mode="insert.direction.markup">
  <xsl:param name="purpose"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="direction"/>

  <xsl:copy-of select="$direction"/>
</xsl:template><xsl:template match="*" mode="insert.olink.docname.markup">
  <xsl:param name="purpose"/>
  <xsl:param name="xrefstyle"/>
  <xsl:param name="docname"/>

  <span class="olinkdocname">
    <xsl:copy-of select="$docname"/>
  </span>

</xsl:template>
<xsl:param name="formal.object.break.after">1</xsl:param><xsl:template name="formal.object">
  <xsl:param name="placement" select="'before'"/>
  <xsl:param name="class">
    <xsl:apply-templates select="." mode="class.value"/>
  </xsl:param>

  <xsl:call-template name="id.warning"/>

  <xsl:variable name="content">
    <div class="{$class}">
      <xsl:call-template name="id.attribute">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>
      <xsl:call-template name="anchor">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>
    
      <xsl:choose>
        <xsl:when test="$placement = 'before'">
          <xsl:call-template name="formal.object.heading"/>
          <div class="{$class}-contents">
            <xsl:apply-templates/>
          </div>
          <!-- HACK: This doesn't belong inside formal.object; it 
               should be done by the table template, but I want 
               the link to be inside the DIV, so... -->
          <xsl:if test="local-name(.) = 'table'">
            <xsl:call-template name="table.longdesc"/>
          </xsl:if>
    
          <xsl:if test="$spacing.paras != 0"><p/></xsl:if>
        </xsl:when>
        <xsl:otherwise>
          <xsl:if test="$spacing.paras != 0"><p/></xsl:if>
          <div class="{$class}-contents"><xsl:apply-templates/></div>
          <!-- HACK: This doesn't belong inside formal.object; it 
               should be done by the table template, but I want 
               the link to be inside the DIV, so... -->
          <xsl:if test="local-name(.) = 'table'">
            <xsl:call-template name="table.longdesc"/>
          </xsl:if>
    
          <xsl:call-template name="formal.object.heading"/>
        </xsl:otherwise>
      </xsl:choose>
    </div>
    <xsl:if test="not($formal.object.break.after = '0')">
      <br class="{$class}-break"/>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="floatstyle">
    <xsl:call-template name="floatstyle"/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$floatstyle != ''">
      <xsl:call-template name="floater">
        <xsl:with-param name="class"><xsl:value-of select="$class"/>-float</xsl:with-param>
        <xsl:with-param name="floatstyle" select="$floatstyle"/>
        <xsl:with-param name="content" select="$content"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="$content"/>
    </xsl:otherwise>
  </xsl:choose>

</xsl:template><xsl:template name="formal.object.heading">
  <xsl:param name="object" select="."/>
  <xsl:param name="title">
    <xsl:apply-templates select="$object" mode="object.title.markup">
      <xsl:with-param name="allow-anchors" select="1"/>
    </xsl:apply-templates>
  </xsl:param>


  <xsl:choose>
    <xsl:when test="$make.clean.html != 0">
      <xsl:variable name="html.class" select="concat(local-name($object),'-title')"/>
      <div class="{$html.class}">
        <xsl:copy-of select="$title"/>
      </div>
    </xsl:when>
    <xsl:otherwise>
      <p class="title">
        <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
          <xsl:copy-of select="$title"/>
        </strong>
      </p>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="informal.object">
  <xsl:param name="class">
    <xsl:apply-templates select="." mode="class.value"/>
  </xsl:param>

  <xsl:variable name="content">
    <div class="{$class}">
      <xsl:call-template name="id.attribute"/>
      <xsl:if test="$spacing.paras != 0"><p/></xsl:if>
      <xsl:call-template name="anchor"/>
      <xsl:apply-templates/>
  
      <!-- HACK: This doesn't belong inside formal.object; it 
           should be done by the table template, but I want 
           the link to be inside the DIV, so... -->
      <xsl:if test="local-name(.) = 'informaltable'">
        <xsl:call-template name="table.longdesc"/>
      </xsl:if>
  
      <xsl:if test="$spacing.paras != 0"><p/></xsl:if>
    </div>
  </xsl:variable>

  <xsl:variable name="floatstyle">
    <xsl:call-template name="floatstyle"/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$floatstyle != ''">
      <xsl:call-template name="floater">
        <xsl:with-param name="class"><xsl:value-of select="$class"/>-float</xsl:with-param>
        <xsl:with-param name="floatstyle" select="$floatstyle"/>
        <xsl:with-param name="content" select="$content"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="$content"/>
    </xsl:otherwise>
  </xsl:choose>

</xsl:template><xsl:template name="semiformal.object">
  <xsl:param name="placement" select="'before'"/>
  <xsl:param name="class" select="local-name(.)"/>

  <xsl:choose>
    <xsl:when test="title or info/title">
      <xsl:call-template name="formal.object">
        <xsl:with-param name="placement" select="$placement"/>
        <xsl:with-param name="class" select="$class"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="informal.object">
        <xsl:with-param name="class" select="$class"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="figure">
  <xsl:variable name="param.placement" select="substring-after(normalize-space($formal.title.placement),                                         concat(local-name(.), ' '))"/>

  <xsl:variable name="placement">
    <xsl:choose>
      <xsl:when test="contains($param.placement, ' ')">
        <xsl:value-of select="substring-before($param.placement, ' ')"/>
      </xsl:when>
      <xsl:when test="$param.placement = ''">before</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$param.placement"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="formal.object">
    <xsl:with-param name="placement" select="$placement"/>
  </xsl:call-template>

</xsl:template><xsl:template match="table">
  <xsl:choose>
    <xsl:when test="tgroup|mediaobject|graphic">
      <xsl:call-template name="calsTable"/>
    </xsl:when>
    <xsl:when test="caption">
      <xsl:call-template name="htmlTable.with.caption"/>
    </xsl:when>
    <xsl:otherwise>
      <!-- do not use xsl:copy because of XHTML's needs -->
      <div>
        <xsl:call-template name="generate.class.attribute"/>
        <xsl:call-template name="id.attribute"/>
        <xsl:call-template name="anchor"/>
        <xsl:element name="table" namespace="http://www.w3.org/1999/xhtml">
          <xsl:apply-templates select="@*" mode="htmlTableAtt"/>
          <xsl:call-template name="htmlTable"/>
        </xsl:element>
      </div>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="htmlTable.with.caption">
  <xsl:param name="class">
    <xsl:apply-templates select="." mode="class.value"/>
  </xsl:param>

  <xsl:variable name="param.placement" select="substring-after(normalize-space($formal.title.placement),                                         concat(local-name(.), ' '))"/>

  <xsl:variable name="placement">
    <xsl:choose>
      <xsl:when test="contains($param.placement, ' ')">
        <xsl:value-of select="substring-before($param.placement, ' ')"/>
      </xsl:when>
      <xsl:when test="$param.placement = ''">before</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$param.placement"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="id.warning"/>

  <xsl:variable name="content">
    <div class="{$class}">
      <xsl:call-template name="id.attribute">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>
      <xsl:call-template name="anchor">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>
    
      <xsl:choose>
        <xsl:when test="$placement = 'before'">

          <xsl:call-template name="formal.object.heading"/>

          <div class="{$class}-contents">
            <xsl:apply-templates select="." mode="htmlTable"/>
          </div>

          <xsl:call-template name="table.longdesc"/>
    
          <xsl:if test="$spacing.paras != 0"><p/></xsl:if>
        </xsl:when>
        <xsl:otherwise>
          <xsl:if test="$spacing.paras != 0"><p/></xsl:if>

          <div class="{$class}-contents">
            <xsl:apply-templates select="." mode="htmlTable"/>
          </div>

          <xsl:call-template name="table.longdesc"/>
    
          <xsl:call-template name="formal.object.heading"/>
        </xsl:otherwise>
      </xsl:choose>
    </div>
    <xsl:if test="not($formal.object.break.after = '0')">
      <br class="{$class}-break"/>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="floatstyle">
    <xsl:call-template name="floatstyle"/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$floatstyle != ''">
      <xsl:call-template name="floater">
        <xsl:with-param name="class"><xsl:value-of select="$class"/>-float</xsl:with-param>
        <xsl:with-param name="floatstyle" select="$floatstyle"/>
        <xsl:with-param name="content" select="$content"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="$content"/>
    </xsl:otherwise>
  </xsl:choose>

</xsl:template><xsl:template name="calsTable">
  <xsl:if test="tgroup/tbody/tr                 |tgroup/thead/tr                 |tgroup/tfoot/tr">
    <xsl:message terminate="yes">Broken table: tr descendent of CALS Table.</xsl:message>
  </xsl:if>

  <xsl:variable name="param.placement" select="substring-after(normalize-space($formal.title.placement),                                         concat(local-name(.), ' '))"/>

  <xsl:variable name="placement">
    <xsl:choose>
      <xsl:when test="contains($param.placement, ' ')">
        <xsl:value-of select="substring-before($param.placement, ' ')"/>
      </xsl:when>
      <xsl:when test="$param.placement = ''">before</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$param.placement"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="formal.object">
    <xsl:with-param name="placement" select="$placement"/>
  </xsl:call-template>
</xsl:template><xsl:template match="table|informaltable" mode="class.value">
  <xsl:choose>
    <xsl:when test="@tabstyle">
      <xsl:value-of select="@tabstyle"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="local-name(.)"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="htmlTable">
  <xsl:if test="tgroup/tbody/row                 |tgroup/thead/row                 |tgroup/tfoot/row">
    <xsl:message terminate="yes">Broken table: row descendent of HTML table.</xsl:message>
  </xsl:if>

  <xsl:apply-templates mode="htmlTable"/>

  <xsl:if test=".//footnote|../title//footnote">
    <tbody class="footnotes">
      <tr>
        <td colspan="50">
          <xsl:apply-templates select=".//footnote|../title//footnote" mode="table.footnote.mode"/>
        </td>
      </tr>
    </tbody>
  </xsl:if>
</xsl:template><xsl:template match="example">
  <xsl:variable name="param.placement" select="substring-after(normalize-space($formal.title.placement),                      concat(local-name(.), ' '))"/>

  <xsl:variable name="placement">
    <xsl:choose>
      <xsl:when test="contains($param.placement, ' ')">
        <xsl:value-of select="substring-before($param.placement, ' ')"/>
      </xsl:when>
      <xsl:when test="$param.placement = ''">before</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$param.placement"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="formal.object">
    <xsl:with-param name="placement" select="$placement"/>
  </xsl:call-template>

</xsl:template><xsl:template match="equation">
  <xsl:variable name="param.placement" select="substring-after(normalize-space($formal.title.placement),                                       concat(local-name(.), ' '))"/>

  <xsl:variable name="placement">
    <xsl:choose>
      <xsl:when test="contains($param.placement, ' ')">
        <xsl:value-of select="substring-before($param.placement, ' ')"/>
      </xsl:when>
      <xsl:when test="$param.placement = ''">before</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$param.placement"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="formal.object">
    <xsl:with-param name="placement" select="$placement"/>
  </xsl:call-template>

</xsl:template><xsl:template match="figure/title"/><xsl:template match="figure/titleabbrev"/><xsl:template match="table/title"/><xsl:template match="table/titleabbrev"/><xsl:template match="table/textobject"/><xsl:template match="example/title"/><xsl:template match="example/titleabbrev"/><xsl:template match="equation/title"/><xsl:template match="equation/titleabbrev"/><xsl:template match="informalfigure">
  <xsl:call-template name="informal.object"/>
</xsl:template><xsl:template match="informalexample">
  <xsl:call-template name="informal.object"/>
</xsl:template><xsl:template match="informaltable">
  <xsl:choose>
    <xsl:when test="tgroup|mediaobject|graphic">
      <xsl:call-template name="informal.object"/>
    </xsl:when>
    <xsl:otherwise>
      <div>
        <xsl:call-template name="generate.class.attribute"/>
        <xsl:call-template name="id.attribute"/>
        <xsl:call-template name="anchor"/>
        <xsl:element name="table" namespace="http://www.w3.org/1999/xhtml">
          <xsl:apply-templates select="@*" mode="htmlTableAtt"/>
          <xsl:call-template name="htmlTable"/>
        </xsl:element>
      </div>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="informaltable/textobject"/><xsl:template name="table.longdesc">
  <!-- HACK: This doesn't belong inside formal.objectt; it should be done by -->
  <!-- the table template, but I want the link to be inside the DIV, so... -->
  <xsl:variable name="longdesc.uri">
    <xsl:call-template name="longdesc.uri">
      <xsl:with-param name="mediaobject" select="."/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="irrelevant">
    <!-- write.longdesc returns the filename ... -->
    <xsl:call-template name="write.longdesc">
      <xsl:with-param name="mediaobject" select="."/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:if test="$html.longdesc != 0 and $html.longdesc.link != 0                 and textobject[not(phrase)]">
    <xsl:call-template name="longdesc.link">
      <xsl:with-param name="longdesc.uri" select="$longdesc.uri"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template match="informalequation">
  <xsl:call-template name="informal.object"/>
</xsl:template><xsl:template name="floatstyle">
  <xsl:if test="(@float and @float != '0') or @floatstyle != ''">
    <xsl:choose>
      <xsl:when test="@floatstyle != ''">
        <xsl:value-of select="@floatstyle"/>
      </xsl:when>
      <xsl:when test="@float = '1'">
        <xsl:value-of select="$default.float.class"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="@float"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
</xsl:template><xsl:template name="floater">
  <xsl:param name="content"/>
  <xsl:param name="class" select="'float'"/>
  <xsl:param name="floatstyle" select="'left'"/>

  <div class="{$class}">
    <xsl:if test="$floatstyle = 'left' or $floatstyle = 'right'">
      <xsl:attribute name="style">
        <xsl:text>float: </xsl:text>
        <xsl:value-of select="$floatstyle"/>
        <xsl:text>;</xsl:text>
      </xsl:attribute>
    </xsl:if>
    <xsl:copy-of select="$content"/>
  </div>
</xsl:template>
<xsl:template name="blank.spans">
  <xsl:param name="cols" select="1"/>
  <xsl:if test="$cols &gt; 0">
    <xsl:text>0:</xsl:text>
    <xsl:call-template name="blank.spans">
      <xsl:with-param name="cols" select="$cols - 1"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template name="calculate.following.spans">
  <xsl:param name="colspan" select="1"/>
  <xsl:param name="spans" select="''"/>

  <xsl:choose>
    <xsl:when test="$colspan &gt; 0">
      <xsl:call-template name="calculate.following.spans">
        <xsl:with-param name="colspan" select="$colspan - 1"/>
        <xsl:with-param name="spans" select="substring-after($spans,':')"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$spans"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="finaltd">
  <xsl:param name="spans"/>
  <xsl:param name="col" select="0"/>

  <xsl:if test="$spans != ''">
    <xsl:choose>
      <xsl:when test="starts-with($spans,'0:')">
        <xsl:call-template name="empty.table.cell">
          <xsl:with-param name="colnum" select="$col"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise/>
    </xsl:choose>

    <xsl:call-template name="finaltd">
      <xsl:with-param name="spans" select="substring-after($spans,':')"/>
      <xsl:with-param name="col" select="$col+1"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template name="sfinaltd">
  <xsl:param name="spans"/>

  <xsl:if test="$spans != ''">
    <xsl:choose>
      <xsl:when test="starts-with($spans,'0:')">0:</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="substring-before($spans,':')-1"/>
        <xsl:text>:</xsl:text>
      </xsl:otherwise>
    </xsl:choose>

    <xsl:call-template name="sfinaltd">
      <xsl:with-param name="spans" select="substring-after($spans,':')"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template name="entry.colnum">
  <xsl:param name="entry" select="."/>

  <xsl:choose>
    <xsl:when test="$entry/@spanname">
      <xsl:variable name="spanname" select="$entry/@spanname"/>
      <xsl:variable name="spanspec" select="($entry/ancestor::tgroup/spanspec[@spanname=$spanname]                              |$entry/ancestor::entrytbl/spanspec[@spanname=$spanname])[last()]"/>
      <xsl:variable name="colspec" select="($entry/ancestor::tgroup/colspec[@colname=$spanspec/@namest]                              |$entry/ancestor::entrytbl/colspec[@colname=$spanspec/@namest])[last()]"/>
      <xsl:call-template name="colspec.colnum">
        <xsl:with-param name="colspec" select="$colspec"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$entry/@colname">
      <xsl:variable name="colname" select="$entry/@colname"/>
      <xsl:variable name="colspec" select="($entry/ancestor::tgroup/colspec[@colname=$colname]                              |$entry/ancestor::entrytbl/colspec[@colname=$colname])[last()]"/>
      <xsl:call-template name="colspec.colnum">
        <xsl:with-param name="colspec" select="$colspec"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$entry/@namest">
      <xsl:variable name="namest" select="$entry/@namest"/>
      <xsl:variable name="colspec" select="($entry/ancestor::tgroup/colspec[@colname=$namest]                              |$entry/ancestor::entrytbl/colspec[@colname=$namest])[last()]"/>
      <xsl:call-template name="colspec.colnum">
        <xsl:with-param name="colspec" select="$colspec"/>
      </xsl:call-template>
    </xsl:when>
    <!-- no idea, return 0 -->
    <xsl:otherwise>0</xsl:otherwise>
  </xsl:choose>
</xsl:template><doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="entry.colnum">
<refpurpose>Determine the column number in which a given entry occurs</refpurpose>
<refdescription id="entry.colnum-desc">
<para>If an <tag>entry</tag> has a
<tag class="attribute">colname</tag> or
<tag class="attribute">namest</tag> attribute, this template
will determine the number of the column in which the entry should occur.
For other <tag>entry</tag>s, nothing is returned.</para>
</refdescription>
<refparameter id="entry.colnum-params">
<variablelist>
<varlistentry><term>entry</term>
<listitem>
<para>The <tag>entry</tag>-element which is to be tested.</para>
</listitem>
</varlistentry>
</variablelist>
</refparameter>

<refreturn id="entry.colnum-returns">
<para>This template returns the column number if it can be determined,
or 0 (the empty string)</para>
</refreturn>
</doc:template><xsl:template name="colspec.colnum">
  <xsl:param name="colspec" select="."/>
  <xsl:choose>
    <xsl:when test="$colspec/@colnum">
      <xsl:value-of select="$colspec/@colnum"/>
    </xsl:when>
    <xsl:when test="$colspec/preceding-sibling::colspec">
      <xsl:variable name="prec.colspec.colnum">
        <xsl:call-template name="colspec.colnum">
          <xsl:with-param name="colspec" select="$colspec/preceding-sibling::colspec[1]"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:value-of select="$prec.colspec.colnum + 1"/>
    </xsl:when>
    <xsl:otherwise>1</xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="calculate.colspan">
  <xsl:param name="entry" select="."/>
  <xsl:variable name="spanname" select="$entry/@spanname"/>
  <xsl:variable name="spanspec" select="($entry/ancestor::tgroup/spanspec[@spanname=$spanname]                          |$entry/ancestor::entrytbl/spanspec[@spanname=$spanname])[last()]"/>

  <xsl:variable name="namest">
    <xsl:choose>
      <xsl:when test="@spanname">
        <xsl:value-of select="$spanspec/@namest"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$entry/@namest"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="nameend">
    <xsl:choose>
      <xsl:when test="@spanname">
        <xsl:value-of select="$spanspec/@nameend"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$entry/@nameend"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="scol">
    <xsl:call-template name="colspec.colnum">
      <xsl:with-param name="colspec" select="($entry/ancestor::tgroup/colspec[@colname=$namest]                                |$entry/ancestor::entrytbl/colspec[@colname=$namest])[last()]"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="ecol">
    <xsl:call-template name="colspec.colnum">
      <xsl:with-param name="colspec" select="($entry/ancestor::tgroup/colspec[@colname=$nameend]                                |$entry/ancestor::entrytbl/colspec[@colname=$nameend])[last()]"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$namest != '' and $nameend != ''">
      <xsl:choose>
        <xsl:when test="number($ecol) &gt;= number($scol)">
          <xsl:value-of select="number($ecol) - number($scol) + 1"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="number($scol) - number($ecol) + 1"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>1</xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="calculate.rowsep">
  <xsl:param name="entry" select="."/>
  <xsl:param name="colnum" select="0"/>

  <xsl:call-template name="inherited.table.attribute">
    <xsl:with-param name="entry" select="$entry"/>
    <xsl:with-param name="colnum" select="$colnum"/>
    <xsl:with-param name="attribute" select="'rowsep'"/>
  </xsl:call-template>
</xsl:template><xsl:template name="calculate.colsep">
  <xsl:param name="entry" select="."/>
  <xsl:param name="colnum" select="0"/>

  <xsl:call-template name="inherited.table.attribute">
    <xsl:with-param name="entry" select="$entry"/>
    <xsl:with-param name="colnum" select="$colnum"/>
    <xsl:with-param name="attribute" select="'colsep'"/>
  </xsl:call-template>
</xsl:template><xsl:template name="inherited.table.attribute">
  <xsl:param name="entry" select="."/>
  <xsl:param name="row" select="$entry/ancestor-or-self::row[1]"/>
  <xsl:param name="colnum" select="0"/>
  <xsl:param name="attribute" select="'colsep'"/>

  <xsl:variable name="tgroup" select="$row/parent::*/parent::tgroup[1]"/>
  <xsl:variable name="tbody" select="$row/parent::*[1]"/>

  <xsl:variable name="table" select="($tgroup/ancestor::table                                      |$tgroup/ancestor::informaltable                                      |$entry/ancestor::entrytbl)[last()]"/>

  <xsl:variable name="entry.value">
    <xsl:call-template name="get-attribute">
      <xsl:with-param name="element" select="$entry"/>
      <xsl:with-param name="attribute" select="$attribute"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="row.value">
    <xsl:call-template name="get-attribute">
      <xsl:with-param name="element" select="$row"/>
      <xsl:with-param name="attribute" select="$attribute"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="span.value">
    <xsl:if test="$entry/@spanname">
      <xsl:variable name="spanname" select="$entry/@spanname"/>
      <xsl:variable name="spanspec" select="$tgroup/spanspec[@spanname=$spanname]"/>
      <xsl:variable name="span.colspec" select="$tgroup/colspec[@colname=$spanspec/@namest]"/>

      <xsl:variable name="spanspec.value">
        <xsl:call-template name="get-attribute">
          <xsl:with-param name="element" select="$spanspec"/>
          <xsl:with-param name="attribute" select="$attribute"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:variable name="scolspec.value">
        <xsl:call-template name="get-attribute">
          <xsl:with-param name="element" select="$span.colspec"/>
          <xsl:with-param name="attribute" select="$attribute"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:choose>
        <xsl:when test="$spanspec.value != ''">
          <xsl:value-of select="$spanspec.value"/>
        </xsl:when>
        <xsl:when test="$scolspec.value != ''">
          <xsl:value-of select="$scolspec.value"/>
        </xsl:when>
        <xsl:otherwise/>
      </xsl:choose>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="namest.value">
    <xsl:if test="$entry/@namest">
      <xsl:variable name="namest" select="$entry/@namest"/>
      <xsl:variable name="colspec" select="$tgroup/colspec[@colname=$namest]"/>

      <xsl:variable name="inner.namest.value">
        <xsl:call-template name="get-attribute">
          <xsl:with-param name="element" select="$colspec"/>
          <xsl:with-param name="attribute" select="$attribute"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:choose>
        <xsl:when test="$inner.namest.value">
          <xsl:value-of select="$inner.namest.value"/>
        </xsl:when>
        <xsl:otherwise/>
      </xsl:choose>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="tgroup.value">
    <xsl:call-template name="get-attribute">
      <xsl:with-param name="element" select="$tgroup"/>
      <xsl:with-param name="attribute" select="$attribute"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="tbody.value">
    <xsl:call-template name="get-attribute">
      <xsl:with-param name="element" select="$tbody"/>
      <xsl:with-param name="attribute" select="$attribute"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="table.value">
    <xsl:call-template name="get-attribute">
      <xsl:with-param name="element" select="$table"/>
      <xsl:with-param name="attribute" select="$attribute"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="default.value">
    <!-- This section used to say that rowsep and colsep have defaults based -->
    <!-- on the frame setting. Further reflection and closer examination of the -->
    <!-- CALS spec reveals I was mistaken. The default is "1" for rowsep and colsep. -->
    <!-- For everything else, the default is the tgroup value -->
    <xsl:choose>
      <xsl:when test="$tgroup.value != ''">
        <xsl:value-of select="$tgroup.value"/>
      </xsl:when>
      <xsl:when test="$attribute = 'rowsep'">1</xsl:when>
      <xsl:when test="$attribute = 'colsep'">1</xsl:when>
      <xsl:otherwise><!-- empty --></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="calc.colvalue">
    <xsl:if test="$colnum &gt; 0">
      <xsl:call-template name="colnum.colspec">
        <xsl:with-param name="colnum" select="$colnum"/>
        <xsl:with-param name="attribute" select="$attribute"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$entry.value != ''">
      <xsl:value-of select="$entry.value"/>
    </xsl:when>
    <xsl:when test="$row.value != ''">
      <xsl:value-of select="$row.value"/>
    </xsl:when>
    <xsl:when test="$span.value != ''">
      <xsl:value-of select="$span.value"/>
    </xsl:when>
    <xsl:when test="$namest.value != ''">
      <xsl:value-of select="$namest.value"/>
    </xsl:when>
    <xsl:when test="$calc.colvalue != ''">
      <xsl:value-of select="$calc.colvalue"/>
    </xsl:when>
    <xsl:when test="$tbody.value != ''">
      <xsl:value-of select="$tbody.value"/>
    </xsl:when>
    <xsl:when test="$tgroup.value != ''">
      <xsl:value-of select="$tgroup.value"/>
    </xsl:when>
    <xsl:when test="$table.value != ''">
      <xsl:value-of select="$table.value"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$default.value"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="colnum.colspec">
  <xsl:param name="colnum" select="0"/>
  <xsl:param name="attribute" select="'colname'"/>
  <xsl:param name="colspec.ancestor" select="(ancestor::tgroup|ancestor::entrytbl)                      [position() = last()]"/>
  <xsl:param name="colspecs" select="$colspec.ancestor/colspec"/>
  <xsl:param name="count" select="1"/>

  <xsl:choose>
    <xsl:when test="not($colspecs) or $count &gt; $colnum">
      <!-- nop -->
    </xsl:when>
    <xsl:when test="$colspecs[1]/@colnum">
      <xsl:choose>
        <xsl:when test="$colspecs[1]/@colnum = $colnum">
          <xsl:call-template name="get-attribute">
            <xsl:with-param name="element" select="$colspecs[1]"/>
            <xsl:with-param name="attribute" select="$attribute"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="colnum.colspec">
            <xsl:with-param name="colnum" select="$colnum"/>
            <xsl:with-param name="attribute" select="$attribute"/>
            <xsl:with-param name="colspecs" select="$colspecs[position()&gt;1]"/>
            <xsl:with-param name="count" select="$colspecs[1]/@colnum+1"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="$count = $colnum">
          <xsl:call-template name="get-attribute">
            <xsl:with-param name="element" select="$colspecs[1]"/>
            <xsl:with-param name="attribute" select="$attribute"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="colnum.colspec">
            <xsl:with-param name="colnum" select="$colnum"/>
            <xsl:with-param name="attribute" select="$attribute"/>
            <xsl:with-param name="colspecs" select="$colspecs[position()&gt;1]"/>
            <xsl:with-param name="count" select="$count+1"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="get-attribute">
  <xsl:param name="element" select="."/>
  <xsl:param name="attribute" select="''"/>

  <xsl:for-each select="$element/@*">
    <xsl:if test="local-name(.) = $attribute">
      <xsl:value-of select="."/>
    </xsl:if>
  </xsl:for-each>
</xsl:template><xsl:template name="consume-row">
  <xsl:param name="spans"/>

  <xsl:if test="contains($spans,':')">
    <xsl:value-of select="substring-before($spans,':') - 1"/>
    <xsl:text>:</xsl:text>
    <xsl:call-template name="consume-row">
      <xsl:with-param name="spans" select="substring-after($spans,':')"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template name="tabstyle">
  <xsl:param name="node" select="."/>

  <xsl:variable name="tgroup" select="$node/tgroup[1] |                                        $node/ancestor-or-self::tgroup[1]"/>

  <xsl:variable name="table" select="($node/ancestor-or-self::table |                           $node/ancestor-or-self::informaltable)[last()]"/>

  <xsl:variable name="tabstyle">
    <xsl:choose>
      <xsl:when test="$table/@tabstyle != ''">
        <xsl:value-of select="normalize-space($table/@tabstyle)"/>
      </xsl:when>
      <xsl:when test="$tgroup/@tgroupstyle != ''">
        <xsl:value-of select="normalize-space($tgroup/@tgroupstyle)"/>
      </xsl:when>
      <xsl:otherwise>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:value-of select="$tabstyle"/>
</xsl:template><lxslt:component xmlns:lxslt="http://xml.apache.org/xslt" prefix="xtbl" functions="adjustColumnWidths"/><xsl:template name="empty.table.cell">
  <xsl:param name="colnum" select="0"/>

  <xsl:variable name="rowsep">
    <xsl:choose>
      <!-- If this is the last row, rowsep never applies. -->
      <xsl:when test="not(ancestor-or-self::row[1]/following-sibling::row                           or ancestor-or-self::thead/following-sibling::tbody                           or ancestor-or-self::tbody/preceding-sibling::tfoot)">
        <xsl:value-of select="0"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="inherited.table.attribute">
          <xsl:with-param name="entry" select="NOT-AN-ELEMENT-NAME"/>
          <xsl:with-param name="row" select="ancestor-or-self::row[1]"/>
          <xsl:with-param name="colnum" select="$colnum"/>
          <xsl:with-param name="attribute" select="'rowsep'"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="colsep">
    <xsl:choose>
      <!-- If this is the last column, colsep never applies. -->
      <xsl:when test="number($colnum) &gt;= ancestor::tgroup/@cols">0</xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="inherited.table.attribute">
          <xsl:with-param name="entry" select="NOT-AN-ELEMENT-NAME"/>
          <xsl:with-param name="row" select="ancestor-or-self::row[1]"/>
          <xsl:with-param name="colnum" select="$colnum"/>
          <xsl:with-param name="attribute" select="'colsep'"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <td class="auto-generated">
    <xsl:if test="$table.borders.with.css != 0">
      <xsl:attribute name="style">
        <xsl:if test="$colsep &gt; 0">
          <xsl:call-template name="border">
            <xsl:with-param name="side" select="'right'"/>
          </xsl:call-template>
        </xsl:if>
        <xsl:if test="$rowsep &gt; 0">
          <xsl:call-template name="border">
            <xsl:with-param name="side" select="'bottom'"/>
          </xsl:call-template>
        </xsl:if>
      </xsl:attribute>
    </xsl:if>
    <xsl:text>Â </xsl:text>
  </td>
</xsl:template><xsl:template name="border">
  <xsl:param name="side" select="'left'"/>
  <xsl:param name="padding" select="0"/>
  <xsl:param name="style" select="$table.cell.border.style"/>
  <xsl:param name="color" select="$table.cell.border.color"/>
  <xsl:param name="thickness" select="$table.cell.border.thickness"/>

  <!-- Note: Some browsers (mozilla) require at least a width and style. -->

  <xsl:choose>
    <xsl:when test="($thickness != ''                      and $style != ''                      and $color != '')                     or ($thickness != ''                         and $style != '')                     or ($thickness != '')">
      <!-- use the compound property if we can: -->
      <!-- it saves space and probably works more reliably -->
      <xsl:text>border-</xsl:text>
      <xsl:value-of select="$side"/>
      <xsl:text>: </xsl:text>
      <xsl:value-of select="$thickness"/>
      <xsl:text> </xsl:text>
      <xsl:value-of select="$style"/>
      <xsl:text> </xsl:text>
      <xsl:value-of select="$color"/>
      <xsl:text>; </xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <!-- we need to specify the styles individually -->
      <xsl:if test="$thickness != ''">
        <xsl:text>border-</xsl:text>
        <xsl:value-of select="$side"/>
        <xsl:text>-width: </xsl:text>
        <xsl:value-of select="$thickness"/>
        <xsl:text>; </xsl:text>
      </xsl:if>

      <xsl:if test="$style != ''">
        <xsl:text>border-</xsl:text>
        <xsl:value-of select="$side"/>
        <xsl:text>-style: </xsl:text>
        <xsl:value-of select="$style"/>
        <xsl:text>; </xsl:text>
      </xsl:if>

      <xsl:if test="$color != ''">
        <xsl:text>border-</xsl:text>
        <xsl:value-of select="$side"/>
        <xsl:text>-color: </xsl:text>
        <xsl:value-of select="$color"/>
        <xsl:text>; </xsl:text>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="tgroup/processing-instruction('dbhtml')">
  <xsl:variable name="summary">
    <xsl:call-template name="pi.dbhtml_table-summary"/>
  </xsl:variable>

  <!-- Suppress the table-summary PI -->
  <xsl:if test="$summary = ''">
    <xsl:processing-instruction name="dbhtml">
      <xsl:value-of select="."/>
    </xsl:processing-instruction>
  </xsl:if>
</xsl:template><xsl:template match="colspec"/><xsl:template match="spanspec"/><xsl:template match="thead|tfoot">
  <xsl:element name="{local-name(.)}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:if test="@align">
      <xsl:attribute name="align">
        <xsl:value-of select="@align"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="@char">
      <xsl:attribute name="char">
        <xsl:value-of select="@char"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="@charoff">
      <xsl:attribute name="charoff">
        <xsl:value-of select="@charoff"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="@valign">
      <xsl:attribute name="valign">
        <xsl:value-of select="@valign"/>
      </xsl:attribute>
    </xsl:if>

    <xsl:choose>
      <!-- recurse on rows only if @morerows is present -->
      <xsl:when test="row/entry/@morerows|row/entrytbl/@morerows">
        <xsl:apply-templates select="row[1]">
          <xsl:with-param name="spans">
            <xsl:call-template name="blank.spans">
              <xsl:with-param name="cols" select="../@cols"/>
            </xsl:call-template>
          </xsl:with-param>
          <xsl:with-param name="browserows" select="'recurse'"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="row">
          <xsl:with-param name="spans">
            <xsl:call-template name="blank.spans">
              <xsl:with-param name="cols" select="../@cols"/>
            </xsl:call-template>
          </xsl:with-param>
          <xsl:with-param name="browserows" select="'loop'"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>

  </xsl:element>
</xsl:template><xsl:template match="tbody">
  <tbody>
    <xsl:if test="@align">
      <xsl:attribute name="align">
        <xsl:value-of select="@align"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="@char">
      <xsl:attribute name="char">
        <xsl:value-of select="@char"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="@charoff">
      <xsl:attribute name="charoff">
        <xsl:value-of select="@charoff"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="@valign">
      <xsl:attribute name="valign">
        <xsl:value-of select="@valign"/>
      </xsl:attribute>
    </xsl:if>

    <xsl:choose>
      <xsl:when test="row/entry/@morerows|row/entrytbl/@morerows">
        <xsl:apply-templates select="row[1]">
          <xsl:with-param name="spans">
            <xsl:call-template name="blank.spans">
              <xsl:with-param name="cols" select="../@cols"/>
            </xsl:call-template>
          </xsl:with-param>
          <xsl:with-param name="browserows" select="'recurse'"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="row">
          <xsl:with-param name="spans">
            <xsl:call-template name="blank.spans">
              <xsl:with-param name="cols" select="../@cols"/>
            </xsl:call-template>
          </xsl:with-param>
          <xsl:with-param name="browserows" select="'loop'"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>

  </tbody>
</xsl:template><xsl:template match="row">
  <xsl:param name="spans"/>
  <xsl:param name="browserows"/>

  <xsl:choose>
    <xsl:when test="contains($spans, '0')">
      <xsl:call-template name="normal-row">
        <xsl:with-param name="spans" select="$spans"/>
        <xsl:with-param name="browserows" select="$browserows"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <!--
      <xsl:message>
        <xsl:text>Ignoring row: </xsl:text>
        <xsl:value-of select="$spans"/>
        <xsl:text> = </xsl:text>
        <xsl:call-template name="consume-row">
          <xsl:with-param name="spans" select="$spans"/>
        </xsl:call-template>
      </xsl:message>
      -->

      <xsl:if test="normalize-space(.//text()) != ''">
        <xsl:message>Warning: overlapped row contains content!</xsl:message>
      </xsl:if>

      <tr><xsl:comment> This row intentionally left blank </xsl:comment></tr>

      <xsl:if test="$browserows = 'recurse'">
        <xsl:apply-templates select="following-sibling::row[1]">
          <xsl:with-param name="spans">
            <xsl:call-template name="consume-row">
              <xsl:with-param name="spans" select="$spans"/>
            </xsl:call-template>
          </xsl:with-param>
          <xsl:with-param name="browserows" select="$browserows"/>
        </xsl:apply-templates>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="normal-row">
  <xsl:param name="spans"/>
  <xsl:param name="browserows"/>

  <xsl:variable name="row-height">
    <xsl:if test="processing-instruction('dbhtml')">
      <xsl:call-template name="pi.dbhtml_row-height"/>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="bgcolor">
    <xsl:if test="processing-instruction('dbhtml')">
      <xsl:call-template name="pi.dbhtml_bgcolor"/>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="class">
    <xsl:if test="processing-instruction('dbhtml')">
      <xsl:call-template name="pi.dbhtml_class"/>
    </xsl:if>
  </xsl:variable>

  <tr>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="tr.attributes">
      <xsl:with-param name="rownum">
        <xsl:number from="tgroup" count="row"/>
      </xsl:with-param>
    </xsl:call-template>

    <xsl:if test="$row-height != ''">
      <xsl:attribute name="height">
        <xsl:value-of select="$row-height"/>
      </xsl:attribute>
    </xsl:if>

    <xsl:if test="$bgcolor != ''">
      <xsl:attribute name="bgcolor">
        <xsl:value-of select="$bgcolor"/>
      </xsl:attribute>
    </xsl:if>

    <xsl:if test="$class != ''">
      <xsl:attribute name="class">
        <xsl:value-of select="$class"/>
      </xsl:attribute>
    </xsl:if>

    <xsl:if test="$table.borders.with.css != 0">
      <xsl:if test="@rowsep = 1 and following-sibling::row">
        <xsl:attribute name="style">
          <xsl:call-template name="border">
            <xsl:with-param name="side" select="'bottom'"/>
          </xsl:call-template>
        </xsl:attribute>
      </xsl:if>
    </xsl:if>

    <xsl:if test="@align">
      <xsl:attribute name="align">
        <xsl:value-of select="@align"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="@char">
      <xsl:attribute name="char">
        <xsl:value-of select="@char"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="@charoff">
      <xsl:attribute name="charoff">
        <xsl:value-of select="@charoff"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="@valign">
      <xsl:attribute name="valign">
        <xsl:value-of select="@valign"/>
      </xsl:attribute>
    </xsl:if>

    <xsl:apply-templates select="(entry|entrytbl)[1]">
      <xsl:with-param name="spans" select="$spans"/>
    </xsl:apply-templates>
  </tr>

  <xsl:if test="$browserows = 'recurse'">
    <xsl:if test="following-sibling::row">
      <xsl:variable name="nextspans">
        <xsl:apply-templates select="(entry|entrytbl)[1]" mode="span">
          <xsl:with-param name="spans" select="$spans"/>
        </xsl:apply-templates>
      </xsl:variable>
  
      <xsl:apply-templates select="following-sibling::row[1]">
        <xsl:with-param name="spans" select="$nextspans"/>
        <xsl:with-param name="browserows" select="$browserows"/>
      </xsl:apply-templates>
    </xsl:if>
  </xsl:if>
</xsl:template><xsl:template match="entry|entrytbl" name="entry">
  <xsl:param name="col">
    <xsl:choose>
      <xsl:when test="@revisionflag">
        <xsl:number from="row"/>
      </xsl:when>
      <xsl:otherwise>1</xsl:otherwise>
    </xsl:choose>
  </xsl:param>

  <xsl:param name="spans"/>

  <xsl:variable name="cellgi">
    <xsl:choose>
      <xsl:when test="ancestor::thead">th</xsl:when>
      <xsl:when test="ancestor::tfoot">th</xsl:when>
      <xsl:when test="ancestor::tbody and                        (ancestor::table[@rowheader = 'firstcol'] or                       ancestor::informaltable[@rowheader = 'firstcol']) and                       ancestor-or-self::entry[1][count(preceding-sibling::entry) = 0]">
        <xsl:text>th</xsl:text>
      </xsl:when>
      <xsl:otherwise>td</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="empty.cell" select="count(node()) = 0"/>

  <xsl:variable name="named.colnum">
    <xsl:call-template name="entry.colnum"/>
  </xsl:variable>

  <xsl:variable name="entry.colnum">
    <xsl:choose>
      <xsl:when test="$named.colnum &gt; 0">
        <xsl:value-of select="$named.colnum"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$col"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="entry.colspan">
    <xsl:choose>
      <xsl:when test="@spanname or @namest">
        <xsl:call-template name="calculate.colspan"/>
      </xsl:when>
      <xsl:otherwise>1</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="following.spans">
    <xsl:call-template name="calculate.following.spans">
      <xsl:with-param name="colspan" select="$entry.colspan"/>
      <xsl:with-param name="spans" select="$spans"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="rowsep">
    <xsl:choose>
      <!-- If this is the last row, rowsep never applies. -->
      <xsl:when test="ancestor::entrytbl                       and not (ancestor-or-self::row[1]/following-sibling::row)                       and not (ancestor::thead)">
        <xsl:value-of select="0"/>
      </xsl:when>
      <xsl:when test="not(ancestor-or-self::row[1]/following-sibling::row                           or ancestor-or-self::thead/following-sibling::tbody                           or ancestor-or-self::tbody/preceding-sibling::tfoot)">
        <xsl:value-of select="0"/>
      </xsl:when>
      <xsl:when test="@morerows and not(@morerows &lt;                   count(ancestor-or-self::row[1]/following-sibling::row))">
        <xsl:value-of select="0"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="inherited.table.attribute">
          <xsl:with-param name="entry" select="."/>
          <xsl:with-param name="colnum" select="$entry.colnum"/>
          <xsl:with-param name="attribute" select="'rowsep'"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="colsep">
    <xsl:choose>
      <!-- If this is the last column, colsep never applies. -->
      <xsl:when test="$following.spans = ''">0</xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="inherited.table.attribute">
          <xsl:with-param name="entry" select="."/>
          <xsl:with-param name="colnum" select="$entry.colnum"/>
          <xsl:with-param name="attribute" select="'colsep'"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="valign">
    <xsl:call-template name="inherited.table.attribute">
      <xsl:with-param name="entry" select="."/>
      <xsl:with-param name="colnum" select="$entry.colnum"/>
      <xsl:with-param name="attribute" select="'valign'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="align">
    <xsl:call-template name="inherited.table.attribute">
      <xsl:with-param name="entry" select="."/>
      <xsl:with-param name="colnum" select="$entry.colnum"/>
      <xsl:with-param name="attribute" select="'align'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="char">
    <xsl:call-template name="inherited.table.attribute">
      <xsl:with-param name="entry" select="."/>
      <xsl:with-param name="colnum" select="$entry.colnum"/>
      <xsl:with-param name="attribute" select="'char'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="charoff">
    <xsl:call-template name="inherited.table.attribute">
      <xsl:with-param name="entry" select="."/>
      <xsl:with-param name="colnum" select="$entry.colnum"/>
      <xsl:with-param name="attribute" select="'charoff'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$spans != '' and not(starts-with($spans,'0:'))">
      <xsl:call-template name="entry">
        <xsl:with-param name="col" select="$col+1"/>
        <xsl:with-param name="spans" select="substring-after($spans,':')"/>
      </xsl:call-template>
    </xsl:when>

    <xsl:when test="number($entry.colnum) &gt; $col">
      <xsl:call-template name="empty.table.cell"/>
      <xsl:call-template name="entry">
        <xsl:with-param name="col" select="$col+1"/>
        <xsl:with-param name="spans" select="substring-after($spans,':')"/>
      </xsl:call-template>
    </xsl:when>

    <xsl:otherwise>
      <xsl:variable name="bgcolor">
        <xsl:if test="processing-instruction('dbhtml')">
          <xsl:call-template name="pi.dbhtml_bgcolor"/>
        </xsl:if>
      </xsl:variable>

      <xsl:element name="{$cellgi}" namespace="http://www.w3.org/1999/xhtml">
        <xsl:call-template name="id.attribute"/>
        <xsl:if test="$bgcolor != ''">
          <xsl:attribute name="bgcolor">
            <xsl:value-of select="$bgcolor"/>
          </xsl:attribute>
        </xsl:if>

        <xsl:call-template name="locale.html.attributes"/>
        <xsl:choose>
          <xsl:when test="$entry.propagates.style != 0 and @role">
            <xsl:apply-templates select="." mode="class.attribute">
              <xsl:with-param name="class" select="@role"/>
            </xsl:apply-templates>
          </xsl:when>
          <xsl:otherwise>
            <xsl:apply-templates select="." mode="class.attribute">
              <xsl:with-param name="class" select="''"/>
            </xsl:apply-templates>
          </xsl:otherwise>
        </xsl:choose>

        <xsl:if test="$show.revisionflag and @revisionflag">
          <xsl:attribute name="class">
            <xsl:value-of select="@revisionflag"/>
          </xsl:attribute>
        </xsl:if>

        <xsl:if test="$table.borders.with.css != 0">
          <xsl:attribute name="style">
            <xsl:if test="$colsep &gt; 0">
              <xsl:call-template name="border">
                <xsl:with-param name="side" select="'right'"/>
              </xsl:call-template>
            </xsl:if>
            <xsl:if test="$rowsep &gt; 0">
              <xsl:call-template name="border">
                <xsl:with-param name="side" select="'bottom'"/>
              </xsl:call-template>
            </xsl:if>
          </xsl:attribute>
        </xsl:if>

        <xsl:if test="@morerows &gt; 0">
          <xsl:attribute name="rowspan">
            <xsl:value-of select="1+@morerows"/>
          </xsl:attribute>
        </xsl:if>

        <xsl:if test="$entry.colspan &gt; 1">
          <xsl:attribute name="colspan">
            <xsl:value-of select="$entry.colspan"/>
          </xsl:attribute>
        </xsl:if>

        <xsl:if test="$align != ''">
          <xsl:attribute name="align">
            <xsl:value-of select="$align"/>
          </xsl:attribute>
        </xsl:if>

        <xsl:if test="$valign != ''">
          <xsl:attribute name="valign">
            <xsl:value-of select="$valign"/>
          </xsl:attribute>
        </xsl:if>

        <xsl:if test="$char != ''">
          <xsl:attribute name="char">
            <xsl:value-of select="$char"/>
          </xsl:attribute>
        </xsl:if>

        <xsl:if test="$charoff != ''">
          <xsl:attribute name="charoff">
            <xsl:value-of select="$charoff"/>
          </xsl:attribute>
        </xsl:if>

        <xsl:if test="not(preceding-sibling::*) and                      (ancestor::row[1]/@id or ancestor::row[1]/@xml:id)">
          <xsl:call-template name="anchor">
            <xsl:with-param name="node" select="ancestor::row[1]"/>
          </xsl:call-template>
        </xsl:if>

        <xsl:call-template name="anchor"/>

        <xsl:choose>
          <xsl:when test="$empty.cell">
            <xsl:text>Â </xsl:text>
          </xsl:when>
          <xsl:when test="self::entrytbl">
            <xsl:call-template name="tgroup"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:apply-templates/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:element>

      <xsl:choose>
        <xsl:when test="following-sibling::entry|following-sibling::entrytbl">
          <xsl:apply-templates select="(following-sibling::entry                                        |following-sibling::entrytbl)[1]">
            <xsl:with-param name="col" select="$col+$entry.colspan"/>
            <xsl:with-param name="spans" select="$following.spans"/>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="finaltd">
            <xsl:with-param name="spans" select="$following.spans"/>
            <xsl:with-param name="col" select="$col+$entry.colspan"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="entry|entrytbl" name="sentry" mode="span">
  <xsl:param name="col" select="1"/>
  <xsl:param name="spans"/>

  <xsl:variable name="entry.colnum">
    <xsl:call-template name="entry.colnum"/>
  </xsl:variable>

  <xsl:variable name="entry.colspan">
    <xsl:choose>
      <xsl:when test="@spanname or @namest">
        <xsl:call-template name="calculate.colspan"/>
      </xsl:when>
      <xsl:otherwise>1</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="following.spans">
    <xsl:call-template name="calculate.following.spans">
      <xsl:with-param name="colspan" select="$entry.colspan"/>
      <xsl:with-param name="spans" select="$spans"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$spans != '' and not(starts-with($spans,'0:'))">
      <xsl:value-of select="substring-before($spans,':')-1"/>
      <xsl:text>:</xsl:text>
      <xsl:call-template name="sentry">
        <xsl:with-param name="col" select="$col+1"/>
        <xsl:with-param name="spans" select="substring-after($spans,':')"/>
      </xsl:call-template>
    </xsl:when>

    <xsl:when test="number($entry.colnum) &gt; $col">
      <xsl:text>0:</xsl:text>
      <xsl:call-template name="sentry">
        <xsl:with-param name="col" select="$col + 1"/>
        <xsl:with-param name="spans" select="substring-after($spans,':')"/>
      </xsl:call-template>
    </xsl:when>

    <xsl:otherwise>
      <xsl:call-template name="copy-string">
        <xsl:with-param name="count" select="$entry.colspan"/>
        <xsl:with-param name="string">
          <xsl:choose>
            <xsl:when test="@morerows">
              <xsl:value-of select="@morerows"/>
            </xsl:when>
            <xsl:otherwise>0</xsl:otherwise>
          </xsl:choose>
          <xsl:text>:</xsl:text>
        </xsl:with-param>
      </xsl:call-template>

      <xsl:choose>
        <xsl:when test="following-sibling::entry|following-sibling::entrytbl">
          <xsl:apply-templates select="(following-sibling::entry                                         |following-sibling::entrytbl)[1]" mode="span">
            <xsl:with-param name="col" select="$col+$entry.colspan"/>
            <xsl:with-param name="spans" select="$following.spans"/>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="sfinaltd">
            <xsl:with-param name="spans" select="$following.spans"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="generate.colgroup">
  <xsl:param name="cols" select="1"/>
  <xsl:param name="count" select="1"/>
  <xsl:choose>
    <xsl:when test="$count &gt; $cols"/>
    <xsl:otherwise>
      <xsl:call-template name="generate.col">
        <xsl:with-param name="countcol" select="$count"/>
      </xsl:call-template>
      <xsl:call-template name="generate.colgroup">
        <xsl:with-param name="cols" select="$cols"/>
        <xsl:with-param name="count" select="$count+1"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="generate.col">
  <xsl:param name="countcol">1</xsl:param>
  <xsl:param name="colspecs" select="./colspec"/>
  <xsl:param name="count">1</xsl:param>
  <xsl:param name="colnum">1</xsl:param>

  <xsl:choose>
    <xsl:when test="$count&gt;count($colspecs)">
      <col/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="colspec" select="$colspecs[$count=position()]"/>
      <xsl:variable name="colspec.colnum">
        <xsl:choose>
          <xsl:when test="$colspec/@colnum">
            <xsl:value-of select="$colspec/@colnum"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$colnum"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>

      <xsl:choose>
        <xsl:when test="$colspec.colnum=$countcol">
          <col>
            <xsl:choose>
              <xsl:when test="$colspec/@colwidth                             and $use.extensions != 0                             and $tablecolumns.extension != 0">
                <xsl:attribute name="width">
                  <xsl:choose>
                    <xsl:when test="normalize-space($colspec/@colwidth) = '*'">
                      <xsl:value-of select="'1*'"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:value-of select="$colspec/@colwidth"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:attribute>
              </xsl:when>
              <!-- pass through to HTML if no * in colspecs -->
              <xsl:when test="$colspec/@colwidth and                              not($colspec/parent::*/colspec/@colwidth[contains(.,'*')])">
                <xsl:attribute name="width">
                  <xsl:choose>
                    <xsl:when test="normalize-space($colspec/@colwidth) = '*'">
                      <xsl:value-of select="'1*'"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:value-of select="$colspec/@colwidth"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:attribute>
              </xsl:when>
            </xsl:choose>

            <xsl:choose>
              <xsl:when test="$colspec/@align">
                <xsl:attribute name="align">
                  <xsl:value-of select="$colspec/@align"/>
                </xsl:attribute>
              </xsl:when>
              <!-- Suggested by Pavel ZAMPACH <zampach@nemcb.cz> -->
              <xsl:when test="$colspecs/ancestor::tgroup/@align">
                <xsl:attribute name="align">
                  <xsl:value-of select="$colspecs/ancestor::tgroup/@align"/>
                </xsl:attribute>
              </xsl:when>
            </xsl:choose>

            <xsl:if test="$colspec/@char">
              <xsl:attribute name="char">
                <xsl:value-of select="$colspec/@char"/>
              </xsl:attribute>
            </xsl:if>
            
            <xsl:if test="$colspec/@charoff">
              <xsl:attribute name="charoff">
                <xsl:value-of select="$colspec/@charoff"/>
              </xsl:attribute>
            </xsl:if>

            <xsl:if test="$colspec/@colname">
              <xsl:attribute name="class">
                <xsl:value-of select="$colspec/@colname"/>
              </xsl:attribute>
            </xsl:if>
          </col>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="generate.col">
            <xsl:with-param name="countcol" select="$countcol"/>
            <xsl:with-param name="colspecs" select="$colspecs"/>
            <xsl:with-param name="count" select="$count+1"/>
            <xsl:with-param name="colnum">
              <xsl:choose>
                <xsl:when test="$colspec/@colnum">
                  <xsl:value-of select="$colspec/@colnum + 1"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:value-of select="$colnum + 1"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:with-param>
           </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="colspec.colwidth">
  <!-- when this macro is called, the current context must be an entry -->
  <xsl:param name="colname"/>
  <!-- .. = row, ../.. = thead|tbody, ../../.. = tgroup -->
  <xsl:param name="colspecs" select="../../../../tgroup/colspec"/>
  <xsl:param name="count">1</xsl:param>
  <xsl:choose>
    <xsl:when test="$count&gt;count($colspecs)"/>
    <xsl:otherwise>
      <xsl:variable name="colspec" select="$colspecs[$count=position()]"/>
      <xsl:choose>
        <xsl:when test="$colspec/@colname=$colname">
          <xsl:value-of select="$colspec/@colwidth"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="colspec.colwidth">
            <xsl:with-param name="colname" select="$colname"/>
            <xsl:with-param name="colspecs" select="$colspecs"/>
            <xsl:with-param name="count" select="$count+1"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="tr.attributes">
  <xsl:param name="row" select="."/>
  <xsl:param name="rownum" select="0"/>

  <!-- by default, do nothing. But you might want to say:

  <xsl:if test="$rownum mod 2 = 0">
    <xsl:attribute name="class">oddrow</xsl:attribute>
  </xsl:if>

  -->
</xsl:template>
<xsl:template match="table" mode="htmlTable">
  <xsl:element name="table" namespace="http://www.w3.org/1999/xhtml">
    <xsl:apply-templates select="@*" mode="htmlTableAtt"/>
    <xsl:call-template name="htmlTable"/>
  </xsl:element>
</xsl:template><xsl:template match="colgroup" mode="htmlTable">
  <xsl:element name="{local-name()}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:apply-templates select="@*" mode="htmlTableAtt"/>
    <xsl:apply-templates mode="htmlTable"/>
  </xsl:element>
</xsl:template><xsl:template match="col" mode="htmlTable">
  <xsl:element name="{local-name()}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:apply-templates select="@*" mode="htmlTableAtt"/>
  </xsl:element>
</xsl:template><xsl:template match="caption" mode="htmlTable"/><xsl:template match="tbody|thead|tfoot|tr" mode="htmlTable">
  <xsl:element name="{local-name(.)}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:apply-templates select="@*" mode="htmlTableAtt"/>
    <xsl:apply-templates mode="htmlTable"/>
  </xsl:element>
</xsl:template><xsl:template match="th|td" mode="htmlTable">
  <xsl:element name="{local-name(.)}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:apply-templates select="@*" mode="htmlTableAtt"/>
    <xsl:apply-templates/> <!-- *not* mode=htmlTable -->
  </xsl:element>
</xsl:template><xsl:template mode="htmlTableAtt" match="@*"/><xsl:template mode="htmlTableAtt" match="@abbr                    | @align                    | @axis                    | @bgcolor                    | @border                    | @cellpadding                    | @cellspacing                    | @char                    | @charoff                    | @class                    | @dir                    | @frame                    | @headers                    | @height                    | @lang                    | @nowrap                    | @onclick                    | @ondblclick                    | @onkeydown                    | @onkeypress                    | @onkeyup                    | @onmousedown                    | @onmousemove                    | @onmouseout                    | @onmouseover                    | @onmouseup                    | @rules                    | @style                    | @summary                    | @title                    | @valign                    | @valign                    | @width                    | @xml:lang">
  <xsl:copy-of select="."/>
</xsl:template><xsl:template match="@span|@rowspan|@colspan" mode="htmlTableAtt">
  <!-- No need to copy through the DTD's default value "1" of the attribute -->
  <xsl:if test="number(.) != 1">
    <xsl:attribute name="{local-name(.)}">
      <xsl:value-of select="."/>
    </xsl:attribute>
  </xsl:if>
</xsl:template><xsl:template match="@floatstyle" mode="htmlTableAtt">
  <xsl:attribute name="style">
    <xsl:text>float: </xsl:text>
    <xsl:choose>
      <xsl:when test="contains(., 'left')">left</xsl:when>
      <xsl:when test="contains(., 'right')">right</xsl:when>
      <xsl:when test="contains(., 'start')">
        <xsl:value-of select="$direction.align.start"/>
      </xsl:when>
      <xsl:when test="contains(., 'end')">
        <xsl:value-of select="$direction.align.end"/>
      </xsl:when>
      <xsl:when test="contains(., 'inside')">
        <xsl:value-of select="$direction.align.start"/>
      </xsl:when>
      <xsl:when test="contains(., 'outside')">
        <xsl:value-of select="$direction.align.end"/>
      </xsl:when>
      <xsl:when test="contains(., 'before')">none</xsl:when>
      <xsl:when test="contains(., 'none')">none</xsl:when>
    </xsl:choose>
    <xsl:text>;</xsl:text>
  </xsl:attribute>
</xsl:template>
<xsl:template match="section">
  <xsl:variable name="depth" select="count(ancestor::section)+1"/>

  <xsl:call-template name="id.warning"/>

  <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:call-template name="section.titlepage"/>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:if test="contains($toc.params, 'toc')                   and $depth &lt;= $generate.section.toc.level">
      <xsl:call-template name="section.toc">
        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
      </xsl:call-template>
      <xsl:call-template name="section.toc.separator"/>
    </xsl:if>
    <xsl:apply-templates/>
    <xsl:call-template name="process.chunk.footnotes"/>
  </xsl:element>
</xsl:template><xsl:template name="section.title">
  <!-- the context node should be the title of a section when called -->
  <xsl:variable name="section" select="(ancestor::section                                         |ancestor::simplesect                                         |ancestor::sect1                                         |ancestor::sect2                                         |ancestor::sect3                                         |ancestor::sect4                                         |ancestor::sect5)[last()]"/>

  <xsl:variable name="renderas">
    <xsl:choose>
      <xsl:when test="$section/@renderas = 'sect1'">1</xsl:when>
      <xsl:when test="$section/@renderas = 'sect2'">2</xsl:when>
      <xsl:when test="$section/@renderas = 'sect3'">3</xsl:when>
      <xsl:when test="$section/@renderas = 'sect4'">4</xsl:when>
      <xsl:when test="$section/@renderas = 'sect5'">5</xsl:when>
      <xsl:otherwise><xsl:value-of select="''"/></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="level">
    <xsl:choose>
      <xsl:when test="$renderas != ''">
        <xsl:value-of select="$renderas"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="section.level">
          <xsl:with-param name="node" select="$section"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="section.heading">
    <xsl:with-param name="section" select="$section"/>
    <xsl:with-param name="level" select="$level"/>
    <xsl:with-param name="title">
      <xsl:apply-templates select="$section" mode="object.title.markup">
        <xsl:with-param name="allow-anchors" select="1"/>
      </xsl:apply-templates>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template><xsl:template match="section/title                     |section/info/title                     |sectioninfo/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.title"/>
</xsl:template><xsl:template match="sect1">
  <xsl:call-template name="id.warning"/>

  <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:choose>
      <xsl:when test="@renderas = 'sect2'">
        <xsl:call-template name="sect2.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect3'">
        <xsl:call-template name="sect3.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect4'">
        <xsl:call-template name="sect4.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect5'">
        <xsl:call-template name="sect5.titlepage"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="sect1.titlepage"/>
      </xsl:otherwise>
    </xsl:choose>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:if test="contains($toc.params, 'toc')                   and $generate.section.toc.level &gt;= 1">
      <xsl:call-template name="section.toc">
        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
      </xsl:call-template>
      <xsl:call-template name="section.toc.separator"/>
    </xsl:if>
    <xsl:apply-templates/>
    <xsl:call-template name="process.chunk.footnotes"/>
  </xsl:element>
</xsl:template><xsl:template match="sect1/title                     |sect1/info/title                     |sect1info/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.title"/>
</xsl:template><xsl:template match="sect2">
  <xsl:call-template name="id.warning"/>

  <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:choose>
      <xsl:when test="@renderas = 'sect1'">
        <xsl:call-template name="sect1.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect3'">
        <xsl:call-template name="sect3.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect4'">
        <xsl:call-template name="sect4.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect5'">
        <xsl:call-template name="sect5.titlepage"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="sect2.titlepage"/>
      </xsl:otherwise>
    </xsl:choose>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:if test="contains($toc.params, 'toc')                   and $generate.section.toc.level &gt;= 2">
      <xsl:call-template name="section.toc">
        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
      </xsl:call-template>
      <xsl:call-template name="section.toc.separator"/>
    </xsl:if>
    <xsl:apply-templates/>
    <xsl:call-template name="process.chunk.footnotes"/>
  </xsl:element>
</xsl:template><xsl:template match="sect2/title                     |sect2/info/title                     |sect2info/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.title"/>
</xsl:template><xsl:template match="sect3">
  <xsl:call-template name="id.warning"/>

  <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:choose>
      <xsl:when test="@renderas = 'sect1'">
        <xsl:call-template name="sect1.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect2'">
        <xsl:call-template name="sect2.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect4'">
        <xsl:call-template name="sect4.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect5'">
        <xsl:call-template name="sect5.titlepage"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="sect3.titlepage"/>
      </xsl:otherwise>
    </xsl:choose>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:if test="contains($toc.params, 'toc')                   and $generate.section.toc.level &gt;= 3">
      <xsl:call-template name="section.toc">
        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
      </xsl:call-template>
      <xsl:call-template name="section.toc.separator"/>
    </xsl:if>
    <xsl:apply-templates/>
    <xsl:call-template name="process.chunk.footnotes"/>
  </xsl:element>
</xsl:template><xsl:template match="sect3/title                     |sect3/info/title                     |sect3info/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.title"/>
</xsl:template><xsl:template match="sect4">
  <xsl:call-template name="id.warning"/>

  <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:choose>
      <xsl:when test="@renderas = 'sect1'">
        <xsl:call-template name="sect1.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect2'">
        <xsl:call-template name="sect2.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect3'">
        <xsl:call-template name="sect3.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect5'">
        <xsl:call-template name="sect5.titlepage"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="sect4.titlepage"/>
      </xsl:otherwise>
    </xsl:choose>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:if test="contains($toc.params, 'toc')                   and $generate.section.toc.level &gt;= 4">
      <xsl:call-template name="section.toc">
        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
      </xsl:call-template>
      <xsl:call-template name="section.toc.separator"/>
    </xsl:if>
    <xsl:apply-templates/>
    <xsl:call-template name="process.chunk.footnotes"/>
  </xsl:element>
</xsl:template><xsl:template match="sect4/title                     |sect4/info/title                     |sect4info/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.title"/>
</xsl:template><xsl:template match="sect5">
  <xsl:call-template name="id.warning"/>

  <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:choose>
      <xsl:when test="@renderas = 'sect1'">
        <xsl:call-template name="sect1.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect2'">
        <xsl:call-template name="sect2.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect3'">
        <xsl:call-template name="sect3.titlepage"/>
      </xsl:when>
      <xsl:when test="@renderas = 'sect4'">
        <xsl:call-template name="sect4.titlepage"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="sect5.titlepage"/>
      </xsl:otherwise>
    </xsl:choose>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:if test="contains($toc.params, 'toc')                   and $generate.section.toc.level &gt;= 5">
      <xsl:call-template name="section.toc">
        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
      </xsl:call-template>
      <xsl:call-template name="section.toc.separator"/>
    </xsl:if>
    <xsl:apply-templates/>
    <xsl:call-template name="process.chunk.footnotes"/>
  </xsl:element>
</xsl:template><xsl:template match="sect5/title                     |sect5/info/title                     |sect5info/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.title"/>
</xsl:template><xsl:template match="simplesect">
  <xsl:call-template name="id.warning"/>

  <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:call-template name="simplesect.titlepage"/>
    <xsl:apply-templates/>
  </xsl:element>
</xsl:template><xsl:template match="simplesect/title|simplesect/info/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.title"/>
</xsl:template><xsl:template match="section/title"/><xsl:template match="section/titleabbrev"/><xsl:template match="section/subtitle"/><xsl:template match="sectioninfo"/><xsl:template match="section/info"/><xsl:template match="sect1/title"/><xsl:template match="sect1/titleabbrev"/><xsl:template match="sect1/subtitle"/><xsl:template match="sect1info"/><xsl:template match="sect1/info"/><xsl:template match="sect2/title"/><xsl:template match="sect2/subtitle"/><xsl:template match="sect2/titleabbrev"/><xsl:template match="sect2info"/><xsl:template match="sect2/info"/><xsl:template match="sect3/title"/><xsl:template match="sect3/subtitle"/><xsl:template match="sect3/titleabbrev"/><xsl:template match="sect3info"/><xsl:template match="sect3/info"/><xsl:template match="sect4/title"/><xsl:template match="sect4/subtitle"/><xsl:template match="sect4/titleabbrev"/><xsl:template match="sect4info"/><xsl:template match="sect4/info"/><xsl:template match="sect5/title"/><xsl:template match="sect5/subtitle"/><xsl:template match="sect5/titleabbrev"/><xsl:template match="sect5info"/><xsl:template match="sect5/info"/><xsl:template match="simplesect/title"/><xsl:template match="simplesect/subtitle"/><xsl:template match="simplesect/titleabbrev"/><xsl:template match="simplesect/info"/><xsl:template name="section.heading">
  <xsl:param name="section" select="."/>
  <xsl:param name="level" select="1"/>
  <xsl:param name="allow-anchors" select="1"/>
  <xsl:param name="title"/>
  <xsl:param name="class" select="'title'"/>

  <xsl:variable name="id">
    <xsl:choose>
      <!-- Make sure the subtitle doesn't get the same id as the title -->
      <xsl:when test="self::subtitle">
        <xsl:call-template name="object.id">
          <xsl:with-param name="object" select="."/>
        </xsl:call-template>
      </xsl:when>
      <!-- if title is in an *info wrapper, get the grandparent -->
      <xsl:when test="contains(local-name(..), 'info')">
        <xsl:call-template name="object.id">
          <xsl:with-param name="object" select="../.."/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="object.id">
          <xsl:with-param name="object" select=".."/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- HTML H level is one higher than section level -->
  <xsl:variable name="hlevel">
    <xsl:choose>
      <!-- highest valid HTML H level is H6; so anything nested deeper
           than 5 levels down just becomes H6 -->
      <xsl:when test="$level &gt; 5">6</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$level + 1"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:element name="h{$hlevel}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:attribute name="class"><xsl:value-of select="$class"/></xsl:attribute>
    <xsl:if test="$css.decoration != '0'">
      <xsl:if test="$hlevel&lt;3">
        <xsl:attribute name="style">clear: both</xsl:attribute>
      </xsl:if>
    </xsl:if>
    <xsl:if test="$allow-anchors != 0">
      <xsl:call-template name="anchor">
        <xsl:with-param name="node" select="$section"/>
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>
    </xsl:if>
    <xsl:copy-of select="$title"/>
  </xsl:element>
</xsl:template><xsl:template match="bridgehead">
  <xsl:variable name="container" select="(ancestor::appendix                         |ancestor::article                         |ancestor::bibliography                         |ancestor::chapter                         |ancestor::glossary                         |ancestor::glossdiv                         |ancestor::index                         |ancestor::partintro                         |ancestor::preface                         |ancestor::refsect1                         |ancestor::refsect2                         |ancestor::refsect3                         |ancestor::sect1                         |ancestor::sect2                         |ancestor::sect3                         |ancestor::sect4                         |ancestor::sect5                         |ancestor::section                         |ancestor::setindex                         |ancestor::simplesect)[last()]"/>

  <xsl:variable name="clevel">
    <xsl:choose>
      <xsl:when test="local-name($container) = 'appendix'                       or local-name($container) = 'chapter'                       or local-name($container) = 'article'                       or local-name($container) = 'bibliography'                       or local-name($container) = 'glossary'                       or local-name($container) = 'index'                       or local-name($container) = 'partintro'                       or local-name($container) = 'preface'                       or local-name($container) = 'setindex'">1</xsl:when>
      <xsl:when test="local-name($container) = 'glossdiv'">
        <xsl:value-of select="count(ancestor::glossdiv)+1"/>
      </xsl:when>
      <xsl:when test="local-name($container) = 'sect1'                       or local-name($container) = 'sect2'                       or local-name($container) = 'sect3'                       or local-name($container) = 'sect4'                       or local-name($container) = 'sect5'                       or local-name($container) = 'refsect1'                       or local-name($container) = 'refsect2'                       or local-name($container) = 'refsect3'                       or local-name($container) = 'section'                       or local-name($container) = 'simplesect'">
        <xsl:variable name="slevel">
          <xsl:call-template name="section.level">
            <xsl:with-param name="node" select="$container"/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="$slevel + 1"/>
      </xsl:when>
      <xsl:otherwise>1</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- HTML H level is one higher than section level -->
  <xsl:variable name="hlevel">
    <xsl:choose>
      <xsl:when test="@renderas = 'sect1'">2</xsl:when>
      <xsl:when test="@renderas = 'sect2'">3</xsl:when>
      <xsl:when test="@renderas = 'sect3'">4</xsl:when>
      <xsl:when test="@renderas = 'sect4'">5</xsl:when>
      <xsl:when test="@renderas = 'sect5'">6</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$clevel + 1"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:element name="h{$hlevel}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:call-template name="anchor">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:apply-templates/>
  </xsl:element>
</xsl:template><xsl:template match="section/subtitle" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.subtitle"/>
</xsl:template><xsl:template match="simplesect/subtitle" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.subtitle"/>
</xsl:template><xsl:template match="sect1/subtitle" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.subtitle"/>
</xsl:template><xsl:template match="sect2/subtitle" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.subtitle"/>
</xsl:template><xsl:template match="sect3/subtitle" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.subtitle"/>
</xsl:template><xsl:template match="sect4/subtitle" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.subtitle"/>
</xsl:template><xsl:template match="sect5/subtitle" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.subtitle"/>
</xsl:template><xsl:template name="section.subtitle">
  <!-- the context node should be the subtitle of a section when called -->
  <xsl:variable name="section" select="(ancestor::section                                         |ancestor::simplesect                                         |ancestor::sect1                                         |ancestor::sect2                                         |ancestor::sect3                                         |ancestor::sect4                                         |ancestor::sect5)[last()]"/>

  <xsl:variable name="level">
    <xsl:call-template name="section.level">
      <xsl:with-param name="node" select="$section"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:call-template name="section.heading">
    <xsl:with-param name="section" select=".."/>
    <xsl:with-param name="allow-anchors" select="0"/>
    <!-- subtitle heading level one higher than section level -->
    <xsl:with-param name="level" select="$level + 1"/>
    <xsl:with-param name="class" select="'subtitle'"/>
    <xsl:with-param name="title">
      <xsl:apply-templates select="$section" mode="object.subtitle.markup">
        <xsl:with-param name="allow-anchors" select="0"/>
      </xsl:apply-templates>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template>
<xsl:key name="glossentries" match="glossentry" use="normalize-space(glossterm)"/><xsl:key name="glossentries" match="glossentry" use="normalize-space(glossterm/@baseform)"/><xsl:template name="simple.xlink">
  <xsl:param name="node" select="."/>
  <xsl:param name="content">
    <xsl:apply-templates/>
  </xsl:param>
  <xsl:param name="linkend" select="$node/@linkend"/>
  <xsl:param name="xhref" select="$node/@xlink:href"/>

  <!-- Support for @xlink:show -->
  <xsl:variable name="target.show">
    <xsl:choose>
      <xsl:when test="$node/@xlink:show = 'new'">_blank</xsl:when>
      <xsl:when test="$node/@xlink:show = 'replace'">_top</xsl:when>
      <xsl:otherwise/>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="link">
    <xsl:choose>
      <xsl:when test="$xhref and                        (not($node/@xlink:type) or                             $node/@xlink:type='simple')">

        <!-- Is it a local idref or a uri? -->
        <xsl:variable name="is.idref">
          <xsl:choose>
            <!-- if the href starts with # and does not contain an "(" -->
            <!-- or if the href starts with #xpointer(id(, it's just an ID -->
            <xsl:when test="starts-with($xhref,'#')                             and (not(contains($xhref,'('))                             or starts-with($xhref,                                        '#xpointer(id('))">1</xsl:when>
            <xsl:otherwise>0</xsl:otherwise>
          </xsl:choose>
        </xsl:variable>

        <!-- Is it an olink ? -->
        <xsl:variable name="is.olink">
          <xsl:choose>
            <!-- If xlink:role="http://docbook.org/xlink/role/olink" -->
            <!-- and if the href contains # -->
            <xsl:when test="contains($xhref,'#') and                  @xlink:role = $xolink.role">1</xsl:when>
            <xsl:otherwise>0</xsl:otherwise>
          </xsl:choose>
        </xsl:variable>

        <xsl:choose>
          <xsl:when test="$is.olink = 1">
            <xsl:call-template name="olink">
              <xsl:with-param name="content" select="$content"/>
            </xsl:call-template>
          </xsl:when>

          <xsl:when test="$is.idref = 1">

            <xsl:variable name="idref">
              <xsl:call-template name="xpointer.idref">
                <xsl:with-param name="xpointer" select="$xhref"/>
              </xsl:call-template>
            </xsl:variable>

            <xsl:variable name="targets" select="key('id',$idref)"/>
            <xsl:variable name="target" select="$targets[1]"/>

            <xsl:call-template name="check.id.unique">
              <xsl:with-param name="linkend" select="$idref"/>
            </xsl:call-template>

            <xsl:choose>
              <xsl:when test="count($target) = 0">
                <xsl:message>
                  <xsl:text>XLink to nonexistent id: </xsl:text>
                  <xsl:value-of select="$idref"/>
                </xsl:message>
                <xsl:copy-of select="$content"/>
              </xsl:when>

              <xsl:otherwise>
                <a>
                  <xsl:apply-templates select="." mode="common.html.attributes"/>
                  <xsl:call-template name="id.attribute"/>

                  <xsl:attribute name="href">
                    <xsl:call-template name="href.target">
                      <xsl:with-param name="object" select="$target"/>
                    </xsl:call-template>
                  </xsl:attribute>

                  <xsl:choose>
                    <xsl:when test="$node/@xlink:title">
                      <xsl:attribute name="title">
                        <xsl:value-of select="$node/@xlink:title"/>
                      </xsl:attribute>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:apply-templates select="$target" mode="html.title.attribute"/>
                    </xsl:otherwise>
                  </xsl:choose>

                  <xsl:if test="$target.show !=''">
                    <xsl:attribute name="target">
                      <xsl:value-of select="$target.show"/>
                    </xsl:attribute>
                  </xsl:if>

                  <xsl:copy-of select="$content"/>

                </a>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:when>

          <!-- otherwise it's a URI -->
          <xsl:otherwise>
            <a>
              <xsl:apply-templates select="." mode="common.html.attributes"/>
              <xsl:call-template name="id.attribute"/>
              <xsl:attribute name="href">
                <xsl:value-of select="$xhref"/>
              </xsl:attribute>
              <xsl:if test="$node/@xlink:title">
                <xsl:attribute name="title">
                  <xsl:value-of select="$node/@xlink:title"/>
                </xsl:attribute>
              </xsl:if>

              <!-- For URIs, use @xlink:show if defined, otherwise use ulink.target -->
              <xsl:choose>
                <xsl:when test="$target.show !=''">
                  <xsl:attribute name="target">
                    <xsl:value-of select="$target.show"/>
                  </xsl:attribute>
                </xsl:when>
                <xsl:when test="$ulink.target !=''">
                  <xsl:attribute name="target">
                    <xsl:value-of select="$ulink.target"/>
                  </xsl:attribute>
                </xsl:when>
              </xsl:choose>
              
              <xsl:copy-of select="$content"/>
            </a>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>

      <xsl:when test="$linkend">
        <xsl:variable name="targets" select="key('id',$linkend)"/>
        <xsl:variable name="target" select="$targets[1]"/>

        <xsl:call-template name="check.id.unique">
          <xsl:with-param name="linkend" select="$linkend"/>
        </xsl:call-template>

        <a>
          <xsl:apply-templates select="." mode="common.html.attributes"/>
          <xsl:call-template name="id.attribute"/>
          <xsl:attribute name="href">
            <xsl:call-template name="href.target">
              <xsl:with-param name="object" select="$target"/>
            </xsl:call-template>
          </xsl:attribute>

          <xsl:apply-templates select="$target" mode="html.title.attribute"/>

          <xsl:copy-of select="$content"/>
          
        </a>
      </xsl:when>
      <xsl:otherwise>
        <xsl:copy-of select="$content"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="function-available('suwl:unwrapLinks')">
      <xsl:copy-of select="suwl:unwrapLinks($link)"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="$link"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="inline.charseq">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:apply-templates/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:param>
  <!-- * if you want output from the inline.charseq template wrapped in -->
  <!-- * something other than a Span, call the template with some value -->
  <!-- * for the 'wrapper-name' param -->
  <xsl:param name="wrapper-name">span</xsl:param>
  <xsl:element name="{$wrapper-name}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:attribute name="class">
      <xsl:value-of select="local-name(.)"/>
    </xsl:attribute>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="dir"/>
    <xsl:call-template name="generate.html.title"/>
    <xsl:copy-of select="$content"/>
    <xsl:call-template name="apply-annotations"/>
  </xsl:element>
</xsl:template><xsl:template name="inline.monoseq">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:apply-templates/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:param>
  <code>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:copy-of select="$content"/>
    <xsl:call-template name="apply-annotations"/>
  </code>
</xsl:template><xsl:template name="inline.boldseq">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:apply-templates/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:param>

  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>

    <!-- don't put <strong> inside figure, example, or table titles -->
    <xsl:choose>
      <xsl:when test="local-name(..) = 'title'                       and (local-name(../..) = 'figure'                       or local-name(../..) = 'example'                       or local-name(../..) = 'table')">
        <xsl:copy-of select="$content"/>
      </xsl:when>
      <xsl:otherwise>
        <strong>
          <xsl:copy-of select="$content"/>
        </strong>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:call-template name="apply-annotations"/>
  </span>
</xsl:template><xsl:template name="inline.italicseq">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:apply-templates/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:param>
  <em>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:copy-of select="$content"/>
    <xsl:call-template name="apply-annotations"/>
  </em>
</xsl:template><xsl:template name="inline.boldmonoseq">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:apply-templates/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:param>
  <!-- don't put <strong> inside figure, example, or table titles -->
  <!-- or other titles that may already be represented with <strong>'s. -->
  <xsl:choose>
    <xsl:when test="local-name(..) = 'title'                     and (local-name(../..) = 'figure'                          or local-name(../..) = 'example'                          or local-name(../..) = 'table'                          or local-name(../..) = 'formalpara')">
      <code>
        <xsl:call-template name="common.html.attributes"/>
        <xsl:call-template name="id.attribute"/>
        <xsl:copy-of select="$content"/>
        <xsl:call-template name="apply-annotations"/>
      </code>
    </xsl:when>
    <xsl:otherwise>
      <strong>
        <xsl:call-template name="common.html.attributes"/>
        <xsl:call-template name="id.attribute"/>
        <code>
          <xsl:call-template name="generate.html.title"/>
          <xsl:call-template name="dir"/>
          <xsl:copy-of select="$content"/>
        </code>
        <xsl:call-template name="apply-annotations"/>
      </strong>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="inline.italicmonoseq">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:apply-templates/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:param>
  <em>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <code>
      <xsl:call-template name="generate.html.title"/>
      <xsl:call-template name="dir"/>
      <xsl:copy-of select="$content"/>
      <xsl:call-template name="apply-annotations"/>
    </code>
  </em>
</xsl:template><xsl:template name="inline.superscriptseq">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:apply-templates/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:param>
  <sup>
    <xsl:call-template name="generate.html.title"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="dir"/>
    <xsl:copy-of select="$content"/>
    <xsl:call-template name="apply-annotations"/>
  </sup>
</xsl:template><xsl:template name="inline.subscriptseq">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:apply-templates/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:param>
  <sub>
    <xsl:call-template name="generate.html.title"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="dir"/>
    <xsl:copy-of select="$content"/>
    <xsl:call-template name="apply-annotations"/>
  </sub>
</xsl:template><xsl:template match="author">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:call-template name="person.name"/>
      </xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="apply-annotations"/>
  </xsl:param>

  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:copy-of select="$content"/>
  </span>
</xsl:template><xsl:template match="editor">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:call-template name="person.name"/>
      </xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="apply-annotations"/>
  </xsl:param>

  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:copy-of select="$content"/>
  </span>
</xsl:template><xsl:template match="othercredit">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:call-template name="person.name"/>
      </xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="apply-annotations"/>
  </xsl:param>

  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:copy-of select="$content"/>
  </span>
</xsl:template><xsl:template match="authorinitials">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="accel">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="action">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="application">
  <xsl:call-template name="inline.boldseq"/>
</xsl:template><xsl:template match="classname">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="exceptionname">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="interfacename">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="methodname">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="command">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="computeroutput">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="constant">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="database">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="date">
  <!-- should this support locale-specific formatting? how? -->
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="errorcode">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="errorname">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="errortype">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="errortext">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="envar">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="filename">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="function">
  <xsl:choose>
    <xsl:when test="$function.parens != '0'                     and (parameter or function or replaceable)">
      <xsl:variable name="nodes" select="text()|*"/>
      <xsl:call-template name="inline.monoseq">
        <xsl:with-param name="content">
          <xsl:call-template name="simple.xlink">
            <xsl:with-param name="content">
              <xsl:apply-templates select="$nodes[1]"/>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:with-param>
      </xsl:call-template>
      <xsl:text>(</xsl:text>
      <xsl:apply-templates select="$nodes[position()&gt;1]"/>
      <xsl:text>)</xsl:text>
    </xsl:when>
    <xsl:otherwise>
     <xsl:call-template name="inline.monoseq"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="function/parameter" priority="2">
  <xsl:call-template name="inline.italicmonoseq"/>
  <xsl:if test="$function.parens != 0 and following-sibling::*">
    <xsl:text>, </xsl:text>
  </xsl:if>
</xsl:template><xsl:template match="function/replaceable" priority="2">
  <xsl:call-template name="inline.italicmonoseq"/>
  <xsl:if test="$function.parens != 0 and following-sibling::*">
    <xsl:text>, </xsl:text>
  </xsl:if>
</xsl:template><xsl:template match="guibutton">
  <xsl:call-template name="inline.boldseq"/>
</xsl:template><xsl:template match="guiicon">
  <xsl:call-template name="inline.boldseq"/>
</xsl:template><xsl:template match="guilabel">
  <xsl:call-template name="inline.boldseq"/>
</xsl:template><xsl:template match="guimenu">
  <xsl:call-template name="inline.boldseq"/>
</xsl:template><xsl:template match="guimenuitem">
  <xsl:call-template name="inline.boldseq"/>
</xsl:template><xsl:template match="guisubmenu">
  <xsl:call-template name="inline.boldseq"/>
</xsl:template><xsl:template match="hardware">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="interface">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="interfacedefinition">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="keycap">
  <xsl:choose>
    <xsl:when test="@function and normalize-space(.) = ''">
      <xsl:call-template name="inline.boldseq">
        <xsl:with-param name="content">
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="'keycap'"/>
            <xsl:with-param name="name" select="@function"/>
          </xsl:call-template>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="inline.boldseq"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="keycode">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="keysym">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="literal">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="code">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="medialabel">
  <xsl:call-template name="inline.italicseq"/>
</xsl:template><xsl:template match="shortcut">
  <xsl:call-template name="inline.boldseq"/>
</xsl:template><xsl:template match="mousebutton">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="option">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="package">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="parameter">
  <xsl:call-template name="inline.italicmonoseq"/>
</xsl:template><xsl:template match="property">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="prompt">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="replaceable" priority="1">
  <xsl:call-template name="inline.italicmonoseq"/>
</xsl:template><xsl:template match="returnvalue">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="structfield">
  <xsl:call-template name="inline.italicmonoseq"/>
</xsl:template><xsl:template match="structname">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="symbol">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="systemitem">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="token">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="type">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="userinput">
  <xsl:call-template name="inline.boldmonoseq"/>
</xsl:template><xsl:template match="abbrev">
  <xsl:call-template name="inline.charseq">
    <xsl:with-param name="wrapper-name">abbr</xsl:with-param>
  </xsl:call-template>
</xsl:template><xsl:template match="acronym">
  <xsl:call-template name="inline.charseq">
    <xsl:with-param name="wrapper-name">acronym</xsl:with-param>
  </xsl:call-template>
</xsl:template><xsl:template match="citerefentry">
  <xsl:choose>
    <xsl:when test="$citerefentry.link != '0'">
      <a>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:attribute name="href">
          <xsl:call-template name="generate.citerefentry.link"/>
        </xsl:attribute>
        <xsl:call-template name="inline.charseq"/>
      </a>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="inline.charseq"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="generate.citerefentry.link">
  <!-- nop -->
</xsl:template><xsl:template name="x.generate.citerefentry.link">
  <xsl:text>http://example.com/cgi-bin/man.cgi?</xsl:text>
  <xsl:value-of select="refentrytitle"/>
  <xsl:text>(</xsl:text>
  <xsl:value-of select="manvolnum"/>
  <xsl:text>)</xsl:text>
</xsl:template><xsl:template match="citetitle">
  <xsl:choose>
    <xsl:when test="@pubwork = 'article'">
      <xsl:call-template name="gentext.startquote"/>
      <xsl:call-template name="inline.charseq"/>
      <xsl:call-template name="gentext.endquote"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="inline.italicseq"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="emphasis">
  <span>
    <xsl:call-template name="id.attribute"/>
    <xsl:choose>
      <!-- We don't want empty @class values, so do not propagate empty @roles -->
      <xsl:when test="@role  and                       normalize-space(@role) != '' and                       $emphasis.propagates.style != 0">
        <xsl:apply-templates select="." mode="common.html.attributes">
          <xsl:with-param name="class" select="@role"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:call-template name="anchor"/>

    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:choose>
          <xsl:when test="@role = 'bold' or @role='strong'">
            <!-- backwards compatibility: make bold into b elements, but -->
            <!-- don't put bold inside figure, example, or table titles -->
            <xsl:choose>
              <xsl:when test="local-name(..) = 'title'                               and (local-name(../..) = 'figure'                               or local-name(../..) = 'example'                               or local-name(../..) = 'table')">
                <xsl:apply-templates/>
              </xsl:when>
              <xsl:otherwise>
                <strong><xsl:apply-templates/></strong>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:when>
          <xsl:when test="@role and $emphasis.propagates.style != 0">
            <xsl:apply-templates/>
          </xsl:when>
          <xsl:otherwise>
            <em><xsl:apply-templates/></em>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:with-param>
    </xsl:call-template>
  </span>
</xsl:template><xsl:template match="foreignphrase">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="inline.italicseq"/>
  </span>
</xsl:template><xsl:template match="markup">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="phrase">
  <span>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="locale.html.attributes"/>
    <!-- We don't want empty @class values, so do not propagate empty @roles -->
    <xsl:choose>
      <xsl:when test="@role and                       normalize-space(@role) != '' and                      $phrase.propagates.style != 0">
        <xsl:apply-templates select="." mode="class.attribute">
          <xsl:with-param name="class" select="@role"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="." mode="class.attribute"/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:call-template name="dir"/>
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:apply-templates/>
      </xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="apply-annotations"/>
  </span>
</xsl:template><xsl:template match="quote">
  <xsl:variable name="depth">
    <xsl:call-template name="dot.count">
      <xsl:with-param name="string">
        <xsl:number level="multiple"/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:variable>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:choose>
      <xsl:when test="$depth mod 2 = 0">
        <xsl:call-template name="gentext.startquote"/>
        <xsl:call-template name="inline.charseq"/>
        <xsl:call-template name="gentext.endquote"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="gentext.nestedstartquote"/>
        <xsl:call-template name="inline.charseq"/>
        <xsl:call-template name="gentext.nestedendquote"/>
      </xsl:otherwise>
    </xsl:choose>
  </span>
</xsl:template><xsl:template match="varname">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="wordasword">
  <xsl:call-template name="inline.italicseq"/>
</xsl:template><xsl:template match="lineannotation">
  <em>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="inline.charseq"/>
  </em>
</xsl:template><xsl:template match="superscript">
  <xsl:call-template name="inline.superscriptseq"/>
</xsl:template><xsl:template match="subscript">
  <xsl:call-template name="inline.subscriptseq"/>
</xsl:template><xsl:template match="trademark">
  <xsl:call-template name="inline.charseq"/>
  <xsl:choose>
    <xsl:when test="@class = 'copyright'                     or @class = 'registered'">
      <xsl:call-template name="dingbat">
        <xsl:with-param name="dingbat" select="@class"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="@class = 'service'">
      <sup>SM</sup>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="dingbat">
        <xsl:with-param name="dingbat" select="'trademark'"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="firstterm">
  <xsl:call-template name="glossterm">
    <xsl:with-param name="firstterm" select="1"/>
  </xsl:call-template>
</xsl:template><xsl:template match="glossterm" name="glossterm">
  <xsl:param name="firstterm" select="0"/>

  <!-- To avoid extra <a name=""> anchor from inline.italicseq -->
  <xsl:variable name="content">
    <xsl:apply-templates/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="($firstterm.only.link = 0 or $firstterm = 1) and @linkend">
      <xsl:variable name="targets" select="key('id',@linkend)"/>
      <xsl:variable name="target" select="$targets[1]"/>

      <xsl:call-template name="check.id.unique">
        <xsl:with-param name="linkend" select="@linkend"/>
      </xsl:call-template>

      <xsl:choose>
        <xsl:when test="$target">
          <a>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:if test="@id or @xml:id">
              <xsl:attribute name="id">
                <xsl:value-of select="(@id|@xml:id)[1]"/>
              </xsl:attribute>
            </xsl:if>

            <xsl:attribute name="href">
              <xsl:call-template name="href.target">
                <xsl:with-param name="object" select="$target"/>
              </xsl:call-template>
            </xsl:attribute>

            <xsl:call-template name="inline.italicseq">
              <xsl:with-param name="content" select="$content"/>
            </xsl:call-template>
          </a>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="inline.italicseq">
            <xsl:with-param name="content" select="$content"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>

    <xsl:when test="not(@linkend)                     and ($firstterm.only.link = 0 or $firstterm = 1)                     and ($glossterm.auto.link != 0)                     and $glossary.collection != ''">
      <xsl:variable name="term">
        <xsl:choose>
          <xsl:when test="@baseform"><xsl:value-of select="@baseform"/></xsl:when>
          <xsl:otherwise><xsl:value-of select="."/></xsl:otherwise>
        </xsl:choose>
      </xsl:variable>

      <xsl:variable name="cterm" select="(document($glossary.collection,.)//glossentry[glossterm=$term])[1]"/>

      <!-- HACK HACK HACK! But it works... -->
      <!-- You'd need to do more work if you wanted to chunk on glossdiv, though -->

      <xsl:variable name="glossary" select="//glossary[@role='auto']"/>

      <xsl:if test="count($glossary) != 1">
        <xsl:message>
          <xsl:text>Warning: glossary.collection specified, but there are </xsl:text>
          <xsl:value-of select="count($glossary)"/>
          <xsl:text> automatic glossaries</xsl:text>
        </xsl:message>
      </xsl:if>

      <xsl:variable name="glosschunk">
        <xsl:call-template name="href.target">
          <xsl:with-param name="object" select="$glossary"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:variable name="chunkbase">
        <xsl:choose>
          <xsl:when test="contains($glosschunk, '#')">
            <xsl:value-of select="substring-before($glosschunk, '#')"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$glosschunk"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>

      <xsl:choose>
        <xsl:when test="not($cterm)">
          <xsl:message>
            <xsl:text>There's no entry for </xsl:text>
            <xsl:value-of select="$term"/>
            <xsl:text> in </xsl:text>
            <xsl:value-of select="$glossary.collection"/>
          </xsl:message>
          <xsl:call-template name="inline.italicseq"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="id">
            <xsl:call-template name="object.id">
              <xsl:with-param name="object" select="$cterm"/>
            </xsl:call-template>
          </xsl:variable>
          <a href="{$chunkbase}#{$id}">
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="inline.italicseq">
              <xsl:with-param name="content" select="$content"/>
            </xsl:call-template>
          </a>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>

    <xsl:when test="not(@linkend)                     and ($firstterm.only.link = 0 or $firstterm = 1)                     and $glossterm.auto.link != 0">
      <xsl:variable name="term">
        <xsl:choose>
          <xsl:when test="@baseform">
            <xsl:value-of select="normalize-space(@baseform)"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="normalize-space(.)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <xsl:variable name="targets" select="key('glossentries', $term)"/>
      <xsl:variable name="target" select="$targets[1]"/>

      <xsl:choose>
        <xsl:when test="count($targets)=0">
          <xsl:message>
            <xsl:text>Error: no glossentry for glossterm: </xsl:text>
            <xsl:value-of select="."/>
            <xsl:text>.</xsl:text>
          </xsl:message>
          <xsl:call-template name="inline.italicseq"/>
        </xsl:when>
        <xsl:otherwise>
          <a>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:if test="@id or @xml:id">
              <xsl:attribute name="id">
                <xsl:value-of select="(@id|@xml:id)[1]"/>
              </xsl:attribute>
            </xsl:if>

            <xsl:attribute name="href">
              <xsl:call-template name="href.target">
                <xsl:with-param name="object" select="$target"/>
              </xsl:call-template>
            </xsl:attribute>

            <xsl:call-template name="inline.italicseq">
              <xsl:with-param name="content" select="$content"/>
            </xsl:call-template>
          </a>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>

    <xsl:otherwise>
      <xsl:call-template name="inline.italicseq"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="termdef">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="gentext.template">
      <xsl:with-param name="context" select="'termdef'"/>
      <xsl:with-param name="name" select="'prefix'"/>
    </xsl:call-template>
    <xsl:apply-templates/>
    <xsl:call-template name="gentext.template">
      <xsl:with-param name="context" select="'termdef'"/>
      <xsl:with-param name="name" select="'suffix'"/>
    </xsl:call-template>
  </span>
</xsl:template><xsl:template match="sgmltag|tag">
  <xsl:call-template name="format.sgmltag"/>
</xsl:template><xsl:template name="format.sgmltag">
  <xsl:param name="class">
    <xsl:choose>
      <xsl:when test="@class">
        <xsl:value-of select="@class"/>
      </xsl:when>
      <xsl:otherwise>element</xsl:otherwise>
    </xsl:choose>
  </xsl:param>

  <xsl:variable name="content">
    <xsl:choose>
      <xsl:when test="$class='attribute'">
        <xsl:apply-templates/>
      </xsl:when>
      <xsl:when test="$class='attvalue'">
        <xsl:apply-templates/>
      </xsl:when>
      <xsl:when test="$class='element'">
        <xsl:apply-templates/>
      </xsl:when>
      <xsl:when test="$class='endtag'">
        <xsl:text>&lt;/</xsl:text>
        <xsl:apply-templates/>
        <xsl:text>&gt;</xsl:text>
      </xsl:when>
      <xsl:when test="$class='genentity'">
        <xsl:text>&amp;</xsl:text>
        <xsl:apply-templates/>
        <xsl:text>;</xsl:text>
      </xsl:when>
      <xsl:when test="$class='numcharref'">
        <xsl:text>&amp;#</xsl:text>
        <xsl:apply-templates/>
        <xsl:text>;</xsl:text>
      </xsl:when>
      <xsl:when test="$class='paramentity'">
        <xsl:text>%</xsl:text>
        <xsl:apply-templates/>
        <xsl:text>;</xsl:text>
      </xsl:when>
      <xsl:when test="$class='pi'">
        <xsl:text>&lt;?</xsl:text>
        <xsl:apply-templates/>
        <xsl:text>&gt;</xsl:text>
      </xsl:when>
      <xsl:when test="$class='xmlpi'">
        <xsl:text>&lt;?</xsl:text>
        <xsl:apply-templates/>
        <xsl:text>?&gt;</xsl:text>
      </xsl:when>
      <xsl:when test="$class='starttag'">
        <xsl:text>&lt;</xsl:text>
        <xsl:apply-templates/>
        <xsl:text>&gt;</xsl:text>
      </xsl:when>
      <xsl:when test="$class='emptytag'">
        <xsl:text>&lt;</xsl:text>
        <xsl:apply-templates/>
        <xsl:text>/&gt;</xsl:text>
      </xsl:when>
      <xsl:when test="$class='sgmlcomment' or $class='comment'">
        <xsl:text>&lt;!--</xsl:text>
        <xsl:apply-templates/>
        <xsl:text>--&gt;</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <code>
    <xsl:apply-templates select="." mode="common.html.attributes">
      <xsl:with-param name="class" select="concat('sgmltag-', $class)"/>
    </xsl:apply-templates>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content" select="$content"/>
    </xsl:call-template>
  </code>
</xsl:template><xsl:template match="email">
  <xsl:call-template name="inline.monoseq">
    <xsl:with-param name="content">
      <xsl:if test="not($email.delimiters.enabled = 0)">
        <xsl:text>&lt;</xsl:text>
      </xsl:if>
      <a>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:call-template name="id.attribute"/>
        <xsl:attribute name="href">
          <xsl:text>mailto:</xsl:text>
          <xsl:value-of select="."/>
        </xsl:attribute>
        <xsl:apply-templates/>
      </a>
      <xsl:if test="not($email.delimiters.enabled = 0)">
        <xsl:text>&gt;</xsl:text>
      </xsl:if>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template><xsl:template match="keycombo">
  <xsl:variable name="action" select="@action"/>
  <xsl:variable name="joinchar">
    <xsl:choose>
      <xsl:when test="$action='seq'"><xsl:text> </xsl:text></xsl:when>
      <xsl:when test="$action='simul'">+</xsl:when>
      <xsl:when test="$action='press'">-</xsl:when>
      <xsl:when test="$action='click'">-</xsl:when>
      <xsl:when test="$action='double-click'">-</xsl:when>
      <xsl:when test="$action='other'"/>
      <xsl:otherwise>+</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:for-each select="*">
    <xsl:if test="position()&gt;1"><xsl:value-of select="$joinchar"/></xsl:if>
    <xsl:apply-templates select="."/>
  </xsl:for-each>
</xsl:template><xsl:template match="uri">
  <xsl:call-template name="inline.monoseq"/>
</xsl:template><xsl:template match="menuchoice">
  <xsl:variable name="shortcut" select="./shortcut"/>
  <xsl:call-template name="process.menuchoice"/>
  <xsl:if test="$shortcut">
    <xsl:text> (</xsl:text>
    <xsl:apply-templates select="$shortcut"/>
    <xsl:text>)</xsl:text>
  </xsl:if>
</xsl:template><xsl:template name="process.menuchoice">
  <xsl:param name="nodelist" select="guibutton|guiicon|guilabel|guimenu|guimenuitem|guisubmenu|interface"/><!-- not(shortcut) -->
  <xsl:param name="count" select="1"/>

  <xsl:choose>
    <xsl:when test="$count&gt;count($nodelist)"/>
    <xsl:when test="$count=1">
      <xsl:apply-templates select="$nodelist[$count=position()]"/>
      <xsl:call-template name="process.menuchoice">
        <xsl:with-param name="nodelist" select="$nodelist"/>
        <xsl:with-param name="count" select="$count+1"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="node" select="$nodelist[$count=position()]"/>
      <xsl:choose>
        <xsl:when test="local-name($node)='guimenuitem'                         or local-name($node)='guisubmenu'">
          <xsl:value-of select="$menuchoice.menu.separator"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$menuchoice.separator"/>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:apply-templates select="$node"/>
      <xsl:call-template name="process.menuchoice">
        <xsl:with-param name="nodelist" select="$nodelist"/>
        <xsl:with-param name="count" select="$count+1"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="optional">
  <xsl:value-of select="$arg.choice.opt.open.str"/>
  <xsl:call-template name="inline.charseq"/>
  <xsl:value-of select="$arg.choice.opt.close.str"/>
</xsl:template><xsl:template match="citation">
  <!-- todo: integrate with bibliography collection -->
  <xsl:variable name="targets" select="(//biblioentry | //bibliomixed)[abbrev = string(current())]"/>
  <xsl:variable name="target" select="$targets[1]"/>

  <xsl:choose>
    <!-- try automatic linking based on match to abbrev -->
    <xsl:when test="$target and not(xref) and not(link)">

      <xsl:text>[</xsl:text>
      <a>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:attribute name="href">
          <xsl:call-template name="href.target">
            <xsl:with-param name="object" select="$target"/>
          </xsl:call-template>
        </xsl:attribute>

        <xsl:choose>
          <xsl:when test="$bibliography.numbered != 0">
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates select="$target" mode="citation"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="inline.charseq"/>
          </xsl:otherwise>
        </xsl:choose>

      </a>
      <xsl:text>]</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>[</xsl:text>
      <xsl:call-template name="inline.charseq"/>
      <xsl:text>]</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="citebiblioid">
  <xsl:variable name="targets" select="//*[biblioid = string(current())]"/>
  <xsl:variable name="target" select="$targets[1]"/>

  <xsl:choose>
    <!-- try automatic linking based on match to parent of biblioid -->
    <xsl:when test="$target and not(xref) and not(link)">

      <xsl:text>[</xsl:text>
      <a>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:attribute name="href">
          <xsl:call-template name="href.target">
            <xsl:with-param name="object" select="$target"/>
          </xsl:call-template>
        </xsl:attribute>

        <xsl:call-template name="inline.charseq"/>

      </a>
      <xsl:text>]</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>[</xsl:text>
      <xsl:call-template name="inline.charseq"/>
      <xsl:text>]</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="biblioentry|bibliomixed" mode="citation">
  <xsl:number from="bibliography" count="biblioentry|bibliomixed" level="any" format="1"/>
</xsl:template><xsl:template match="comment[parent::answer|parent::appendix|parent::article|parent::bibliodiv|                                 parent::bibliography|parent::blockquote|parent::caution|parent::chapter|                                 parent::glossary|parent::glossdiv|parent::important|parent::index|                                 parent::indexdiv|parent::listitem|parent::note|parent::orderedlist|                                 parent::partintro|parent::preface|parent::procedure|parent::qandadiv|                                 parent::qandaset|parent::question|parent::refentry|parent::refnamediv|                                 parent::refsect1|parent::refsect2|parent::refsect3|parent::refsection|                                 parent::refsynopsisdiv|parent::sect1|parent::sect2|parent::sect3|parent::sect4|                                 parent::sect5|parent::section|parent::setindex|parent::sidebar|                                 parent::simplesect|parent::taskprerequisites|parent::taskrelated|                                 parent::tasksummary|parent::warning|parent::topic]|remark[parent::answer|parent::appendix|parent::article|parent::bibliodiv|                                 parent::bibliography|parent::blockquote|parent::caution|parent::chapter|                                 parent::glossary|parent::glossdiv|parent::important|parent::index|                                 parent::indexdiv|parent::listitem|parent::note|parent::orderedlist|                                 parent::partintro|parent::preface|parent::procedure|parent::qandadiv|                                 parent::qandaset|parent::question|parent::refentry|parent::refnamediv|                                 parent::refsect1|parent::refsect2|parent::refsect3|parent::refsection|                                 parent::refsynopsisdiv|parent::sect1|parent::sect2|parent::sect3|parent::sect4|                                 parent::sect5|parent::section|parent::setindex|parent::sidebar|                                 parent::simplesect|parent::taskprerequisites|parent::taskrelated|                                 parent::tasksummary|parent::warning|parent::topic]">
  <xsl:if test="$show.comments != 0">
    <p class="remark"><em><xsl:call-template name="inline.charseq"/></em></p>
  </xsl:if>
</xsl:template><xsl:template match="comment|remark">
  <xsl:if test="$show.comments != 0">
    <em><xsl:call-template name="inline.charseq"/></em>
  </xsl:if>
</xsl:template><xsl:template match="productname">
  <xsl:call-template name="inline.charseq"/>
  <xsl:if test="@class">
    <xsl:call-template name="dingbat">
      <xsl:with-param name="dingbat" select="@class"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template match="productnumber">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="pob|street|city|state|postcode|country|otheraddr">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="phone|fax">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="honorific|firstname|surname|lineage|othername">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="person">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:apply-templates select="personname"/>
      </xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="apply-annotations"/>
  </xsl:param>

  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:copy-of select="$content"/>
  </span>
</xsl:template><xsl:template match="personname">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:call-template name="person.name"/>
      </xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="apply-annotations"/>
  </xsl:param>

  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:copy-of select="$content"/>
  </span>
</xsl:template><xsl:template match="org">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:apply-templates/>
      </xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="apply-annotations"/>
  </xsl:param>

  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:copy-of select="$content"/>
  </span>
</xsl:template><xsl:template match="orgname">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:apply-templates/>
      </xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="apply-annotations"/>
  </xsl:param>

  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:copy-of select="$content"/>
  </span>
</xsl:template><xsl:template match="orgdiv">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:apply-templates/>
      </xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="apply-annotations"/>
  </xsl:param>

  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:copy-of select="$content"/>
  </span>
</xsl:template><xsl:template match="affiliation">
  <xsl:param name="content">
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="simple.xlink">
      <xsl:with-param name="content">
        <xsl:call-template name="person.name"/>
      </xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="apply-annotations"/>
  </xsl:param>

  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:copy-of select="$content"/>
  </span>
</xsl:template><xsl:template match="beginpage">
  <!-- does nothing; this *is not* markup to force a page break. -->
</xsl:template>
<xsl:template match="footnoteref">
  <xsl:variable name="targets" select="key('id',@linkend)"/>
  <xsl:variable name="footnote" select="$targets[1]"/>

  <xsl:if test="not(local-name($footnote) = 'footnote')">
   <xsl:message terminate="yes">
ERROR: A footnoteref element has a linkend that points to an element that is not a footnote. 
Typically this happens when an id attribute is accidentally applied to the child of a footnote element. 
target element: <xsl:value-of select="local-name($footnote)"/>
linkend/id: <xsl:value-of select="@linkend"/>
   </xsl:message>
  </xsl:if>

  <xsl:variable name="target.href">
    <xsl:call-template name="href.target">
      <xsl:with-param name="object" select="$footnote"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="href">
    <xsl:value-of select="substring-before($target.href, '#')"/>
    <xsl:text>#ftn.</xsl:text>
    <xsl:value-of select="substring-after($target.href, '#')"/>
  </xsl:variable>

  <a href="{$href}">
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:call-template name="id.attribute"/>
    <sup>
      <xsl:apply-templates select="." mode="class.attribute"/>
      <xsl:text>[</xsl:text>
      <xsl:apply-templates select="$footnote" mode="footnote.number"/>
      <xsl:text>]</xsl:text>
    </sup>
  </a>
</xsl:template><xsl:template match="footnote" mode="footnote.number">
  <xsl:choose>
    <xsl:when test="string-length(@label) != 0">
      <xsl:value-of select="@label"/>
    </xsl:when>
    <xsl:when test="ancestor::table or ancestor::informaltable">
      <xsl:variable name="tfnum">
        <xsl:number level="any" from="table|informaltable" format="1"/>
      </xsl:variable>

      <xsl:choose>
        <xsl:when test="string-length($table.footnote.number.symbols) &gt;= $tfnum">
          <xsl:value-of select="substring($table.footnote.number.symbols, $tfnum, 1)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number level="any" from="table | informaltable" format="{$table.footnote.number.format}"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="pfoot" select="preceding::footnote[not(@label)]"/>
      <xsl:variable name="ptfoot" select="preceding::table//footnote |                                           preceding::informaltable//footnote"/>
      <xsl:variable name="fnum" select="count($pfoot) - count($ptfoot) + 1"/>

      <xsl:choose>
        <xsl:when test="string-length($footnote.number.symbols) &gt;= $fnum">
          <xsl:value-of select="substring($footnote.number.symbols, $fnum, 1)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number value="$fnum" format="{$footnote.number.format}"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="footnote/para[1]|footnote/simpara[1]" priority="2">
  <!-- this only works if the first thing in a footnote is a para, -->
  <!-- which is ok, because it usually is. -->
  <xsl:variable name="href">
    <xsl:text>#</xsl:text>
    <xsl:call-template name="object.id">
      <xsl:with-param name="object" select="ancestor::footnote"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:call-template name="paragraph">
    <xsl:with-param name="class">
      <xsl:if test="@role and $para.propagates.style != 0">
        <xsl:value-of select="@role"/>
      </xsl:if>
    </xsl:with-param>
    <xsl:with-param name="content">
      <a href="{$href}">
        <xsl:apply-templates select="." mode="class.attribute"/>
        <sup>
          <xsl:apply-templates select="." mode="class.attribute"/>
          <xsl:text>[</xsl:text>
          <xsl:apply-templates select="ancestor::footnote" mode="footnote.number"/>
          <xsl:text>] </xsl:text>
        </sup>
      </a>
      <xsl:apply-templates/>
    </xsl:with-param>
  </xsl:call-template>

</xsl:template><xsl:template match="*" mode="footnote.body.number">
  <xsl:variable name="name">
    <xsl:text>ftn.</xsl:text>
    <xsl:call-template name="object.id">
      <xsl:with-param name="object" select="ancestor::footnote"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="href">
    <xsl:text>#</xsl:text>
    <xsl:call-template name="object.id">
      <xsl:with-param name="object" select="ancestor::footnote"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="footnote.mark">
    <a href="{$href}">
      <xsl:apply-templates select="." mode="class.attribute"/>
      <xsl:choose>
        <xsl:when test="$generate.id.attributes = 0">
          <xsl:if test="@id or @xml:id">
            <xsl:attribute name="id">
              <xsl:value-of select="@id|@xml:id"/>
            </xsl:attribute>
          </xsl:if>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="id.attribute"/>
        </xsl:otherwise>
      </xsl:choose>
      <sup>
        <xsl:text>[</xsl:text>
        <xsl:apply-templates select="ancestor::footnote" mode="footnote.number"/>
        <xsl:text>] </xsl:text>
      </sup>
    </a>
  </xsl:variable>

  <xsl:variable name="html">
    <xsl:apply-templates select="."/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$exsl.node.set.available != 0">
      <xsl:variable name="html-nodes" select="exsl:node-set($html)"/>
      <xsl:choose>
        <xsl:when test="$html-nodes//p">
          <xsl:apply-templates select="$html-nodes" mode="insert.html.p">
            <xsl:with-param name="mark" select="$footnote.mark"/>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="$html-nodes" mode="insert.html.text">
            <xsl:with-param name="mark" select="$footnote.mark"/>
          </xsl:apply-templates>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="$html"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="process.footnotes">
  <xsl:variable name="footnotes" select=".//footnote"/>
  <xsl:variable name="table.footnotes" select=".//table//footnote | .//informaltable//footnote"/>

  <!-- Only bother to do this if there's at least one non-table footnote -->
  <xsl:if test="count($footnotes)&gt;count($table.footnotes)">
    <div class="footnotes">
      <xsl:call-template name="footnotes.attributes"/>
      <br/>
      <hr>
        <xsl:choose>
          <xsl:when test="$make.clean.html != 0">
            <xsl:attribute name="class">footnote-hr</xsl:attribute>
          </xsl:when>
          <xsl:when test="$css.decoration != 0">
            <xsl:attribute name="style">
              <xsl:value-of select="concat('width:100; text-align:',                                             $direction.align.start,                                             ';',          'margin-', $direction.align.start, ': 0')"/>
            </xsl:attribute>
          </xsl:when>
          <xsl:otherwise>
            <xsl:attribute name="width">100</xsl:attribute>
            <xsl:attribute name="align"><xsl:value-of select="$direction.align.start"/></xsl:attribute>
          </xsl:otherwise>
        </xsl:choose>
      </hr>
      <xsl:apply-templates select="$footnotes" mode="process.footnote.mode"/>
    </div>
  </xsl:if>

  <xsl:if test="$annotation.support != 0 and //annotation">
    <div class="annotation-list">
      <div class="annotation-nocss">
	<p>The following annotations are from this essay. You are seeing
	them here because your browser doesnâ€™t support the user-interface
	techniques used to make them appear as â€˜popupsâ€™ on modern browsers.</p>
      </div>

      <xsl:apply-templates select="//annotation" mode="annotation-popup"/>
    </div>
  </xsl:if>
</xsl:template><xsl:template name="footnotes.attributes">
  <!-- customizable for footnotes attributes -->
</xsl:template><xsl:template name="process.chunk.footnotes">
  <!-- nop -->
</xsl:template><xsl:template match="footnote" name="process.footnote" mode="process.footnote.mode">
  <xsl:variable name="id">
    <xsl:text>ftn.</xsl:text>
    <xsl:call-template name="object.id">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="local-name(*[1]) = 'para' or local-name(*[1]) = 'simpara'">
      <div id="{$id}">
        <xsl:call-template name="common.html.attributes"/>
        <xsl:apply-templates/>
      </div>
    </xsl:when>

    <xsl:when test="$html.cleanup != 0 and                      $exsl.node.set.available != 0">
      <div id="{$id}">
        <xsl:call-template name="common.html.attributes"/>
        <xsl:call-template name="id.attribute"/>
        <xsl:apply-templates select="*[1]" mode="footnote.body.number"/>
        <xsl:apply-templates select="*[position() &gt; 1]"/>
      </div>
    </xsl:when>

    <xsl:otherwise>
      <xsl:message>
        <xsl:text>Warning: footnote number may not be generated </xsl:text>
        <xsl:text>correctly; </xsl:text>
        <xsl:value-of select="local-name(*[1])"/>
        <xsl:text> unexpected as first child of footnote.</xsl:text>
      </xsl:message>
      <div id="{$id}">
        <xsl:call-template name="common.html.attributes"/>
        <xsl:call-template name="id.attribute"/>
        <xsl:apply-templates/>
      </div>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="table//footnote | informaltable//footnote" mode="process.footnote.mode">
</xsl:template>

<xsl:template match="footnote" mode="table.footnote.mode">
  <xsl:call-template name="process.footnote"/>
</xsl:template>

<xsl:variable name="direction.align.start">
  <xsl:choose>
    <xsl:when test="starts-with($writing.mode, 'lr')">left</xsl:when>
    <xsl:when test="starts-with($writing.mode, 'rl')">right</xsl:when>
    <xsl:otherwise>left</xsl:otherwise>
  </xsl:choose>
</xsl:variable>
<xsl:variable name="direction.align.end">
  <xsl:choose>
    <xsl:when test="starts-with($writing.mode, 'lr')">right</xsl:when>
    <xsl:when test="starts-with($writing.mode, 'rl')">left</xsl:when>
    <xsl:otherwise>right</xsl:otherwise>
  </xsl:choose>
</xsl:variable>
<xsl:variable name="direction.mode">
  <xsl:choose>
    <xsl:when test="starts-with($writing.mode, 'lr')">ltr</xsl:when>
    <xsl:when test="starts-with($writing.mode, 'rl')">rtl</xsl:when>
    <xsl:otherwise>ltr</xsl:otherwise>
  </xsl:choose>
</xsl:variable>
<xsl:variable name="div.element">div</xsl:variable>
<xsl:variable name="table.border.off">0</xsl:variable>
<xsl:template name="generate.html.title">
  <xsl:apply-templates select="." mode="html.title.attribute"/>
</xsl:template>
<xsl:template match="acronym|abbrev" mode="html.title.attribute">
  <xsl:if test="alt">
    <xsl:attribute name="title">
      <xsl:value-of select="normalize-space(alt)"/>
    </xsl:attribute>
  </xsl:if>
</xsl:template>
<xsl:template match="qandaentry" mode="html.title.attribute">
  <xsl:apply-templates select="question" mode="html.title.attribute"/>
</xsl:template><xsl:template match="question" mode="html.title.attribute">
  <xsl:variable name="label.text">
    <xsl:apply-templates select="." mode="qanda.label"/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="string-length($label.text) != 0">
      <xsl:attribute name="title">
        <xsl:value-of select="$label.text"/>
      </xsl:attribute>
    </xsl:when>
    <!-- Fall back to alt if available -->
    <xsl:when test="alt">
      <xsl:attribute name="title">
        <xsl:value-of select="normalize-space(alt)"/>
      </xsl:attribute>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template name="dir">
  <xsl:param name="inherit" select="0"/>

  <xsl:variable name="dir">
    <xsl:choose>
      <xsl:when test="@dir">
        <xsl:value-of select="@dir"/>
      </xsl:when>
      <xsl:when test="$inherit != 0">
        <xsl:value-of select="ancestor::*/@dir[1]"/>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:if test="$dir != ''">
    <xsl:attribute name="dir">
      <xsl:value-of select="$dir"/>
    </xsl:attribute>
  </xsl:if>
</xsl:template><xsl:template name="anchor">
  <xsl:param name="node" select="."/>
  <xsl:param name="conditional" select="1"/>

  <xsl:choose>
    <xsl:when test="$generate.id.attributes != 0">
      <!-- No named anchors output when this param is set -->
    </xsl:when>
    <xsl:when test="$conditional = 0 or $node/@id or $node/@xml:id">
      <a>
        <xsl:attribute name="id">
          <xsl:call-template name="object.id">
            <xsl:with-param name="object" select="$node"/>
          </xsl:call-template>
        </xsl:attribute>
      </a>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template name="id.attribute">
  <xsl:param name="node" select="."/>
  <xsl:param name="conditional" select="1"/>
  <xsl:choose>
    <xsl:when test="$generate.id.attributes = 0">
      <!-- No id attributes when this param is zero -->
    </xsl:when>
    <xsl:when test="$conditional = 0 or $node/@id or $node/@xml:id">
      <xsl:attribute name="id">
        <xsl:call-template name="object.id">
          <xsl:with-param name="object" select="$node"/>
        </xsl:call-template>
      </xsl:attribute>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template name="href.target.uri">
  <xsl:param name="context" select="."/>
  <xsl:param name="object" select="."/>
  <xsl:text>#</xsl:text>
  <xsl:call-template name="object.id">
    <xsl:with-param name="object" select="$object"/>
  </xsl:call-template>
</xsl:template><xsl:template name="href.target">
  <xsl:param name="context" select="."/>
  <xsl:param name="object" select="."/>
  <xsl:text>#</xsl:text>
  <xsl:call-template name="object.id">
    <xsl:with-param name="object" select="$object"/>
  </xsl:call-template>
</xsl:template><xsl:template name="href.target.with.base.dir">
  <xsl:param name="context" select="."/>
  <xsl:param name="object" select="."/>
  <xsl:if test="$manifest.in.base.dir = 0">
    <xsl:value-of select="$chunk.base.dir"/>
  </xsl:if>
  <xsl:call-template name="href.target">
    <xsl:with-param name="context" select="$context"/>
    <xsl:with-param name="object" select="$object"/>
  </xsl:call-template>
</xsl:template><xsl:template name="dingbat">
  <xsl:param name="dingbat">bullet</xsl:param>
  <xsl:call-template name="dingbat.characters">
    <xsl:with-param name="dingbat" select="$dingbat"/>
  </xsl:call-template>
</xsl:template><xsl:template name="dingbat.characters">
  <!-- now that I'm using the real serializer, all that dingbat malarky -->
  <!-- isn't necessary anymore... -->
  <xsl:param name="dingbat">bullet</xsl:param>
  <xsl:choose>
    <xsl:when test="$dingbat='bullet'">â€¢</xsl:when>
    <xsl:when test="$dingbat='copyright'">Â©</xsl:when>
    <xsl:when test="$dingbat='trademark'">â„¢</xsl:when>
    <xsl:when test="$dingbat='trade'">â„¢</xsl:when>
    <xsl:when test="$dingbat='registered'">Â®</xsl:when>
    <xsl:when test="$dingbat='service'">(SM)</xsl:when>
    <xsl:when test="$dingbat='nbsp'">Â </xsl:when>
    <xsl:when test="$dingbat='ldquo'">â€œ</xsl:when>
    <xsl:when test="$dingbat='rdquo'">â€</xsl:when>
    <xsl:when test="$dingbat='lsquo'">â€˜</xsl:when>
    <xsl:when test="$dingbat='rsquo'">â€™</xsl:when>
    <xsl:when test="$dingbat='em-dash'">â€”</xsl:when>
    <xsl:when test="$dingbat='mdash'">â€”</xsl:when>
    <xsl:when test="$dingbat='en-dash'">â€“</xsl:when>
    <xsl:when test="$dingbat='ndash'">â€“</xsl:when>
    <xsl:otherwise>
      <xsl:text>â€¢</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="id.warning">
  <xsl:if test="$id.warnings != 0 and not(@id) and not(@xml:id) and parent::*">
    <xsl:variable name="title">
      <xsl:choose>
        <xsl:when test="title">
          <xsl:value-of select="title[1]"/>
        </xsl:when>
        <xsl:when test="substring(local-name(*[1]),                                   string-length(local-name(*[1])-3) = 'info')                         and *[1]/title">
          <xsl:value-of select="*[1]/title[1]"/>
        </xsl:when>
        <xsl:when test="refmeta/refentrytitle">
          <xsl:value-of select="refmeta/refentrytitle"/>
        </xsl:when>
        <xsl:when test="refnamediv/refname">
          <xsl:value-of select="refnamediv/refname[1]"/>
        </xsl:when>
      </xsl:choose>
    </xsl:variable>

    <xsl:message>
      <xsl:text>ID recommended on </xsl:text>
      <xsl:value-of select="local-name(.)"/>
      <xsl:if test="$title != ''">
        <xsl:text>: </xsl:text>
        <xsl:choose>
          <xsl:when test="string-length($title) &gt; 40">
            <xsl:value-of select="substring($title,1,40)"/>
            <xsl:text>...</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$title"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
    </xsl:message>
  </xsl:if>
</xsl:template><xsl:template name="generate.class.attribute">
  <xsl:param name="class" select="local-name(.)"/>
  <xsl:apply-templates select="." mode="class.attribute">
    <xsl:with-param name="class" select="$class"/>
  </xsl:apply-templates>
</xsl:template>
<xsl:template match="*" mode="class.value">
  <xsl:param name="class" select="local-name(.)"/>
  <!-- permit customization of class value only -->
  <!-- Use element name by default -->
  <xsl:value-of select="$class"/>
</xsl:template><xsl:template name="common.html.attributes">
  <xsl:param name="inherit" select="0"/>
  <xsl:param name="class" select="local-name(.)"/>
  <xsl:apply-templates select="." mode="common.html.attributes">
    <xsl:with-param name="class" select="$class"/>
    <xsl:with-param name="inherit" select="$inherit"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="*" mode="common.html.attributes">
  <xsl:param name="class" select="local-name(.)"/>
  <xsl:param name="inherit" select="0"/>
  <xsl:call-template name="generate.html.lang"/>
  <xsl:call-template name="dir">
    <xsl:with-param name="inherit" select="$inherit"/>
  </xsl:call-template>
  <xsl:apply-templates select="." mode="class.attribute">
    <xsl:with-param name="class" select="$class"/>
  </xsl:apply-templates>
</xsl:template><xsl:template name="locale.html.attributes">
  <xsl:apply-templates select="." mode="locale.html.attributes"/>
</xsl:template><xsl:template match="*" mode="locale.html.attributes">
  <xsl:call-template name="generate.html.lang"/>
  <xsl:call-template name="dir"/>
</xsl:template><xsl:template name="generate.html.lang">
  <xsl:apply-templates select="." mode="html.lang.attribute"/>
</xsl:template><xsl:template match="*" mode="html.lang.attribute">
  <!-- match the attribute name to the output type -->
  <xsl:choose>
    <xsl:when test="@lang and $stylesheet.result.type = 'html'">
      <xsl:attribute name="lang">
        <xsl:value-of select="@lang"/>
      </xsl:attribute>
    </xsl:when>
    <xsl:when test="@lang and $stylesheet.result.type = 'xhtml'">
      <xsl:attribute name="xml:lang">
        <xsl:value-of select="@lang"/>
      </xsl:attribute>
    </xsl:when>
    <xsl:when test="@xml:lang and $stylesheet.result.type = 'html'">
      <xsl:attribute name="lang">
        <xsl:value-of select="@xml:lang"/>
      </xsl:attribute>
    </xsl:when>
    <xsl:when test="@xml:lang and $stylesheet.result.type = 'xhtml'">
      <xsl:attribute name="xml:lang">
        <xsl:value-of select="@xml:lang"/>
      </xsl:attribute>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template name="generate.css">
  <xsl:choose>
    <xsl:when test="$generate.css.header = 0">
      <xsl:call-template name="generate.css.links"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="generate.css.headers"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="generate.css.headers">
  <xsl:call-template name="generate.default.css.header"/>
  <xsl:call-template name="generate.custom.css.header"/>
</xsl:template>

<xsl:template name="generate.default.css.header">
  <xsl:if test="$make.clean.html != 0 and                  $docbook.css != ''">
    <style type="text/css">
        <xsl:copy-of select="$docbook.css"/>
    </style>
  </xsl:if>
</xsl:template>

<xsl:template name="generate.custom.css.header">
  <xsl:if test="$custom.css != ''">
    <style type="text/css">
        <xsl:copy-of select="$custom.css"/>
    </style>
  </xsl:if>
</xsl:template>

<xsl:template name="output.css.header">
  <xsl:param name="css.node"/> 

  <xsl:choose>
    <xsl:when test="count($css.node) = 0">
    </xsl:when>
    <xsl:otherwise>
      <style type="text/css">
        <xsl:copy-of select="$css.node/text()"/>
      </style>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="generate.css.links">
  <xsl:call-template name="generate.default.css.link"/>
  <xsl:call-template name="generate.custom.css.link"/>
</xsl:template>

<xsl:template name="generate.default.css.link">
  <xsl:if test="$make.clean.html != 0 and                  $docbook.css.link != 0 and                 $docbook.css.filename != ''">
    <xsl:call-template name="make.css.link">
      <xsl:with-param name="css.filename" select="$docbook.css.filename"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template>

<xsl:template name="generate.custom.css.link">
  <xsl:if test="$custom.css.filename != ''">
    <xsl:call-template name="make.css.link">
      <xsl:with-param name="css.filename" select="$custom.css.filename"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template>

<xsl:template name="make.css.link">
  <xsl:param name="css.filename" select="''"/>

  <xsl:variable name="href">
    <xsl:call-template name="relative.path.link">
      <xsl:with-param name="target.pathname" select="$css.filename"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:if test="string-length($css.filename) != 0">
    <link rel="stylesheet" type="text/css" href="{$href}"/>
  </xsl:if>
</xsl:template><xsl:template name="make.script.link">
  <xsl:param name="script.filename" select="''"/>

  <xsl:variable name="src">
    <xsl:call-template name="relative.path.link">
      <xsl:with-param name="target.pathname" select="$script.filename"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:if test="string-length($script.filename) != 0">
    <script>
      <xsl:attribute name="src">
        <xsl:value-of select="$src"/>
      </xsl:attribute>
      <xsl:attribute name="type">
        <xsl:value-of select="$html.script.type"/>
      </xsl:attribute>
      <xsl:call-template name="other.script.attributes">
        <xsl:with-param name="script.filename" select="$script.filename"/>
      </xsl:call-template>
    </script>
  </xsl:if>
</xsl:template><xsl:template name="other.script.attributes">
  <xsl:param name="script.filename"/>
  <!-- Placeholder template to allow customization to 
       insert additional script element attributes if needed -->
</xsl:template><xsl:template name="relative.path.link">
  <xsl:param name="target.pathname"/>
  
  <xsl:variable name="href.to.uri" select="$target.pathname"/>

  <xsl:variable name="href.from.uri">
    <xsl:call-template name="href.target.uri">
      <xsl:with-param name="object" select="."/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="href.to">
    <xsl:call-template name="trim.common.uri.paths">
      <xsl:with-param name="uriA" select="$href.to.uri"/>
      <xsl:with-param name="uriB" select="$href.from.uri"/>
      <xsl:with-param name="return" select="'A'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="href.from">
    <xsl:call-template name="trim.common.uri.paths">
      <xsl:with-param name="uriA" select="$href.to.uri"/>
      <xsl:with-param name="uriB" select="$href.from.uri"/>
      <xsl:with-param name="return" select="'B'"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="depth">
    <xsl:call-template name="count.uri.path.depth">
      <xsl:with-param name="filename" select="$href.from"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="href">
    <xsl:call-template name="copy-string">
      <xsl:with-param name="string" select="'../'"/>
      <xsl:with-param name="count" select="$depth"/>
    </xsl:call-template>
    <xsl:value-of select="$href.to"/>
  </xsl:variable>

  <xsl:value-of select="$href"/>
</xsl:template>

<xsl:template name="generate.css.files">
  <xsl:call-template name="generate.default.css.file"/>
  <xsl:call-template name="generate.custom.css.file"/>
</xsl:template>

<xsl:template name="generate.default.css.file">
  <xsl:if test="$make.clean.html != 0 and                  $generate.css.header = 0 and                 $docbook.css != ''">
    <xsl:call-template name="generate.css.file">
      <xsl:with-param name="filename" select="$docbook.css.filename"/>
      <xsl:with-param name="src" select="$docbook.css"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template>

<xsl:template name="generate.custom.css.file">
  <xsl:if test="$custom.css != '' and                 $generate.css.header = 0">
    <xsl:call-template name="generate.css.file">
      <xsl:with-param name="filename" select="$custom.css.filename"/>
      <xsl:with-param name="src" select="$custom.css"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template>

<xsl:template name="generate.css.file">
  <xsl:param name="src" select="''"/>
  <xsl:param name="filename"/> 

  <xsl:call-template name="write.text.chunk">
    <xsl:with-param name="filename" select="$filename"/>
    <xsl:with-param name="content" select="$src"/>
  </xsl:call-template>
</xsl:template>

<xsl:template name="css.output.filename">
  <xsl:param name="content"/>
  <xsl:param name="src" select="''"/>
  
  <xsl:variable name="candidate">
    <xsl:choose>
      <xsl:when test="string-length($src) = 0">
        <xsl:message>
          <xsl:text>ERROR: missing CSS input filename.</xsl:text>
        </xsl:message>
      </xsl:when>
      <xsl:when test="substring($src,string-length($src)-3) = '.xml'">
        <xsl:value-of select="substring($src, 1, string-length($src) - 4)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$src"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:value-of select="$candidate"/>
</xsl:template>

<xsl:template name="css.output.pathname">
  <xsl:param name="content"/>
  <xsl:param name="src" select="''"/>

  <xsl:variable name="file">
    <xsl:call-template name="css.output.filename">
      <xsl:with-param name="content" select="$content"/>
      <xsl:with-param name="src" select="$src"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="path" select="concat($chunk.base.dir, $file)"/>
  <xsl:value-of select="$path"/>
  
</xsl:template>

<xsl:template match="corpauthor">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates/>
  </span>
</xsl:template><xsl:template match="jobtitle">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates/>
  </span>
</xsl:template>
<xsl:template match="keywordset"/><xsl:template match="subjectset"/><xsl:template match="keywordset" mode="html.header">
  <meta name="keywords">
    <xsl:attribute name="content">
      <xsl:apply-templates select="keyword" mode="html.header"/>
    </xsl:attribute>
  </meta>
</xsl:template><xsl:template match="keyword" mode="html.header">
  <xsl:apply-templates/>
  <xsl:if test="following-sibling::keyword">, </xsl:if>
</xsl:template>
<xsl:template match="set">
  <xsl:call-template name="id.warning"/>

  <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:call-template name="dir">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="language.attribute"/>
    <xsl:if test="$generate.id.attributes != 0">
      <xsl:attribute name="id">
        <xsl:call-template name="object.id"/>
      </xsl:attribute>
    </xsl:if>

    <xsl:call-template name="set.titlepage"/>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:call-template name="make.lots">
      <xsl:with-param name="toc.params" select="$toc.params"/>
      <xsl:with-param name="toc">
        <xsl:call-template name="set.toc">
          <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
        </xsl:call-template>
      </xsl:with-param>
    </xsl:call-template>

    <xsl:apply-templates/>
  </xsl:element>
</xsl:template><xsl:template match="set/setinfo"/><xsl:template match="set/title"/><xsl:template match="set/titleabbrev"/><xsl:template match="set/subtitle"/><xsl:template match="book">
  <xsl:call-template name="id.warning"/>

  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:call-template name="book.titlepage"/>

    <xsl:apply-templates select="dedication" mode="dedication"/>
    <xsl:apply-templates select="acknowledgements" mode="acknowledgements"/>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:call-template name="make.lots">
      <xsl:with-param name="toc.params" select="$toc.params"/>
      <xsl:with-param name="toc">
        <xsl:call-template name="division.toc">
          <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
        </xsl:call-template>
      </xsl:with-param>
    </xsl:call-template>

    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="book/bookinfo"/><xsl:template match="book/info"/><xsl:template match="book/title"/><xsl:template match="book/titleabbrev"/><xsl:template match="book/subtitle"/><xsl:template match="part">
  <xsl:call-template name="id.warning"/>

  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:call-template name="part.titlepage"/>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:if test="not(partintro) and contains($toc.params, 'toc')">
      <xsl:call-template name="division.toc"/>
    </xsl:if>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="part" mode="make.part.toc">
  <xsl:call-template name="division.toc"/>
</xsl:template><xsl:template match="reference" mode="make.part.toc">
  <xsl:call-template name="division.toc"/>
</xsl:template><xsl:template match="part/docinfo"/><xsl:template match="part/partinfo"/><xsl:template match="part/info"/><xsl:template match="part/title"/><xsl:template match="part/titleabbrev"/><xsl:template match="part/subtitle"/><xsl:template match="partintro">
  <xsl:call-template name="id.warning"/>

  <div>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:call-template name="partintro.titlepage"/>
    <xsl:apply-templates/>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="node" select="parent::*"/>
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:if test="contains($toc.params, 'toc')">
      <!-- not ancestor::part because partintro appears in reference -->
      <xsl:apply-templates select="parent::*" mode="make.part.toc"/>
    </xsl:if>
    <xsl:call-template name="process.footnotes"/>
  </div>
</xsl:template><xsl:template match="partintro/title"/><xsl:template match="partintro/titleabbrev"/><xsl:template match="partintro/subtitle"/><xsl:template match="partintro/title" mode="partintro.title.mode">
  <h2>
    <xsl:apply-templates/>
  </h2>
</xsl:template><xsl:template match="partintro/subtitle" mode="partintro.title.mode">
  <h3>
    <em xmlns:xslo="http://www.w3.org/1999/XSL/Transform"><xsl:apply-templates/></em>
  </h3>
</xsl:template><xsl:template match="book" mode="division.number">
  <xsl:number from="set" count="book" format="1."/>
</xsl:template><xsl:template match="part" mode="division.number">
  <xsl:number from="book" count="part" format="I."/>
</xsl:template><xsl:template name="division.title">
  <xsl:param name="node" select="."/>

  <h1>
    <xsl:attribute name="class">title</xsl:attribute>
    <xsl:call-template name="anchor">
      <xsl:with-param name="node" select="$node"/>
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:apply-templates select="$node" mode="object.title.markup">
      <xsl:with-param name="allow-anchors" select="1"/>
    </xsl:apply-templates>
  </h1>
</xsl:template>
<xsl:template match="set/toc | book/toc | part/toc">
  <xsl:variable name="toc.params">
    <xsl:call-template name="find.path.params">
      <xsl:with-param name="node" select="parent::*"/>
      <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
    </xsl:call-template>
  </xsl:variable>

  <!-- Do not output the toc element if one is already generated
       by the use of $generate.toc parameter, or if
       generating a source toc is turned off -->
  <xsl:if test="not(contains($toc.params, 'toc')) and                 ($process.source.toc != 0 or $process.empty.source.toc != 0)">
    <xsl:variable name="content">
      <xsl:choose>
        <xsl:when test="* and $process.source.toc != 0">
          <xsl:apply-templates/>
        </xsl:when>
        <xsl:when test="count(*) = 0 and $process.empty.source.toc != 0">
          <!-- trick to switch context node to parent element -->
          <xsl:for-each select="parent::*">
            <xsl:choose>
              <xsl:when test="self::set">
                <xsl:call-template name="set.toc">
                  <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                </xsl:call-template>
              </xsl:when>
              <xsl:when test="self::book">
                <xsl:call-template name="division.toc">
                  <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                </xsl:call-template>
              </xsl:when>
              <xsl:when test="self::part">
                <xsl:call-template name="division.toc">
                  <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                </xsl:call-template>
              </xsl:when>
            </xsl:choose>
          </xsl:for-each>
        </xsl:when>
      </xsl:choose>
    </xsl:variable>

    <xsl:if test="string-length(normalize-space($content)) != 0">
      <xsl:copy-of select="$content"/>
    </xsl:if>
  </xsl:if>
</xsl:template><xsl:template match="chapter/toc | appendix/toc | preface/toc | article/toc">
  <xsl:variable name="toc.params">
    <xsl:call-template name="find.path.params">
      <xsl:with-param name="node" select="parent::*"/>
      <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
    </xsl:call-template>
  </xsl:variable>

  <!-- Do not output the toc element if one is already generated
       by the use of $generate.toc parameter, or if
       generating a source toc is turned off -->
  <xsl:if test="not(contains($toc.params, 'toc')) and                 ($process.source.toc != 0 or $process.empty.source.toc != 0)">
    <xsl:choose>
      <xsl:when test="* and $process.source.toc != 0">
        <div>
          <xsl:apply-templates select="." mode="common.html.attributes"/>
          <xsl:call-template name="id.attribute"/>
          <xsl:apply-templates select="title"/> 
          <dl>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:apply-templates select="*[not(self::title)]"/> 
          </dl>
        </div>
        <xsl:call-template name="component.toc.separator"/>
      </xsl:when>
      <xsl:when test="count(*) = 0 and $process.empty.source.toc != 0">
        <!-- trick to switch context node to section element -->
        <xsl:for-each select="parent::*">
          <xsl:call-template name="component.toc">
            <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
          </xsl:call-template>
        </xsl:for-each>
        <xsl:call-template name="component.toc.separator"/>
      </xsl:when>
    </xsl:choose>
  </xsl:if>
</xsl:template><xsl:template match="section/toc                     |sect1/toc                     |sect2/toc                     |sect3/toc                     |sect4/toc                     |sect5/toc">

  <xsl:variable name="toc.params">
    <xsl:call-template name="find.path.params">
      <xsl:with-param name="node" select="parent::*"/>
      <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
    </xsl:call-template>
  </xsl:variable>

  <!-- Do not output the toc element if one is already generated
       by the use of $generate.toc parameter, or if
       generating a source toc is turned off -->
  <xsl:if test="not(contains($toc.params, 'toc')) and                 ($process.source.toc != 0 or $process.empty.source.toc != 0)">
    <xsl:choose>
      <xsl:when test="* and $process.source.toc != 0">
        <div>
          <xsl:apply-templates select="." mode="common.html.attributes"/>
          <xsl:call-template name="id.attribute"/>
          <xsl:apply-templates select="title"/> 
          <dl>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:apply-templates select="*[not(self::title)]"/> 
          </dl>
        </div>
        <xsl:call-template name="section.toc.separator"/>
      </xsl:when>
      <xsl:when test="count(*) = 0 and $process.empty.source.toc != 0">
        <!-- trick to switch context node to section element -->
        <xsl:for-each select="parent::*">
          <xsl:call-template name="section.toc">
            <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
          </xsl:call-template>
        </xsl:for-each>
        <xsl:call-template name="section.toc.separator"/>
      </xsl:when>
    </xsl:choose>
  </xsl:if>
</xsl:template><xsl:template match="tocpart|tocchap                      |toclevel1|toclevel2|toclevel3|toclevel4|toclevel5">
  <xsl:variable name="sub-toc">
    <xsl:if test="tocchap|toclevel1|toclevel2|toclevel3|toclevel4|toclevel5">
      <xsl:choose>
        <xsl:when test="$toc.list.type = 'dl'">
          <dd>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
              <xsl:apply-templates select="." mode="common.html.attributes"/>
              <xsl:apply-templates select="tocchap|toclevel1|toclevel2|                                            toclevel3|toclevel4|toclevel5"/>
            </xsl:element>
          </dd>
        </xsl:when>
        <xsl:otherwise>
          <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:apply-templates select="tocchap|toclevel1|toclevel2|                                          toclevel3|toclevel4|toclevel5"/>
          </xsl:element>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:variable>

  <xsl:apply-templates select="tocentry[position() != last()]"/>

  <xsl:choose>
    <xsl:when test="$toc.list.type = 'dl'">
      <dt>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:apply-templates select="tocentry[position() = last()]"/>
      </dt>
      <xsl:copy-of select="$sub-toc"/>
    </xsl:when>
    <xsl:otherwise>
      <li>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:apply-templates select="tocentry[position() = last()]"/>
        <xsl:copy-of select="$sub-toc"/>
      </li>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="tocentry|tocdiv|lotentry|tocfront|tocback">
  <xsl:choose>
    <xsl:when test="$toc.list.type = 'dl'">
      <dt>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:call-template name="tocentry-content"/>
      </dt>
    </xsl:when>
    <xsl:otherwise>
      <li>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:call-template name="tocentry-content"/>
      </li>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="tocentry[position() = last()]" priority="2">
  <xsl:call-template name="tocentry-content"/>
</xsl:template><xsl:template name="tocentry-content">
  <xsl:variable name="targets" select="key('id',@linkend)"/>
  <xsl:variable name="target" select="$targets[1]"/>

  <xsl:choose>
    <xsl:when test="@linkend">
      <xsl:call-template name="check.id.unique">
        <xsl:with-param name="linkend" select="@linkend"/>
      </xsl:call-template>
      <a>
        <xsl:attribute name="href">
          <xsl:call-template name="href.target">
            <xsl:with-param name="object" select="$target"/>
          </xsl:call-template>
        </xsl:attribute>
        <xsl:apply-templates/>
      </a>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="toc/title">
  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="toc/subtitle">
  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="toc/titleabbrev">
</xsl:template><xsl:template match="book/lot | part/lot">
  <!-- Don't generate a page sequence unless there is content -->
  <xsl:variable name="content">
    <xsl:choose>
      <xsl:when test="* and $process.source.toc != 0">
        <div>
          <xsl:apply-templates select="." mode="common.html.attributes"/>
          <xsl:apply-templates/>
        </div>
      </xsl:when>
      <xsl:when test="not(child::*) and $process.empty.source.toc != 0">
        <xsl:call-template name="process.empty.lot"/>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:if test="string-length(normalize-space($content)) != 0">
    <xsl:copy-of select="$content"/>
  </xsl:if>
</xsl:template><xsl:template match="chapter/lot | appendix/lot | preface/lot | article/lot">
  <xsl:choose>
    <xsl:when test="* and $process.source.toc != 0">
      <div>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:apply-templates/>
      </div>
      <xsl:call-template name="component.toc.separator"/>
    </xsl:when>
    <xsl:when test="not(child::*) and $process.empty.source.toc != 0">
      <xsl:call-template name="process.empty.lot"/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="section/lot                     |sect1/lot                     |sect2/lot                     |sect3/lot                     |sect4/lot                     |sect5/lot">
  <xsl:choose>
    <xsl:when test="* and $process.source.toc != 0">
      <div>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:apply-templates/>
      </div>
      <xsl:call-template name="section.toc.separator"/>
    </xsl:when>
    <xsl:when test="not(child::*) and $process.empty.source.toc != 0">
      <xsl:call-template name="process.empty.lot"/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template name="process.empty.lot">
  <!-- An empty lot element does not provide any information to indicate
       what should be included in it.  You can customize this
       template to generate a lot based on @role or something -->
  <xsl:message>
    <xsl:text>Warning: don't know what to generate for </xsl:text>
    <xsl:text>lot that has no children.</xsl:text>
  </xsl:message>
</xsl:template><xsl:template match="lot/title">
  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="lot/subtitle">
  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="lot/titleabbrev">
</xsl:template>
<xsl:template match="index">
  <!-- some implementations use completely empty index tags to indicate -->
  <!-- where an automatically generated index should be inserted. so -->
  <!-- if the index is completely empty, skip it. Unless generate.index -->
  <!-- is non-zero, in which case, this is where the automatically -->
  <!-- generated index should go. -->

  <xsl:call-template name="id.warning"/>

  <xsl:if test="count(*)&gt;0 or $generate.index != '0'">
    <div>
      <xsl:apply-templates select="." mode="common.html.attributes"/>
      <xsl:call-template name="id.attribute">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>

      <xsl:call-template name="index.titlepage"/>
      <xsl:choose>
	<xsl:when test="indexdiv">
	  <xsl:apply-templates/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:apply-templates select="*[not(self::indexentry)]"/>
	  <!-- Because it's actually valid for Index to have neither any -->
	  <!-- Indexdivs nor any Indexentries, we need to check and make -->
	  <!-- sure that at least one Indexentry exists, and generate a -->
	  <!-- wrapper dl if there is at least one; otherwise, do nothing. -->
	  <xsl:if test="indexentry">
	    <!-- The indexentry template assumes a parent dl wrapper has -->
	    <!-- been generated; for Indexes that have Indexdivs, the dl -->
	    <!-- wrapper is generated by the indexdiv template; however, -->
	    <!-- for Indexes that lack Indexdivs, if we don't generate a -->
	    <!-- dl here, HTML output will not be valid. -->
	    <dl>
	      <xsl:apply-templates select="indexentry"/>
	    </dl>
	  </xsl:if>
	</xsl:otherwise>
      </xsl:choose>

      <xsl:if test="count(indexentry) = 0 and count(indexdiv) = 0">
        <xsl:call-template name="generate-index">
          <xsl:with-param name="scope" select="(ancestor::book|/)[last()]"/>
        </xsl:call-template>
      </xsl:if>

      <xsl:if test="not(parent::article)">
        <xsl:call-template name="process.footnotes"/>
      </xsl:if>
    </div>
  </xsl:if>
</xsl:template><xsl:template match="setindex">
  <!-- some implementations use completely empty index tags to indicate -->
  <!-- where an automatically generated index should be inserted. so -->
  <!-- if the index is completely empty, skip it. Unless generate.index -->
  <!-- is non-zero, in which case, this is where the automatically -->
  <!-- generated index should go. -->

  <xsl:call-template name="id.warning"/>

  <xsl:if test="count(*)&gt;0 or $generate.index != '0'">
    <div>
      <xsl:apply-templates select="." mode="common.html.attributes"/>
      <xsl:call-template name="id.attribute">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>

      <xsl:call-template name="setindex.titlepage"/>
      <xsl:apply-templates/>

      <xsl:if test="count(indexentry) = 0 and count(indexdiv) = 0">
        <xsl:call-template name="generate-index">
          <xsl:with-param name="scope" select="/"/>
        </xsl:call-template>
      </xsl:if>

      <xsl:if test="not(parent::article)">
        <xsl:call-template name="process.footnotes"/>
      </xsl:if>
    </div>
  </xsl:if>
</xsl:template><xsl:template match="index/indexinfo"/><xsl:template match="index/info"/><xsl:template match="index/title"/><xsl:template match="index/subtitle"/><xsl:template match="index/titleabbrev"/><xsl:template match="indexdiv">
  <xsl:call-template name="id.warning"/>

  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:apply-templates select="*[not(self::indexentry)]"/>
    <dl>
      <xsl:apply-templates select="indexentry"/>
    </dl>
  </div>
</xsl:template><xsl:template match="indexdiv/title">
  <h3>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:apply-templates/>
  </h3>
</xsl:template><xsl:template match="indexterm">
  <!-- this one must have a name, even if it doesn't have an ID -->
  <xsl:variable name="id">
    <xsl:call-template name="object.id"/>
  </xsl:variable>

  <a id="{$id}" class="indexterm"/>
</xsl:template><xsl:template match="primary|secondary|tertiary|see|seealso">
</xsl:template><xsl:template match="indexentry">
  <xsl:apply-templates select="primaryie"/>
</xsl:template><xsl:template match="primaryie">
  <dt>
    <xsl:apply-templates/>
  </dt>
  <dd>
    <xsl:apply-templates select="following-sibling::seeie                                    [not(preceding-sibling::secondaryie)]" mode="indexentry"/>
    <xsl:apply-templates select="following-sibling::seealsoie                                    [not(preceding-sibling::secondaryie)]" mode="indexentry"/>
    <xsl:apply-templates select="following-sibling::secondaryie" mode="indexentry"/>
  </dd>
</xsl:template><xsl:template match="secondaryie">
</xsl:template><xsl:template match="tertiaryie">
</xsl:template><xsl:template match="seeie|seealsoie">
</xsl:template><xsl:template match="secondaryie" mode="indexentry">
  <dl>
    <dt>
      <xsl:apply-templates/>
    </dt>
    <dd>
      <!-- select following see* elements up to next secondaryie or tertiary or end -->
      <xsl:variable name="after.this" select="following-sibling::*"/>
      <xsl:variable name="next.entry" select="(following-sibling::secondaryie|following-sibling::tertiaryie)[1]"/>
      <xsl:variable name="before.entry" select="$next.entry/preceding-sibling::*"/>
      <xsl:variable name="see.intersection" select="$after.this[count(.|$before.entry) = count($before.entry)]                                 [self::seeie or self::seealsoie]"/>
      <xsl:choose>
        <xsl:when test="count($see.intersection) != 0">
          <xsl:apply-templates select="$see.intersection" mode="indexentry"/>
        </xsl:when>
        <xsl:when test="count($next.entry) = 0">
          <xsl:apply-templates select="following-sibling::seeie" mode="indexentry"/>
          <xsl:apply-templates select="following-sibling::seealsoie" mode="indexentry"/>
        </xsl:when>
      </xsl:choose>

      <!-- now process any tertiaryie before the next secondaryie -->
      <xsl:variable name="before.next.secondary" select="following-sibling::secondaryie[1]/preceding-sibling::*"/>
      <xsl:variable name="tertiary.intersection" select="$after.this[count(.|$before.next.secondary) =                                   count($before.next.secondary)]                                 [not(self::seeie) and not(self::seealsoie)]"/>
      <xsl:choose>
        <xsl:when test="count($tertiary.intersection) != 0">
          <xsl:apply-templates select="$tertiary.intersection" mode="indexentry"/>
        </xsl:when>
        <xsl:when test="not(following-sibling::secondaryie)">
          <xsl:apply-templates select="following-sibling::tertiaryie" mode="indexentry"/>
        </xsl:when>
      </xsl:choose>
    </dd>
  </dl>
</xsl:template><xsl:template match="tertiaryie" mode="indexentry">
  <dl>
    <dt>
      <xsl:apply-templates/>
    </dt>
    <dd>
      <!-- select following see* elements up to next secondaryie or tertiary or end -->
      <xsl:variable name="after.this" select="following-sibling::*"/>
      <xsl:variable name="next.entry" select="(following-sibling::secondaryie|following-sibling::tertiaryie)[1]"/>
      <xsl:variable name="before.entry" select="$next.entry/preceding-sibling::*"/>
      <xsl:variable name="see.intersection" select="$after.this[count(.|$before.entry) = count($before.entry)]                                 [self::seeie or self::seealsoie]"/>
      <xsl:choose>
        <xsl:when test="count($see.intersection) != 0">
          <xsl:apply-templates select="$see.intersection" mode="indexentry"/>
        </xsl:when>
        <xsl:when test="count($next.entry) = 0">
          <xsl:apply-templates select="following-sibling::seeie" mode="indexentry"/>
          <xsl:apply-templates select="following-sibling::seealsoie" mode="indexentry"/>
        </xsl:when>
      </xsl:choose>
    </dd>
  </dl>
</xsl:template><xsl:template match="seeie" mode="indexentry">
  <dt>
    <xsl:text>(</xsl:text>
    <xsl:call-template name="gentext">
      <xsl:with-param name="key" select="'see'"/>
    </xsl:call-template>
    <xsl:text> </xsl:text>
    <xsl:apply-templates/>
    <xsl:text>)</xsl:text>
  </dt>
</xsl:template><xsl:template match="seealsoie" mode="indexentry">
  <div>
    <xsl:text>(</xsl:text>
    <xsl:call-template name="gentext">
      <xsl:with-param name="key" select="'seealso'"/>
    </xsl:call-template>
    <xsl:text> </xsl:text>
    <xsl:apply-templates/>
    <xsl:text>)</xsl:text>
  </div>
</xsl:template>
<xsl:template match="reference">
  <xsl:call-template name="id.warning"/>

  <div>
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:call-template name="reference.titlepage"/>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:if test="not(partintro) and contains($toc.params, 'toc')">
      <xsl:call-template name="division.toc"/>
    </xsl:if>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="reference" mode="division.number">
  <xsl:number from="book" count="reference" format="I."/>
</xsl:template><xsl:template match="reference/docinfo"/><xsl:template match="reference/referenceinfo"/><xsl:template match="reference/title"/><xsl:template match="reference/subtitle"/><xsl:template match="reference/titleabbrev"/><xsl:template name="refentry.title">
  <xsl:param name="node" select="."/>
  <xsl:variable name="refmeta" select="$node//refmeta"/>
  <xsl:variable name="refentrytitle" select="$refmeta//refentrytitle"/>
  <xsl:variable name="refnamediv" select="$node//refnamediv"/>
  <xsl:variable name="refname" select="$refnamediv//refname"/>
  <xsl:variable name="refdesc" select="$refnamediv//refdescriptor"/>
  <xsl:variable name="title">
    <xsl:choose>
      <xsl:when test="$refentrytitle">
        <xsl:apply-templates select="$refentrytitle[1]" mode="title"/>
      </xsl:when>
      <xsl:when test="$refdesc">
	<xsl:apply-templates select="$refdesc[1]" mode="title"/>
      </xsl:when>
      <xsl:when test="$refname">
        <xsl:apply-templates select="$refname[1]" mode="title"/>
      </xsl:when>
      <xsl:otherwise/>
    </xsl:choose>
  </xsl:variable>

  <h1 class="title">
    <xsl:copy-of select="$title"/>
  </h1>
</xsl:template><xsl:template match="refentry">
  <xsl:call-template name="id.warning"/>

  <div>
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:if test="$refentry.separator != 0 and preceding-sibling::refentry">
      <div class="refentry.separator">
        <hr/>
      </div>
    </xsl:if>
    <xsl:call-template name="anchor">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:call-template name="refentry.titlepage"/>
    <xsl:apply-templates/>
    <xsl:call-template name="process.footnotes"/>
  </div>
</xsl:template><xsl:template match="refentry/docinfo|refentry/refentryinfo"/><xsl:template match="refentry/info"/><xsl:template match="refentrytitle|refname|refdescriptor" mode="title">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="refmeta">
</xsl:template><xsl:template match="manvolnum">
  <xsl:if test="$refentry.xref.manvolnum != 0">
    <xsl:text>(</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>)</xsl:text>
  </xsl:if>
</xsl:template><xsl:template match="refmiscinfo">
</xsl:template><xsl:template match="refentrytitle">
  <xsl:call-template name="inline.charseq"/>
</xsl:template><xsl:template match="refnamediv">
  <div>
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>

    <xsl:choose>
      <xsl:when test="preceding-sibling::refnamediv">
	<!-- no title on secondary refnamedivs! -->
      </xsl:when>
      <xsl:when test="$refentry.generate.name != 0">
        <h2>
          <xsl:call-template name="gentext">
            <xsl:with-param name="key" select="'RefName'"/>
          </xsl:call-template>
        </h2>
      </xsl:when>
      <xsl:when test="$refentry.generate.title != 0">
        <h2>
          <xsl:choose>
            <xsl:when test="../refmeta/refentrytitle">
              <xsl:apply-templates select="../refmeta/refentrytitle"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:apply-templates select="refname[1]"/>
            </xsl:otherwise>
          </xsl:choose>
        </h2>
      </xsl:when>
    </xsl:choose>

    <p>
      <xsl:apply-templates/>
    </p>
  </div>
</xsl:template><xsl:template match="refname">
  <xsl:if test="not(preceding-sibling::refdescriptor)">
    <xsl:apply-templates/>
    <xsl:if test="following-sibling::refname">
      <xsl:text>, </xsl:text>
    </xsl:if>
  </xsl:if>
</xsl:template><xsl:template match="refpurpose">
  <xsl:if test="node()">
    <xsl:text> </xsl:text>
    <xsl:call-template name="dingbat">
      <xsl:with-param name="dingbat">em-dash</xsl:with-param>
    </xsl:call-template>
    <xsl:text> </xsl:text>
    <xsl:apply-templates/>
  </xsl:if>
</xsl:template><xsl:template match="refdescriptor">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="refclass">
  <xsl:if test="$refclass.suppress = 0">
  <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
    <xsl:if test="@role">
      <xsl:value-of select="@role"/>
      <xsl:text>: </xsl:text>
    </xsl:if>
    <xsl:apply-templates/>
  </strong>
  </xsl:if>
</xsl:template><xsl:template match="refsynopsisdiv">
  <div>
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <h2>
      <xsl:choose>
        <xsl:when test="refsynopsisdiv/title|title">
          <xsl:apply-templates select="(refsynopsisdiv/title|title)[1]" mode="titlepage.mode"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="gentext">
            <xsl:with-param name="key" select="'RefSynopsisDiv'"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </h2>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="refsynopsisdivinfo"/><xsl:template match="refsynopsisdiv/title">
</xsl:template><xsl:template match="refsynopsisdiv/title" mode="titlepage.mode">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="refsection|refsect1|refsect2|refsect3">
  <div>
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:call-template name="anchor">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <!-- pick up info title -->
    <xsl:apply-templates select="(title|info/title)[1]"/>
    <xsl:apply-templates select="node()[not(self::title) and not(self::info)]"/>
  </div>
</xsl:template><xsl:template match="refsection/title|refsection/info/title">
  <!-- the ID is output in the block.object call for refsect1 -->
  <xsl:variable name="level" select="count(ancestor-or-self::refsection)"/>
  <xsl:variable name="refsynopsisdiv">
    <xsl:text>0</xsl:text>
    <xsl:if test="ancestor::refsynopsisdiv">1</xsl:if>
  </xsl:variable>
  <xsl:variable name="hlevel">
    <xsl:choose>
      <xsl:when test="$level+$refsynopsisdiv &gt; 5">6</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$level+1+$refsynopsisdiv"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:element name="h{$hlevel}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:apply-templates/>
  </xsl:element>
</xsl:template><xsl:template match="refsect1/title|refsect1/info/title">
  <!-- the ID is output in the block.object call for refsect1 -->
  <h2>
    <xsl:apply-templates/>
  </h2>
</xsl:template><xsl:template match="refsect2/title|refsect2/info/title">
  <!-- the ID is output in the block.object call for refsect2 -->
  <h3>
    <xsl:apply-templates/>
  </h3>
</xsl:template><xsl:template match="refsect3/title|refsect3/info/title">
  <!-- the ID is output in the block.object call for refsect3 -->
  <h4>
    <xsl:apply-templates/>
  </h4>
</xsl:template><xsl:template match="refsectioninfo|refsection/info"/><xsl:template match="refsect1info|refsect1/info"/><xsl:template match="refsect2info|refsect2/info"/><xsl:template match="refsect3info|refsect3/info"/>
<xsl:template match="inlineequation">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="alt">
</xsl:template><xsl:template match="mathphrase">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates/>
  </span>
</xsl:template><xsl:template match="mml:*">
  <xsl:copy>
    <xsl:copy-of select="@*"/>
    <xsl:apply-templates/>
  </xsl:copy>
</xsl:template><xsl:template match="*" mode="collect.tex.math">
  <xsl:call-template name="write.text.chunk">
    <xsl:with-param name="filename" select="$tex.math.file"/>
    <xsl:with-param name="method" select="'text'"/>
    <xsl:with-param name="content">
      <xsl:choose>
        <xsl:when test="$tex.math.in.alt = 'plain'">
          <xsl:call-template name="tex.math.plain.head"/>
          <xsl:apply-templates select="." mode="collect.tex.math.plain"/>
          <xsl:call-template name="tex.math.plain.tail"/>
        </xsl:when>
        <xsl:when test="$tex.math.in.alt = 'latex'">
          <xsl:call-template name="tex.math.latex.head"/>
          <xsl:apply-templates select="." mode="collect.tex.math.latex"/>
          <xsl:call-template name="tex.math.latex.tail"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message>
            Unsupported TeX math notation: 
            <xsl:value-of select="$tex.math.in.alt"/>
          </xsl:message>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:with-param>
    <xsl:with-param name="encoding" select="$chunker.output.encoding"/>
  </xsl:call-template>
</xsl:template><xsl:template name="tex.math.plain.head">
  <xsl:text>\nopagenumbers 
</xsl:text>
</xsl:template><xsl:template name="tex.math.plain.tail">
  <xsl:text>\bye 
</xsl:text>
</xsl:template><xsl:template match="inlineequation" mode="collect.tex.math.plain">
  <xsl:variable name="filename">
    <xsl:choose>
      <xsl:when test="graphic">
        <xsl:call-template name="mediaobject.filename">
          <xsl:with-param name="object" select="graphic"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="select.mediaobject.filename">
          <xsl:with-param name="olist" select="inlinemediaobject/*"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:variable name="output.delims">
    <xsl:call-template name="tex.math.output.delims"/>
  </xsl:variable>
  <xsl:variable name="tex" select="alt[@role='tex'] | inlinemediaobject/textobject[@role='tex']"/>
  <xsl:if test="$tex">
    <xsl:text>\special{dvi2bitmap outputfile </xsl:text>
    <xsl:value-of select="$filename"/>
    <xsl:text>} 
</xsl:text>
    <xsl:if test="$output.delims != 0">
      <xsl:text>$</xsl:text>
    </xsl:if>
    <xsl:value-of select="$tex"/>
    <xsl:if test="$output.delims != 0">
      <xsl:text>$ 
</xsl:text>
    </xsl:if>
    <xsl:text>\vfill\eject 
</xsl:text>
  </xsl:if>
</xsl:template><xsl:template match="equation|informalequation" mode="collect.tex.math.plain">
  <xsl:variable name="filename">
    <xsl:choose>
      <xsl:when test="graphic">
        <xsl:call-template name="mediaobject.filename">
          <xsl:with-param name="object" select="graphic"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="select.mediaobject.filename">
          <xsl:with-param name="olist" select="mediaobject/*"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:variable name="output.delims">
    <xsl:call-template name="tex.math.output.delims"/>
  </xsl:variable>
  <xsl:variable name="tex" select="alt[@role='tex'] | mediaobject/textobject[@role='tex']"/>
  <xsl:if test="$tex">
    <xsl:text>\special{dvi2bitmap outputfile </xsl:text>
    <xsl:value-of select="$filename"/>
    <xsl:text>} 
</xsl:text>
    <xsl:if test="$output.delims != 0">
      <xsl:text>$$</xsl:text>
    </xsl:if>
    <xsl:value-of select="$tex"/>
    <xsl:if test="$output.delims != 0">
      <xsl:text>$$ 
</xsl:text>
    </xsl:if>
    <xsl:text>\vfill\eject 
</xsl:text>
  </xsl:if>
</xsl:template><xsl:template match="text()" mode="collect.tex.math.plain"/><xsl:template name="tex.math.latex.head">
  <xsl:text>\documentclass{article} 
</xsl:text>
  <xsl:text>\pagestyle{empty} 
</xsl:text>
  <xsl:text>\begin{document} 
</xsl:text>
</xsl:template><xsl:template name="tex.math.latex.tail">
  <xsl:text>\end{document} 
</xsl:text>
</xsl:template><xsl:template match="inlineequation" mode="collect.tex.math.latex">
  <xsl:variable name="filename">
    <xsl:choose>
      <xsl:when test="graphic">
        <xsl:call-template name="mediaobject.filename">
          <xsl:with-param name="object" select="graphic"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="select.mediaobject.filename">
          <xsl:with-param name="olist" select="inlinemediaobject/*"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:variable name="output.delims">
    <xsl:call-template name="tex.math.output.delims"/>
  </xsl:variable>
  <xsl:variable name="tex" select="alt[@role='tex'] | inlinemediaobject/textobject[@role='tex']"/>
  <xsl:if test="$tex">
    <xsl:text>\special{dvi2bitmap outputfile </xsl:text>
    <xsl:value-of select="$filename"/>
    <xsl:text>} 
</xsl:text>
    <xsl:if test="$output.delims != 0">  
      <xsl:text>$</xsl:text>
    </xsl:if>
    <xsl:value-of select="$tex"/>
    <xsl:if test="$output.delims != 0">  
      <xsl:text>$ 
</xsl:text>
    </xsl:if>
    <xsl:text>\newpage 
</xsl:text>
  </xsl:if>
</xsl:template><xsl:template match="equation|informalequation" mode="collect.tex.math.latex">
  <xsl:variable name="filename">
    <xsl:choose>
      <xsl:when test="graphic">
        <xsl:call-template name="mediaobject.filename">
          <xsl:with-param name="object" select="graphic"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="select.mediaobject.filename">
          <xsl:with-param name="olist" select="mediaobject/*"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:variable name="output.delims">
    <xsl:call-template name="tex.math.output.delims"/>
  </xsl:variable>
  <xsl:variable name="tex" select="alt[@role='tex'] | mediaobject/textobject[@role='tex']"/>
  <xsl:if test="$tex">
    <xsl:text>\special{dvi2bitmap outputfile </xsl:text>
    <xsl:value-of select="$filename"/>
    <xsl:text>} 
</xsl:text>
    <xsl:if test="$output.delims != 0">
      <xsl:text>$$</xsl:text>
    </xsl:if>
    <xsl:value-of select="$tex"/>
    <xsl:if test="$output.delims != 0">
      <xsl:text>$$ 
</xsl:text>
    </xsl:if>
    <xsl:text>\newpage 
</xsl:text>
  </xsl:if>
</xsl:template><xsl:template match="text()" mode="collect.tex.math.latex"/><xsl:template name="select.mediaobject.filename">
  <xsl:param name="olist" select="imageobject|imageobjectco                      |videoobject|audioobject|textobject"/>

  <xsl:variable name="mediaobject.index">
    <xsl:call-template name="select.mediaobject.index">
      <xsl:with-param name="olist" select="$olist"/>
      <xsl:with-param name="count" select="1"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:if test="$mediaobject.index != ''">
    <xsl:call-template name="mediaobject.filename">
      <xsl:with-param name="object" select="$olist[position() = $mediaobject.index]"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template name="tex.math.output.delims">
  <xsl:variable name="pi.delims">
    <xsl:call-template name="pi.dbtex_delims">
      <xsl:with-param name="node" select="descendant-or-self::*"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:variable name="result">
    <xsl:choose>
      <xsl:when test="$pi.delims = 'no'">0</xsl:when>
      <xsl:when test="$pi.delims = '' and $tex.math.delims = 0">0</xsl:when>
      <xsl:otherwise>1</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:value-of select="$result"/>
</xsl:template>
<xsl:template match="*" mode="admon.graphic.width">
  <xsl:param name="node" select="."/>
  <xsl:text>25</xsl:text>
</xsl:template><xsl:template match="note|important|warning|caution|tip">
  <xsl:choose>
    <xsl:when test="$admon.graphics != 0">
      <xsl:call-template name="graphical.admonition"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="nongraphical.admonition"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="admon.graphic">
  <xsl:param name="node" select="."/>
  <xsl:value-of select="$admon.graphics.path"/>
  <xsl:choose>
    <xsl:when test="local-name($node)='note'">note</xsl:when>
    <xsl:when test="local-name($node)='warning'">warning</xsl:when>
    <xsl:when test="local-name($node)='caution'">caution</xsl:when>
    <xsl:when test="local-name($node)='tip'">tip</xsl:when>
    <xsl:when test="local-name($node)='important'">important</xsl:when>
    <xsl:otherwise>note</xsl:otherwise>
  </xsl:choose>
  <xsl:value-of select="$admon.graphics.extension"/>
</xsl:template><xsl:template name="nongraphical.admonition">
  <div>
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute"/>
    <xsl:if test="$admon.style != '' and $make.clean.html = 0">
      <xsl:attribute name="style">
        <xsl:value-of select="$admon.style"/>
      </xsl:attribute>
    </xsl:if>

    <xsl:if test="$admon.textlabel != 0 or title or info/title">
      <h3 class="title">
        <xsl:call-template name="anchor"/>
        <xsl:apply-templates select="." mode="object.title.markup"/>
      </h3>
    </xsl:if>

    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="note/title"/><xsl:template match="important/title"/><xsl:template match="warning/title"/><xsl:template match="caution/title"/><xsl:template match="tip/title"/>
<xsl:param name="component.heading.level" select="2"/><xsl:template name="component.title">
  <xsl:param name="node" select="."/>

  <!-- This handles the case where a component (bibliography, for example)
       occurs inside a section; will we need parameters for this? -->

  <!-- This "level" is a section level.  To compute <h> level, add 1. -->
  <xsl:variable name="level">
    <xsl:choose>
      <!-- chapters and other book children should get <h1> -->
      <xsl:when test="$node/parent::book">0</xsl:when>
      <xsl:when test="ancestor::section">
        <xsl:value-of select="count(ancestor::section)+1"/>
      </xsl:when>
      <xsl:when test="ancestor::sect5">6</xsl:when>
      <xsl:when test="ancestor::sect4">5</xsl:when>
      <xsl:when test="ancestor::sect3">4</xsl:when>
      <xsl:when test="ancestor::sect2">3</xsl:when>
      <xsl:when test="ancestor::sect1">2</xsl:when>
      <xsl:otherwise>1</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:element name="h{$level+1}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:attribute name="class">title</xsl:attribute>
    <xsl:call-template name="anchor">
      <xsl:with-param name="node" select="$node"/>
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:apply-templates select="$node" mode="object.title.markup">
      <xsl:with-param name="allow-anchors" select="1"/>
    </xsl:apply-templates>
  </xsl:element>
</xsl:template><xsl:template name="component.subtitle">
  <xsl:param name="node" select="."/>
  <xsl:variable name="subtitle" select="($node/docinfo/subtitle                         |$node/info/subtitle                         |$node/prefaceinfo/subtitle                         |$node/chapterinfo/subtitle                         |$node/appendixinfo/subtitle                         |$node/articleinfo/subtitle                         |$node/artheader/subtitle                         |$node/subtitle)[1]"/>

  <xsl:if test="$subtitle">
    <h3 class="subtitle">
      <xsl:call-template name="id.attribute"/>
      <em xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
        <xsl:apply-templates select="$node" mode="object.subtitle.markup"/>
      </em>
    </h3>
  </xsl:if>
</xsl:template><xsl:template name="component.separator">
</xsl:template><xsl:template match="dedication" mode="dedication">
  <xsl:call-template name="id.warning"/>

  <div>
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:call-template name="dedication.titlepage"/>
    <xsl:apply-templates/>
    <xsl:call-template name="process.footnotes"/>
  </div>
</xsl:template><xsl:template match="dedication/title|dedication/info/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.title">
    <xsl:with-param name="node" select="ancestor::dedication[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="dedication/subtitle|dedication/info/subtitle" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.subtitle">
    <xsl:with-param name="node" select="ancestor::dedication[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="dedication"/><xsl:template match="dedication/title"/><xsl:template match="dedication/subtitle"/><xsl:template match="dedication/titleabbrev"/><xsl:template match="acknowledgements" mode="acknowledgements">
  <xsl:call-template name="id.warning"/>

  <div>
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:call-template name="acknowledgements.titlepage"/>
    <xsl:apply-templates/>
    <xsl:call-template name="process.footnotes"/>
  </div>
</xsl:template><xsl:template match="acknowledgements/title|acknowledgements/info/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.title">
    <xsl:with-param name="node" select="ancestor::acknowledgements[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="acknowledgements/subtitle|acknowledgements/info/subtitle" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.subtitle">
    <xsl:with-param name="node" select="ancestor::acknowledgements[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="acknowledgements"/><xsl:template match="acknowledgements/title"/><xsl:template match="acknowledgements/subtitle"/><xsl:template match="acknowledgements/titleabbrev"/><xsl:template match="colophon">
  <xsl:call-template name="id.warning"/>

  <div>
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:call-template name="component.separator"/>
    <xsl:call-template name="component.title"/>
    <xsl:call-template name="component.subtitle"/>

    <xsl:apply-templates/>
    <xsl:call-template name="process.footnotes"/>
  </div>
</xsl:template><xsl:template match="colophon/title"/><xsl:template match="colophon/subtitle"/><xsl:template match="colophon/titleabbrev"/><xsl:template match="preface">
  <xsl:call-template name="id.warning"/>

  <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:call-template name="component.separator"/>
    <xsl:call-template name="preface.titlepage"/>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:if test="contains($toc.params, 'toc')">
      <xsl:call-template name="component.toc">
        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
      </xsl:call-template>
      <xsl:call-template name="component.toc.separator"/>
    </xsl:if>
    <xsl:apply-templates/>
    <xsl:call-template name="process.footnotes"/>
  </xsl:element>
</xsl:template><xsl:template match="preface/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.title">
    <xsl:with-param name="node" select="ancestor::preface[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="preface/subtitle                      |preface/prefaceinfo/subtitle                      |preface/info/subtitle                      |preface/docinfo/subtitle" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.subtitle">
    <xsl:with-param name="node" select="ancestor::preface[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="preface/docinfo|prefaceinfo"/><xsl:template match="preface/info"/><xsl:template match="preface/title"/><xsl:template match="preface/titleabbrev"/><xsl:template match="preface/subtitle"/><xsl:template match="chapter">
  <xsl:call-template name="id.warning"/>

  <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:call-template name="component.separator"/>
    <xsl:call-template name="chapter.titlepage"/>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:if test="contains($toc.params, 'toc')">
      <xsl:call-template name="component.toc">
        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
      </xsl:call-template>
      <xsl:call-template name="component.toc.separator"/>
    </xsl:if>
    <xsl:apply-templates/>
    <xsl:call-template name="process.footnotes"/>
  </xsl:element>
</xsl:template><xsl:template match="chapter/title|chapter/chapterinfo/title|chapter/info/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.title">
    <xsl:with-param name="node" select="ancestor::chapter[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="chapter/subtitle                      |chapter/chapterinfo/subtitle                      |chapter/info/subtitle                      |chapter/docinfo/subtitle" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.subtitle">
    <xsl:with-param name="node" select="ancestor::chapter[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="chapter/docinfo|chapterinfo"/><xsl:template match="chapter/info"/><xsl:template match="chapter/title"/><xsl:template match="chapter/titleabbrev"/><xsl:template match="chapter/subtitle"/><xsl:template match="appendix">
  <xsl:variable name="ischunk">
    <xsl:call-template name="chunk"/>
  </xsl:variable>

  <xsl:call-template name="id.warning"/>

  <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:choose>
      <xsl:when test="parent::article and $ischunk = 0">
        <xsl:call-template name="section.heading">
          <xsl:with-param name="level" select="1"/>
          <xsl:with-param name="title">
            <xsl:apply-templates select="." mode="object.title.markup"/>
          </xsl:with-param>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="component.separator"/>
        <xsl:call-template name="appendix.titlepage"/>
      </xsl:otherwise>
    </xsl:choose>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:if test="contains($toc.params, 'toc')">
      <xsl:call-template name="component.toc">
        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
      </xsl:call-template>
      <xsl:call-template name="component.toc.separator"/>
    </xsl:if>

    <xsl:apply-templates/>

    <xsl:if test="not(parent::article) or $ischunk != 0">
      <xsl:call-template name="process.footnotes"/>
    </xsl:if>
  </xsl:element>
</xsl:template><xsl:template match="appendix/title|appendix/appendixinfo/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.title">
    <xsl:with-param name="node" select="ancestor::appendix[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="appendix/subtitle                      |appendix/appendixinfo/subtitle                      |appendix/info/subtitle                      |appendix/docinfo/subtitle" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.subtitle">
    <xsl:with-param name="node" select="ancestor::appendix[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="appendix/docinfo|appendixinfo"/><xsl:template match="appendix/info"/><xsl:template match="appendix/title"/><xsl:template match="appendix/titleabbrev"/><xsl:template match="appendix/subtitle"/><xsl:template match="article">
  <xsl:call-template name="id.warning"/>

  <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:call-template name="article.titlepage"/>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:call-template name="make.lots">
      <xsl:with-param name="toc.params" select="$toc.params"/>
      <xsl:with-param name="toc">
        <xsl:call-template name="component.toc">
          <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
        </xsl:call-template>
      </xsl:with-param>
    </xsl:call-template>

    <xsl:apply-templates/>
    <xsl:call-template name="process.footnotes"/>
  </xsl:element>
</xsl:template><xsl:template match="article/title|article/articleinfo/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.title">
    <xsl:with-param name="node" select="ancestor::article[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="article/subtitle                      |article/articleinfo/subtitle                      |article/info/subtitle                      |article/artheader/subtitle" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.subtitle">
    <xsl:with-param name="node" select="ancestor::article[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="article/artheader|article/articleinfo"/><xsl:template match="article/info"/><xsl:template match="article/title"/><xsl:template match="article/titleabbrev"/><xsl:template match="article/subtitle"/><xsl:template match="topic">
  <xsl:call-template name="id.warning"/>

  <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:call-template name="topic.titlepage"/>

    <xsl:variable name="toc.params">
      <xsl:call-template name="find.path.params">
        <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:apply-templates/>

    <xsl:call-template name="process.footnotes"/>
  </xsl:element>
</xsl:template><xsl:template match="topic/title|topic/info/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.title">
    <xsl:with-param name="node" select="ancestor::topic[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="topic/subtitle                      |topic/info/subtitle" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.subtitle">
    <xsl:with-param name="node" select="ancestor::topic[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="topic/info"/><xsl:template match="topic/title"/><xsl:template match="topic/titleabbrev"/><xsl:template match="topic/subtitle"/>
<xsl:template match="bibliography">
  <xsl:call-template name="id.warning"/>

  <div>
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="1"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:call-template name="bibliography.titlepage"/>

    <xsl:apply-templates/>

    <xsl:if test="not(parent::article)">
      <xsl:call-template name="process.footnotes"/>
    </xsl:if>
  </div>
</xsl:template><xsl:template match="bibliography/bibliographyinfo"/><xsl:template match="bibliography/info"/><xsl:template match="bibliography/title"/><xsl:template match="bibliography/subtitle"/><xsl:template match="bibliography/titleabbrev"/><xsl:template match="bibliodiv">
  <xsl:call-template name="id.warning"/>

  <div>
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="0"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="bibliodiv/title">
  <h3>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="anchor">
      <xsl:with-param name="node" select=".."/>
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:apply-templates/>
  </h3>
</xsl:template><xsl:template match="bibliolist">
  <div>
    <xsl:call-template name="common.html.attributes">
      <xsl:with-param name="inherit" select="0"/>
    </xsl:call-template>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:if test="blockinfo/title|info/title|title">
      <xsl:call-template name="formal.object.heading"/>
    </xsl:if>
    <xsl:apply-templates select="*[not(self::blockinfo)                                    and not(self::info)                                    and not(self::title)                                    and not(self::titleabbrev)                                    and not(self::biblioentry)                                    and not(self::bibliomixed)]"/>
    <xsl:apply-templates select="biblioentry|bibliomixed"/>
  </div>
</xsl:template><xsl:template match="biblioentry">
  <xsl:param name="label">
    <xsl:call-template name="biblioentry.label"/>
  </xsl:param>

  <xsl:variable name="id">
    <xsl:call-template name="object.id"/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="string(.) = ''">
      <xsl:variable name="bib" select="document($bibliography.collection,.)"/>
      <xsl:variable name="entry" select="$bib/bibliography//                                          *[@id=$id or @xml:id=$id][1]"/>
      <xsl:choose>
        <xsl:when test="$entry">
          <xsl:choose>
            <xsl:when test="$bibliography.numbered != 0">
              <xsl:apply-templates select="$entry">
                <xsl:with-param name="label" select="$label"/>
              </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
              <xsl:apply-templates select="$entry"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message>
            <xsl:text>No bibliography entry: </xsl:text>
            <xsl:value-of select="$id"/>
            <xsl:text> found in </xsl:text>
            <xsl:value-of select="$bibliography.collection"/>
          </xsl:message>
          <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <p>
              <xsl:copy-of select="$label"/>
              <xsl:text>Error: no bibliography entry: </xsl:text>
              <xsl:value-of select="$id"/>
              <xsl:text> found in </xsl:text>
              <xsl:value-of select="$bibliography.collection"/>
            </p>
          </div>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <div>
        <xsl:call-template name="common.html.attributes"/>
        <xsl:call-template name="id.attribute">
          <xsl:with-param name="conditional" select="0"/>
        </xsl:call-template>
        <xsl:call-template name="anchor">
          <xsl:with-param name="conditional" select="0"/>
        </xsl:call-template>
        <p>
          <xsl:copy-of select="$label"/>
	  <xsl:choose>
	    <xsl:when test="$bibliography.style = 'iso690'">
	      <xsl:call-template name="iso690.makecitation"/>
	    </xsl:when>
	    <xsl:otherwise>
	      <xsl:apply-templates mode="bibliography.mode"/>
	    </xsl:otherwise>
	  </xsl:choose>
        </p>
      </div>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="bibliomixed">
  <xsl:param name="label">
    <xsl:call-template name="biblioentry.label"/>
  </xsl:param>

  <xsl:variable name="id">
    <xsl:call-template name="object.id"/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="string(.) = ''">
      <xsl:variable name="bib" select="document($bibliography.collection,.)"/>
      <xsl:variable name="entry" select="$bib/bibliography//                                          *[@id=$id or @xml:id=$id][1]"/>
      <xsl:choose>
        <xsl:when test="$entry">
          <xsl:choose>
            <xsl:when test="$bibliography.numbered != 0">
              <xsl:apply-templates select="$entry">
                <xsl:with-param name="label" select="$label"/>
              </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
              <xsl:apply-templates select="$entry"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message>
            <xsl:text>No bibliography entry: </xsl:text>
            <xsl:value-of select="$id"/>
            <xsl:text> found in </xsl:text>
            <xsl:value-of select="$bibliography.collection"/>
          </xsl:message>
          <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <p>
              <xsl:copy-of select="$label"/>
              <xsl:text>Error: no bibliography entry: </xsl:text>
              <xsl:value-of select="$id"/>
              <xsl:text> found in </xsl:text>
              <xsl:value-of select="$bibliography.collection"/>
            </p>
          </div>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <div>
        <xsl:call-template name="common.html.attributes"/>
        <xsl:call-template name="id.attribute">
          <xsl:with-param name="conditional" select="0"/>
        </xsl:call-template>
        <xsl:call-template name="anchor">
          <xsl:with-param name="conditional" select="0"/>
        </xsl:call-template>
        <p>
          <xsl:call-template name="common.html.attributes"/>
          <xsl:copy-of select="$label"/>
          <xsl:apply-templates mode="bibliomixed.mode"/>
        </p>
      </div>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="biblioentry.label">
  <xsl:param name="node" select="."/>

  <xsl:choose>
    <xsl:when test="$bibliography.numbered != 0">
      <xsl:text>[</xsl:text>
      <xsl:number from="bibliography" count="biblioentry|bibliomixed" level="any" format="1"/>
      <xsl:text>] </xsl:text>
    </xsl:when>
    <xsl:when test="local-name($node/child::*[1]) = 'abbrev'">
      <xsl:text>[</xsl:text>
      <xsl:apply-templates select="$node/abbrev[1]"/>
      <xsl:text>] </xsl:text>
    </xsl:when>
    <xsl:when test="$node/@xreflabel">
      <xsl:text>[</xsl:text>
      <xsl:value-of select="$node/@xreflabel"/>
      <xsl:text>] </xsl:text>
    </xsl:when>
    <xsl:when test="$node/@id">
      <xsl:text>[</xsl:text>
      <xsl:value-of select="$node/@id"/>
      <xsl:text>] </xsl:text>
    </xsl:when>
    <xsl:when test="$node/@xml:id">
      <xsl:text>[</xsl:text>
      <xsl:value-of select="$node/@xml:id"/>
      <xsl:text>] </xsl:text>
    </xsl:when>
    <xsl:otherwise><!-- nop --></xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="*" mode="bibliography.mode">
  <xsl:apply-templates select="."/><!-- try the default mode -->
</xsl:template><xsl:template match="abbrev" mode="bibliography.mode">
  <xsl:if test="preceding-sibling::*">
    <xsl:apply-templates mode="bibliography.mode"/>
  </xsl:if>
</xsl:template><xsl:template match="abstract" mode="bibliography.mode">
  <!-- suppressed -->
</xsl:template><xsl:template match="address" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="affiliation" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="shortaffil" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="jobtitle" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="artheader|articleinfo|info" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="artpagenums" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="author" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:choose>
      <xsl:when test="orgname">
        <xsl:apply-templates select="orgname" mode="bibliography.mode"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="person.name"/>
        <xsl:copy-of select="$biblioentry.item.separator"/>
      </xsl:otherwise>
    </xsl:choose>
  </span>
</xsl:template><xsl:template match="authorblurb|personblurb" mode="bibliography.mode">
  <!-- suppressed -->
</xsl:template><xsl:template match="authorgroup" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="person.name.list"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="authorinitials" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="bibliomisc" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="bibliomset" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="biblioset" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
  </span>
</xsl:template><xsl:template match="biblioset/title|biblioset/citetitle" mode="bibliography.mode">
  <xsl:variable name="relation" select="../@relation"/>
  <xsl:choose>
    <xsl:when test="$relation='article' or @pubwork='article'">
      <xsl:call-template name="gentext.startquote"/>
      <xsl:apply-templates/>
      <xsl:call-template name="gentext.endquote"/>
    </xsl:when>
    <xsl:otherwise>
      <em xmlns:xslo="http://www.w3.org/1999/XSL/Transform"><xsl:apply-templates/></em>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:copy-of select="$biblioentry.item.separator"/>
</xsl:template><xsl:template match="citetitle" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:choose>
      <xsl:when test="@pubwork = 'article'">
        <xsl:call-template name="gentext.startquote"/>
        <xsl:call-template name="inline.charseq"/>
        <xsl:call-template name="gentext.endquote"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="inline.italicseq"/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="collab" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="collabname" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="confgroup" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="confdates" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="conftitle" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="confnum" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="confsponsor" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="contractnum" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="contractsponsor" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="contrib" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="copyright" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="gentext">
      <xsl:with-param name="key" select="'Copyright'"/>
    </xsl:call-template>
    <xsl:call-template name="gentext.space"/>
    <xsl:call-template name="dingbat">
      <xsl:with-param name="dingbat">copyright</xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="gentext.space"/>
    <xsl:apply-templates select="year" mode="bibliography.mode"/>
    <xsl:if test="holder">
      <xsl:call-template name="gentext.space"/>
      <xsl:apply-templates select="holder" mode="bibliography.mode"/>
    </xsl:if>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="year" mode="bibliography.mode">
  <xsl:apply-templates/><xsl:text>, </xsl:text>
</xsl:template><xsl:template match="year[position()=last()]" mode="bibliography.mode">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="holder" mode="bibliography.mode">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="corpauthor" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="corpcredit" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="corpname" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="date" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="edition" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="editor" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="person.name"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="firstname" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="honorific" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="indexterm" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="invpartnumber" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="isbn" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="issn" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="issuenum" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="lineage" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="orgname" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="orgdiv" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="othercredit" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="othername" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="pagenums" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="printhistory" mode="bibliography.mode">
  <!-- suppressed -->
</xsl:template><xsl:template match="productname" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="productnumber" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="pubdate" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="publisher" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
  </span>
</xsl:template><xsl:template match="publishername" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="pubsnumber" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="releaseinfo" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="revhistory" mode="bibliography.mode">
  <!-- suppressed; how could this be represented? -->
</xsl:template><xsl:template match="seriesinfo" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
  </span>
</xsl:template><xsl:template match="seriesvolnums" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="subtitle" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="surname" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="title" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <em xmlns:xslo="http://www.w3.org/1999/XSL/Transform"><xsl:apply-templates mode="bibliography.mode"/></em>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="titleabbrev" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="volumenum" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="bibliocoverage|biblioid|bibliorelation|bibliosource" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliography.mode"/>
    <xsl:copy-of select="$biblioentry.item.separator"/>
  </span>
</xsl:template><xsl:template match="biblioid[@class='doi']" mode="bibliography.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <a href="{concat('http://dx.doi.org/', .)}">doi:<xsl:value-of select="."/></a>
  </span>
</xsl:template><xsl:template match="*" mode="bibliomixed.mode">
  <xsl:apply-templates select="."/><!-- try the default mode -->
</xsl:template><xsl:template match="abbrev" mode="bibliomixed.mode">
  <xsl:if test="preceding-sibling::*">
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </xsl:if>
</xsl:template><xsl:template match="abstract" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="address" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="affiliation" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="shortaffil" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="jobtitle" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="artpagenums" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="author" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:choose>
      <xsl:when test="orgname">
        <xsl:apply-templates select="orgname" mode="bibliomixed.mode"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="person.name"/>
      </xsl:otherwise>
    </xsl:choose>
  </span>
</xsl:template><xsl:template match="authorblurb|personblurb" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="authorgroup" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="authorinitials" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="bibliomisc" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="bibliomset" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="bibliomset/title|bibliomset/citetitle" mode="bibliomixed.mode">
  <xsl:variable name="relation" select="../@relation"/>
  <xsl:choose>
    <xsl:when test="$relation='article' or @pubwork='article'">
      <xsl:call-template name="gentext.startquote"/>
      <xsl:apply-templates/>
      <xsl:call-template name="gentext.endquote"/>
    </xsl:when>
    <xsl:otherwise>
      <em xmlns:xslo="http://www.w3.org/1999/XSL/Transform"><xsl:apply-templates/></em>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="biblioset" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="citetitle" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:choose>
      <xsl:when test="@pubwork = 'article'">
        <xsl:call-template name="gentext.startquote"/>
        <xsl:call-template name="inline.charseq"/>
        <xsl:call-template name="gentext.endquote"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="inline.italicseq"/>
      </xsl:otherwise>
    </xsl:choose>
  </span>
</xsl:template><xsl:template match="collab" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="confgroup" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="contractnum" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="contractsponsor" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="contrib" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="copyright" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="corpauthor" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="corpcredit" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="corpname" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="date" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="edition" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="editor" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="firstname" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="honorific" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="indexterm" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="invpartnumber" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="isbn" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="issn" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="issuenum" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="lineage" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="orgname" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="othercredit" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="othername" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="pagenums" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="printhistory" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="productname" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="productnumber" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="pubdate" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="publisher" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="publishername" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="pubsnumber" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="releaseinfo" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="revhistory" mode="bibliomixed.mode">
  <!-- suppressed; how could this be represented? -->
</xsl:template><xsl:template match="seriesvolnums" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="subtitle" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="surname" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="title" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="titleabbrev" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="volumenum" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="bibliocoverage|biblioid|bibliorelation|bibliosource" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="bibliomixed.mode"/>
  </span>
</xsl:template><xsl:template match="biblioid[@class='doi']" mode="bibliomixed.mode">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <a href="{concat('http://dx.doi.org/', .)}">doi:<xsl:value-of select="."/></a>
  </span>
</xsl:template>
<xsl:param name="biblioentry.alt.primary.seps" select="0"/><xsl:param name="biblioentry.primary.count" select="1"/><xsl:template name="iso690.makecitation">
<!-- Types of resources -->
  <xsl:choose>

    <!-- SYSTEMS OF ELECTRONIC COMMUNICATION : ENTIRE MESSAGE SYSTEM -->
    <!-- same as Monographs -->
    <xsl:when test="./@role='messagesystem'">
      <xsl:call-template name="iso690.monogr"/>
    </xsl:when>

    <!-- SYSTEMS OF ELECTRONIC COMMUNICATION : ELECTRONIC MESSAGES -->
    <!-- same as Contributions to Monographs -->
    <xsl:when test="./@role='message'">
      <xsl:call-template name="iso690.paper.mon"/>
    </xsl:when>

    <!-- SERIALS -->
    <xsl:when test="./@role='serial' or ./biblioid/@class='issn' or ./issn">
      <xsl:call-template name="iso690.serial"/>
    </xsl:when>

    <!-- PARTS OF MONOGRAPHS -->
    <xsl:when test="./@role='part' or (./bibliomisc[@role='secnum']|./bibliomisc[@role='sectitle'])">
      <xsl:call-template name="iso690.monogr.part"/>
    </xsl:when>

    <!-- CONTRIBUTIONS TO MONOGRAPHS -->
    <xsl:when test="./@role='contribution' or (./biblioset/@relation='part' and ./biblioset/@relation='book')">
      <xsl:call-template name="iso690.paper.mon"/>
    </xsl:when>

    <!-- ARTICLES, ETC., IN SERIALS -->
    <xsl:when test="./@role='article' or (./biblioset/@relation='journal' and ./biblioset/@relation='article')">
      <xsl:call-template name="iso690.article"/>
    </xsl:when>

    <!-- PATENT DOCUMENTS -->
    <xsl:when test="./@role='patent' or (./bibliomisc[@role='patenttype'] and ./bibliomisc[@role='patentnum'])">
      <xsl:call-template name="iso690.patent"/>
    </xsl:when>

    <!-- MONOGRAPHS -->
    <xsl:otherwise>
      <xsl:call-template name="iso690.monogr"/>
    </xsl:otherwise>

  </xsl:choose>
</xsl:template><xsl:template name="iso690.monogr">
  <!-- Primary responsibility -->
  <xsl:call-template name="iso690.primary"/>
  <!-- Title and Type of medium -->
  <xsl:call-template name="iso690.title"/>
  <!-- Subordinate responsibility -->
  <xsl:call-template name="iso690.secondary"/>
  <!-- Edition -->
  <xsl:call-template name="iso690.edition"/>
  <!-- Place of publication, Publisher, Year/Date of publication, Date of update/revision, Date of citation -->
  <xsl:call-template name="iso690.pub"/>
  <!-- Extent -->
  <xsl:call-template name="iso690.extent"/>
  <!-- Series -->
  <xsl:call-template name="iso690.serie"/>
  <!-- Notes -->
  <xsl:call-template name="iso690.notice"/>
  <!-- Avaibility and access -->
  <xsl:call-template name="iso690.access"/>
  <!-- Standard number -->
  <xsl:call-template name="iso690.isbn"/>
</xsl:template><xsl:template name="iso690.serial">
  <!-- Title and Type of medium -->
  <xsl:call-template name="iso690.title"/>
  <!-- Responsibility [nonEL] -->
  <xsl:if test="not(./bibliomisc[@role='medium'])">
    <xsl:call-template name="iso690.secondary"/>
  </xsl:if>
  <!-- Edition -->
  <xsl:call-template name="iso690.edition">
    <xsl:with-param name="after" select="./bibliomisc[@role='issuing']"/>
  </xsl:call-template>
  <!-- Issue designation (date and/or num) [nonEL] -->
  <xsl:if test="not(./bibliomisc[@role='medium'])">
    <xsl:call-template name="iso690.issuing"/>
  </xsl:if>
  <!-- Place of publication, Publisher, Year/Date of publication, Date of update/revision, Date of citation -->
  <xsl:call-template name="iso690.pub"/>
  <!-- Series -->
  <xsl:call-template name="iso690.serie"/>
  <!-- Notes -->
  <xsl:call-template name="iso690.notice"/>
  <!-- Avaibility and access -->
  <xsl:call-template name="iso690.access"/>
  <!-- Standard number -->
  <xsl:call-template name="iso690.issn"/>
</xsl:template><xsl:template name="iso690.monogr.part">
  <!-- Primary responsibility of host document -->
  <xsl:call-template name="iso690.primary"/>
  <!-- Title and Type of medium of host document -->
  <xsl:call-template name="iso690.title"/>
  <!-- Subordinate responsibility of host document [EL] -->
  <xsl:if test="./bibliomisc[@role='medium']">
    <xsl:call-template name="iso690.secondary"/>
  </xsl:if>
  <!-- Edition -->
  <xsl:call-template name="iso690.edition">
    <xsl:with-param name="after" select="./volumenum"/>
  </xsl:call-template>
  <!-- Numeration of the part [nonEL]-->
  <xsl:if test="not(./bibliomisc[@role='medium'])">
    <xsl:call-template name="iso690.partnr"/>
  <!-- Subordinate responsibility [nonEL] -->
    <xsl:call-template name="iso690.secondary"/>
  </xsl:if>
  <!-- Place of publication, Publisher, Year/Date of publication, Date of update/revision, Date of citation -->
  <xsl:call-template name="iso690.pub"/>
  <!-- Location within host -->
  <xsl:call-template name="iso690.part.location"/>
  <xsl:if test="./bibliomisc[@role='medium']">
  <!-- Numeration within host document [EL] -->
  <!-- Notes [EL] -->
    <xsl:call-template name="iso690.notice"/>
  <!-- Avaibility and access [EL] -->
    <xsl:call-template name="iso690.access"/>
  <!-- Standard number [EL] -->
    <xsl:call-template name="iso690.isbn"/>
  </xsl:if>
</xsl:template><xsl:template name="iso690.paper.mon">
<!-- Contribution -->
  <xsl:apply-templates mode="iso690.paper.part" select="./biblioset[@relation='part']"/>
<!-- In -->
  <xsl:text>In </xsl:text>
<!-- Host -->
  <xsl:apply-templates mode="iso690.paper.book" select="./biblioset[@relation='book']"/>
</xsl:template><xsl:template match="biblioset" mode="iso690.paper.part">
<!-- Contribution -->
  <!-- Primary responsibility -->
  <xsl:call-template name="iso690.primary"/>
  <!-- Title -->
  <xsl:call-template name="iso690.title">
    <xsl:with-param name="italic" select="0"/>
  </xsl:call-template>
</xsl:template><xsl:template match="biblioset" mode="iso690.paper.book">
<!-- Host -->
  <!-- Primary responsibility -->
  <xsl:call-template name="iso690.primary"/>
  <!-- Title and Type of medium -->
  <xsl:call-template name="iso690.title"/>
  <!-- Subordinate responsibility [EL] -->
  <xsl:if test="./bibliomisc[@role='medium']">
    <xsl:call-template name="iso690.secondary"/>
  </xsl:if>
  <!-- Edition -->
  <xsl:call-template name="iso690.edition"/>
  <!-- Place of publication, Publisher, Year/Date of publication, Date of update/revision, Date of citation -->
  <xsl:call-template name="iso690.paper.pub"/>
  <!-- Numeration within host document [EL] -->
  <!-- Location within host -->
  <xsl:call-template name="iso690.location"/>
  <xsl:if test="./bibliomisc[@role='medium']">
  <!-- Notes [EL] -->
    <xsl:call-template name="iso690.notice"/>
  <!-- Avaibility and access [EL] -->
    <xsl:call-template name="iso690.access"/>
  <!-- Standard number [EL] -->
    <xsl:call-template name="iso690.isbn"/>
  </xsl:if>
</xsl:template><xsl:template name="iso690.article">
<!-- Article -->
  <xsl:apply-templates mode="iso690.article.art" select="./biblioset[@relation='article']"/>
<!-- Serial -->
  <xsl:apply-templates mode="iso690.article.jour" select="./biblioset[@relation='journal']"/>
</xsl:template><xsl:template match="biblioset" mode="iso690.article.art">
<!-- Article -->
  <!-- Primary responsibility -->
  <xsl:call-template name="iso690.primary"/>
  <!-- Title -->
  <xsl:call-template name="iso690.title">
    <xsl:with-param name="italic" select="0"/>
  </xsl:call-template>
  <!-- Subordinate responsibility [nonEL] -->
  <xsl:if test="not(../*/bibliomisc[@role='medium'])">
    <xsl:call-template name="iso690.secondary"/>
  </xsl:if>
</xsl:template><xsl:template match="biblioset" mode="iso690.article.jour">
<!-- Serial -->
  <!-- Title and Type of medium -->
  <xsl:call-template name="iso690.title"/>
  <!-- Edition -->
  <xsl:call-template name="iso690.edition">
    <xsl:with-param name="after" select="./pubdate[not(@role='issuing')]|./volumenum|./issuenum|./pagenums"/>
  </xsl:call-template>
  <!-- Number designation [EL] -->
  <!-- Location within host -->
  <xsl:call-template name="iso690.article.location"/>
  <xsl:if test="./bibliomisc[@role='medium']">
  <!-- Notes [EL] -->
    <xsl:call-template name="iso690.notice"/>
  <!-- Avaibility and access [EL] -->
    <xsl:call-template name="iso690.access"/>
  <!-- Standard number [EL] -->
    <xsl:call-template name="iso690.issn"/>
  </xsl:if>
</xsl:template><xsl:template name="iso690.patent">
  <!-- Primary responsibility (applicant) -->
  <xsl:call-template name="iso690.primary"/>
  <!-- Title of the invention -->
  <xsl:call-template name="iso690.title"/>
  <!-- Subordinate responsibility -->
  <xsl:call-template name="iso690.secondary"/>
  <!-- Notes -->
  <xsl:call-template name="iso690.notice"/>
  <!-- Identification -->
  <xsl:call-template name="iso690.pat.ident"/>
</xsl:template><xsl:template name="iso690.primary">
  <xsl:param name="primary.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'primary.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:choose>
    <xsl:when test="./authorgroup/author|./author">
      <xsl:call-template name="iso690.author.list">
        <xsl:with-param name="person.list" select=".//authorgroup/author|.//author"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="./authorgroup/editor|./editor">
      <xsl:call-template name="iso690.author.list">
        <xsl:with-param name="person.list" select=".//authorgroup/editor|.//editor"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="./authorgroup/corpauthor|./corpauthor">
      <xsl:call-template name="iso690.author.list">
        <xsl:with-param name="person.list" select=".//authorgroup/corpauthor|.//corpauthor"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:if test="(./firstname)and(./surname)">
        <xsl:call-template name="iso690.author"/>
        <xsl:call-template name="iso690.endsep">
          <xsl:with-param name="text" select="string(./firstname[1])"/>
          <xsl:with-param name="sep" select="$primary.sep"/>
        </xsl:call-template>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="iso690.author.list">
  <xsl:param name="person.list" select="author|corpauthor|editor"/>
  <xsl:param name="person.count" select="count($person.list)"/>
  <xsl:param name="count" select="1"/>
  <xsl:param name="group" select="./authorgroup[@role='many']"/>
  <xsl:param name="many" select="0"/>

  <xsl:param name="primary.many">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'primary.many'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="primary.editor">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'primary.editor'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="primary.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'primary.sep'"/></xsl:call-template>
  </xsl:param>

  <xsl:choose>
    <xsl:when test="$count &gt; $person.count"/>
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="$person.count &lt; 4 and not($group)">
          <xsl:call-template name="iso690.author">
            <xsl:with-param name="node" select="$person.list[position()=$count]"/>
          </xsl:call-template>
          <xsl:choose>
            <xsl:when test="$person.count = 2 and $count = 1 and $biblioentry.alt.primary.seps != 0">
              <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'alt.person.two.sep'"/></xsl:call-template>
            </xsl:when>
            <xsl:when test="$person.count = 2 and $count = 1">
              <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'authorgroup'"/>
                <xsl:with-param name="name" select="'sep2'"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:when test="$person.count &gt; 2 and $count+1 = $person.count and $biblioentry.alt.primary.seps != 0">
              <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'alt.person.last.sep'"/></xsl:call-template>
            </xsl:when>
            <xsl:when test="$person.count &gt; 2 and $count+1 = $person.count">
              <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'authorgroup'"/>
                <xsl:with-param name="name" select="'seplast'"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:when test="$count &lt; $person.count and $biblioentry.alt.primary.seps != 0">
              <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'alt.person.more.sep'"/></xsl:call-template>
            </xsl:when>
            <xsl:when test="$count &lt; $person.count">
              <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'authorgroup'"/>
                <xsl:with-param name="name" select="'sep'"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:when test="($count = $person.count)">
              <xsl:choose>
                <xsl:when test="$many!=0">
                  <xsl:if test="name($person.list[position()=$count])='editor'">
                    <xsl:value-of select="$primary.editor"/>
                  </xsl:if>
                  <xsl:value-of select="$primary.many"/>
                  <xsl:call-template name="iso690.endsep">
                    <xsl:with-param name="text" select="$primary.many"/>
                    <xsl:with-param name="sep" select="$primary.sep"/>
                  </xsl:call-template>
                </xsl:when>
                <xsl:when test="name($person.list[position()=$count])='editor'">
                  <xsl:value-of select="$primary.editor"/>
                  <xsl:value-of select="$primary.sep"/>
                </xsl:when>
                <xsl:when test="name($person.list[position()=$count])='corpauthor'">
                  <xsl:call-template name="iso690.endsep">
                    <xsl:with-param name="text" select="string($person.list[position()=$count])"/>
                    <xsl:with-param name="sep" select="$primary.sep"/>
                  </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:call-template name="iso690.endsep">
                    <xsl:with-param name="text" select="string($person.list[position()=$count]//firstname[1])"/>
                    <xsl:with-param name="sep" select="$primary.sep"/>
                  </xsl:call-template>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
          </xsl:choose>

          <xsl:call-template name="iso690.author.list">
            <xsl:with-param name="person.list" select="$person.list"/>
            <xsl:with-param name="person.count" select="$person.count"/>
            <xsl:with-param name="count" select="$count+1"/>
            <xsl:with-param name="many" select="$many"/>
            <xsl:with-param name="group"/>
          </xsl:call-template>
        </xsl:when>

        <xsl:otherwise>
          <xsl:choose>
            <xsl:when test="($biblioentry.primary.count&gt;=3) and ($person.count&gt;=3)">
              <xsl:call-template name="iso690.author.list">
                <xsl:with-param name="person.list" select="$person.list[1]|$person.list[2]|$person.list[3]"/>
                <xsl:with-param name="person.count" select="3"/>
                <xsl:with-param name="count" select="1"/>
                <xsl:with-param name="many" select="1"/>
                <xsl:with-param name="group"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:when test="($biblioentry.primary.count&gt;1) and  ($person.count&gt;1)">
              <xsl:call-template name="iso690.author.list">
                <xsl:with-param name="person.list" select="$person.list[1]|$person.list[2]"/>
                <xsl:with-param name="person.count" select="2"/>
                <xsl:with-param name="count" select="1"/>
                <xsl:with-param name="many" select="1"/>
                <xsl:with-param name="group"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:call-template name="iso690.author.list">
                <xsl:with-param name="person.list" select="$person.list[1]"/>
                <xsl:with-param name="person.count" select="1"/>
                <xsl:with-param name="count" select="1"/>
                <xsl:with-param name="many" select="1"/>
                <xsl:with-param name="group"/>
              </xsl:call-template>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="iso690.author">
  <xsl:param name="node" select="."/>
  <xsl:param name="lastfirst.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'lastfirst.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:choose>
    <xsl:when test="name($node)!='corpauthor'">
      <span style="text-transform:uppercase">
        <xsl:apply-templates mode="iso690.mode" select="$node//surname[1]"/>
      </span>
      <xsl:if test="$node//surname and $node//firstname">
        <xsl:value-of select="$lastfirst.sep"/>
      </xsl:if>
      <xsl:apply-templates mode="iso690.mode" select="$node//firstname[1]"/>
    </xsl:when>
    <xsl:otherwise>
      <span style="text-transform:uppercase">
        <xsl:apply-templates mode="iso690.mode" select="$node"/>
      </span>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="corpauthor|firstname|surname" mode="iso690.mode">
  <xsl:apply-templates mode="iso690.mode"/>
</xsl:template><xsl:template name="iso690.title">
  <xsl:param name="medium" select="./bibliomisc[@role='medium']"/>
  <xsl:param name="italic" select="1"/>
  <xsl:param name="sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'title.sep'"/></xsl:call-template>
  </xsl:param>

  <xsl:apply-templates mode="iso690.mode" select="./title">
    <xsl:with-param name="medium" select="$medium"/>
    <xsl:with-param name="italic" select="$italic"/>
    <xsl:with-param name="sep" select="$sep"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="title" mode="iso690.mode">
  <xsl:param name="medium"/>
  <xsl:param name="italic" select="1"/>
  <xsl:param name="sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'title.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="medium1">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'medium1'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="medium2">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'medium2'"/></xsl:call-template>
  </xsl:param>
  <xsl:choose>
    <xsl:when test="$italic=1">
      <xsl:call-template name="iso690.italic.title"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="iso690.make.title"/>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:if test="$medium">
    <xsl:value-of select="$medium1"/>
    <xsl:apply-templates mode="iso690.mode" select="$medium"/>
    <xsl:value-of select="$medium2"/>
  </xsl:if>
  <xsl:call-template name="iso690.endsep">
    <xsl:with-param name="text" select="concat(string(.),string(../subtitle))"/>
    <xsl:with-param name="sep" select="$sep"/>
  </xsl:call-template>
</xsl:template><xsl:template name="iso690.italic.title">
  <em xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
    <xsl:call-template name="iso690.make.title"/>
  </em>
</xsl:template><xsl:template name="iso690.make.title">
  <xsl:param name="submaintitle.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'submaintitle.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:apply-templates mode="iso690.mode"/>
  <xsl:if test="../subtitle|../info/subtitle">
    <xsl:value-of select="$submaintitle.sep"/>
    <xsl:apply-templates mode="iso690.mode" select="../subtitle|../info/subtitle"/>
  </xsl:if>
</xsl:template><xsl:template match="subtitle" mode="iso690.mode">
  <xsl:apply-templates mode="iso690.mode"/>
</xsl:template><xsl:template match="bibliomisc[@role='medium']" mode="iso690.mode">
  <xsl:apply-templates mode="iso690.mode"/>
</xsl:template><xsl:template name="iso690.secondary">
  <xsl:param name="secondary.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'secondary.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="secondary.person.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'secondary.person.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:for-each select="./bibliomisc[@role='secondary']">
    <xsl:apply-templates mode="iso690.mode" select="."/>
    <xsl:choose>
      <xsl:when test="position()=count(../bibliomisc[@role='secondary'])">
        <xsl:call-template name="iso690.endsep">
          <xsl:with-param name="text" select="string(.)"/>
          <xsl:with-param name="sep" select="$secondary.sep"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$secondary.person.sep"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each>
</xsl:template><xsl:template match="bibliomisc[@role='secondary']" mode="iso690.mode">
  <xsl:apply-templates mode="iso690.mode"/>
</xsl:template><xsl:template name="iso690.edition">
  <xsl:param name="after"/>
  <xsl:param name="edition.serial.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'edition.serial.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:choose>
    <xsl:when test="string($after)!=''">
      <xsl:apply-templates mode="iso690.mode" select="./edition">
        <xsl:with-param name="sep" select="$edition.serial.sep"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="iso690.mode" select="./edition"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="edition" mode="iso690.mode">
  <xsl:param name="sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'edition.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:apply-templates mode="iso690.mode"/>
  <xsl:call-template name="iso690.endsep">
    <xsl:with-param name="text" select="string(.)"/>
    <xsl:with-param name="sep" select="$sep"/>
  </xsl:call-template>
</xsl:template><xsl:template name="iso690.issuing">
  <xsl:param name="issuing.div">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'issuing.div'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="issuing.range">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'issuing.range'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="issuing.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'issuing.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:choose>
    <xsl:when test="./pubdate[@role='issuing'] and ./volumenum[2] and ./issuenum[2]">
      <xsl:call-template name="iso690.issuedate"/>
      <xsl:apply-templates mode="iso690.mode" select="./volumenum[1]">
        <xsl:with-param name="sep" select="$issuing.div"/>
      </xsl:apply-templates>
      <xsl:apply-templates mode="iso690.mode" select="./issuenum[1]">
        <xsl:with-param name="sep" select="$issuing.range"/>
      </xsl:apply-templates>
      <xsl:apply-templates mode="iso690.mode" select="./volumenum[2]">
        <xsl:with-param name="sep" select="$issuing.div"/>
      </xsl:apply-templates>
      <xsl:apply-templates mode="iso690.mode" select="./issuenum[2]">
        <xsl:with-param name="sep" select="$issuing.sep"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:when test="./pubdate[@role='issuing'] and ./volumenum[2]">
      <xsl:call-template name="iso690.issuedate"/>
      <xsl:apply-templates mode="iso690.mode" select="./volumenum[1]">
        <xsl:with-param name="sep" select="$issuing.range"/>
      </xsl:apply-templates>
      <xsl:apply-templates mode="iso690.mode" select="./volumenum[2]">
        <xsl:with-param name="sep" select="$issuing.sep"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:when test="./pubdate[@role='issuing'] and ./volumenum and ./issuenum">
      <xsl:apply-templates mode="iso690.mode" select="./pubdate[@role='issuing']">
        <xsl:with-param name="sep" select="$issuing.div"/>
      </xsl:apply-templates>
      <xsl:apply-templates mode="iso690.mode" select="./volumenum">
        <xsl:with-param name="sep" select="$issuing.div"/>
      </xsl:apply-templates>
      <xsl:apply-templates mode="iso690.mode" select="./issuenum">
        <xsl:with-param name="sep" select="$issuing.sep"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:when test="./pubdate[@role='issuing']">
      <xsl:apply-templates mode="iso690.mode" select="./pubdate[@role='issuing']">
        <xsl:with-param name="sep" select="$issuing.sep"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:when test="./volumenum">
      <xsl:apply-templates mode="iso690.mode" select="./volumenum">
        <xsl:with-param name="sep" select="$issuing.sep"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:when test="./issuenum">
      <xsl:apply-templates mode="iso690.mode" select="./issuenum">
        <xsl:with-param name="sep" select="$issuing.sep"/>
      </xsl:apply-templates>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template name="iso690.issuedate">
  <xsl:param name="issuing.div">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'issuing.div'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="issuing.range">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'issuing.range'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="issuing.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'issuing.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:choose>
    <xsl:when test="./pubdate[@role='issuing'][2]">
      <xsl:apply-templates mode="iso690.mode" select="./pubdate[@role='issuing'][1]">
        <xsl:with-param name="sep" select="$issuing.range"/>
      </xsl:apply-templates>
      <xsl:apply-templates mode="iso690.mode" select="./pubdate[@role='issuing'][2]">
        <xsl:with-param name="sep" select="$issuing.div"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="iso690.mode" select="./pubdate[@role='issuing']">
        <xsl:with-param name="sep" select="$issuing.div"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="pubdate[@role='issuing']" mode="iso690.mode">
  <xsl:param name="sep"/>
  <xsl:variable name="substr" select="substring(string(.),string-length(string(.)))"/>
  <xsl:apply-templates mode="iso690.mode"/>
  <xsl:call-template name="iso690.space">
    <xsl:with-param name="text" select="$substr"/>
  </xsl:call-template>
  <xsl:choose>
    <xsl:when test="$substr='-'">
      <xsl:call-template name="iso690.endsep">
        <xsl:with-param name="text" select="' '"/>
        <xsl:with-param name="sep" select="$sep"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="iso690.endsep">
        <xsl:with-param name="text" select="string(.)"/>
        <xsl:with-param name="sep" select="$sep"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="iso690.partnr">
  <xsl:param name="partnr.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'partnr.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:apply-templates mode="iso690.mode" select="./volumenum">
    <xsl:with-param name="sep" select="$partnr.sep"/>
  </xsl:apply-templates>
</xsl:template><xsl:template name="iso690.pub">
  <xsl:param name="onlydate" select="0"/>
  <xsl:param name="placesep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'placepubl.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="pubsep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'publyear.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="endsep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'pubinfo.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:choose>
    <xsl:when test="(./publisher/publishername|./publishername|./publisher/address/city)and($onlydate=0)and(./pubdate[not(@role='issuing')]|./copyright/year|./date[@role='upd']|./date[@role='upd'])">
      <xsl:apply-templates mode="iso690.mode" select="./publisher/address/city">
        <xsl:with-param name="sep" select="$placesep"/>
      </xsl:apply-templates>
      <xsl:apply-templates mode="iso690.mode" select="./publisher/publishername|./publishername">
        <xsl:with-param name="sep" select="$pubsep"/>
      </xsl:apply-templates>
      <xsl:apply-templates mode="iso690.mode" select="./pubdate[not(@role='issuing')]|./copyright/year">
        <xsl:with-param name="sep" select="$endsep"/>
      </xsl:apply-templates>
      <xsl:if test="not(./pubdate[not(@role='issuing')]|./copyright/year)">
        <xsl:call-template name="iso690.data">
          <xsl:with-param name="sep" select="$endsep"/>
        </xsl:call-template>
      </xsl:if>
    </xsl:when>
    <xsl:when test="(./publisher/publishername|./publishername)and(./publisher/address/city)and($onlydate=0)">
      <xsl:apply-templates mode="iso690.mode" select="./publisher/address/city">
        <xsl:with-param name="sep" select="$placesep"/>
      </xsl:apply-templates>
      <xsl:apply-templates mode="iso690.mode" select="./publisher/publishername|./publishername">
        <xsl:with-param name="sep" select="$endsep"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:when test="($onlydate=1)or(./pubdate[not(@role='issuing')]|./copyright/year)">
      <xsl:apply-templates mode="iso690.mode" select="./pubdate[not(@role='issuing')]|./copyright/year">
        <xsl:with-param name="sep" select="$endsep"/>
      </xsl:apply-templates>
      <xsl:if test="$onlydate=1">
        <xsl:call-template name="iso690.location">
          <xsl:with-param name="onlypages" select="1"/>
        </xsl:call-template>
      </xsl:if>
    </xsl:when>
    <xsl:when test="not(./pubdate[not(@role='issuing')]|./copyright/year)">
      <xsl:call-template name="iso690.data">
        <xsl:with-param name="sep" select="$endsep"/>
      </xsl:call-template>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template name="iso690.paper.pub">
  <xsl:param name="spec.pubinfo.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'spec.pubinfo.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:choose>
    <xsl:when test="./volumnum|./issuenum|./pagenums">
      <xsl:call-template name="iso690.pub">
        <xsl:with-param name="endsep" select="$spec.pubinfo.sep"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="iso690.pub"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="iso690.data">
  <xsl:param name="sep"/>
  <xsl:param name="datecit2">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'datecit2'"/></xsl:call-template>
  </xsl:param>
  <xsl:apply-templates mode="iso690.mode" select="./date[@role='upd']">
    <xsl:with-param name="sep"/>
  </xsl:apply-templates>
  <xsl:apply-templates mode="iso690.mode" select="./date[@role='cit']"/>
  <xsl:choose>
    <xsl:when test="./date[@role='cit']">
      <xsl:call-template name="iso690.endsep">
        <xsl:with-param name="text" select="$datecit2"/>
        <xsl:with-param name="sep" select="$sep"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="./date[@role='upd']">
      <xsl:call-template name="iso690.endsep">
        <xsl:with-param name="text" select="string(./date[@role='upd'])"/>
        <xsl:with-param name="sep" select="$sep"/>
      </xsl:call-template>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="publisher/address/city|publishername" mode="iso690.mode">
  <xsl:param name="sep"/>
  <xsl:param name="upd" select="0"/>
  <xsl:apply-templates mode="iso690.mode"/>
  <xsl:call-template name="iso690.endsep">
    <xsl:with-param name="text" select="string(.)"/>
    <xsl:with-param name="sep" select="$sep"/>
  </xsl:call-template>
</xsl:template><xsl:template match="pubdate|copyright/year" mode="iso690.mode">
  <xsl:param name="sep"/>
  <xsl:param name="upd" select="1"/>
  <xsl:param name="datecit2">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'datecit2'"/></xsl:call-template>
  </xsl:param>
  <xsl:variable name="substr" select="substring(string(.),string-length(string(.)))"/>
  <xsl:if test="name(.)!='pubdate'">
    <xsl:value-of select="'&#xA9;'"/><!-- copyright -->
  </xsl:if>
  <xsl:apply-templates mode="iso690.mode"/>
  <xsl:call-template name="iso690.space">
    <xsl:with-param name="text" select="$substr"/>
  </xsl:call-template>
  <xsl:if test="$upd!=0">
    <xsl:choose>
      <xsl:when test="name(.)='pubdate'">
        <xsl:apply-templates mode="iso690.mode" select="../date[@role='upd']"/>
        <xsl:apply-templates mode="iso690.mode" select="../date[@role='cit']"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates mode="iso690.mode" select="../../date[@role='upd']"/>
        <xsl:apply-templates mode="iso690.mode" select="../../date[@role='cit']"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
  <xsl:choose>
    <xsl:when test="../date[@role='cit']|../../date[@role='cit'] and $upd!=0">
      <xsl:call-template name="iso690.endsep">
        <xsl:with-param name="text" select="$datecit2"/>
        <xsl:with-param name="sep" select="$sep"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="../date[@role='upd']|../../date[@role='upd'] and $upd!=0">
      <xsl:call-template name="iso690.endsep">
        <xsl:with-param name="text" select="string(../date[@role='upd'])"/>
        <xsl:with-param name="sep" select="$sep"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$substr='-'">
      <xsl:call-template name="iso690.endsep">
        <xsl:with-param name="text" select="' '"/>
        <xsl:with-param name="sep" select="$sep"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="iso690.endsep">
        <xsl:with-param name="text" select="string(.)"/>
        <xsl:with-param name="sep" select="$sep"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="iso690.space">
  <xsl:param name="text" select="substring(string(.),string-length(string(.)))"/>
  <xsl:if test="$text='-'">
    <xsl:value-of select="' '"/>
  </xsl:if>
</xsl:template><xsl:template match="date[@role='upd']" mode="iso690.mode">
  <xsl:param name="sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'upd.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:value-of select="$sep"/>
  <xsl:apply-templates mode="iso690.mode"/>
</xsl:template><xsl:template match="date[@role='cit']" mode="iso690.mode">
  <xsl:param name="datecit1">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'datecit1'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="datecit2">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'datecit2'"/></xsl:call-template>
  </xsl:param>
  <xsl:value-of select="$datecit1"/>
  <xsl:apply-templates mode="iso690.mode"/>
  <xsl:value-of select="$datecit2"/>
</xsl:template><xsl:template name="iso690.extent">
  <xsl:param name="extent.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'extent.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:apply-templates mode="iso690.mode" select="./pagenums">
    <xsl:with-param name="sep" select="$extent.sep"/>
  </xsl:apply-templates>
</xsl:template><xsl:template name="iso690.part.location">
  <xsl:param name="location.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'location.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:choose>
    <xsl:when test="./pagenums">
      <xsl:apply-templates mode="iso690.mode" select="./bibliomisc[@role='secnum']"/>
      <xsl:apply-templates mode="iso690.mode" select="./bibliomisc[@role='sectitle']"/>
      <xsl:apply-templates mode="iso690.mode" select="./pagenums"/>
    </xsl:when>
    <xsl:when test="./bibliomisc[@role='sectitle']">
      <xsl:apply-templates mode="iso690.mode" select="./bibliomisc[@role='secnum']"/>
      <xsl:apply-templates mode="iso690.mode" select="./bibliomisc[@role='sectitle']">
        <xsl:with-param name="sep" select="$location.sep"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="iso690.mode" select="./bibliomisc[@role='secnum']">
        <xsl:with-param name="sep" select="$location.sep"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="iso690.article.location">
  <xsl:param name="location.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'location.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="locs.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'locs.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:choose>
    <xsl:when test="not(./date[@role='upd']|./date[@role='cit'])">
      <xsl:choose>
        <xsl:when test="./volumenum|./issuenum|./pagenums">
          <xsl:apply-templates mode="iso690.mode" select="./pubdate[not(@role='issuing')]">
            <xsl:with-param name="upd" select="0"/>
            <xsl:with-param name="sep" select="$locs.sep"/>
          </xsl:apply-templates>
          <xsl:call-template name="iso690.location"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates mode="iso690.mode" select="./pubdate[not(@role='issuing')]">
            <xsl:with-param name="sep" select="$location.sep"/>
          </xsl:apply-templates>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="./volumenum|./issuenum|./pagenums">
          <xsl:apply-templates mode="iso690.mode" select="./pubdate[not(@role='issuing')]">
            <xsl:with-param name="upd" select="0"/>
            <xsl:with-param name="sep" select="$locs.sep"/>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates mode="iso690.mode" select="./pubdate[not(@role='issuing')]">
            <xsl:with-param name="upd" select="0"/>
            <xsl:with-param name="sep" select="$location.sep"/>
          </xsl:apply-templates>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:choose>
        <xsl:when test="./issuenum">
          <xsl:apply-templates mode="iso690.mode" select="./volumenum"/>
          <xsl:apply-templates mode="iso690.mode" select="./issuenum">
            <xsl:with-param name="sep"/>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates mode="iso690.mode" select="./volumenum">
            <xsl:with-param name="sep"/>
          </xsl:apply-templates>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:choose>
        <xsl:when test="./pagenums">
          <xsl:call-template name="iso690.data">
            <xsl:with-param name="sep" select="$locs.sep"/>
          </xsl:call-template>
          <xsl:apply-templates mode="iso690.mode" select="./pagenums"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="iso690.data">
            <xsl:with-param name="sep" select="$location.sep"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="iso690.location">
  <xsl:param name="location.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'location.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:choose>
    <xsl:when test="./volumenum and not(./issuenum) and not(./pagenums)">
      <xsl:apply-templates mode="iso690.mode" select="./volumenum">
        <xsl:with-param name="sep" select="$location.sep"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:when test="./issuenum and not(./pagenums)">
      <xsl:apply-templates mode="iso690.mode" select="./volumenum"/>
      <xsl:apply-templates mode="iso690.mode" select="./issuenum">
        <xsl:with-param name="sep" select="$location.sep"/>
      </xsl:apply-templates>
    </xsl:when>
    <xsl:when test="./pagenums">
      <xsl:apply-templates mode="iso690.mode" select="./volumenum"/>
      <xsl:apply-templates mode="iso690.mode" select="./issuenum"/>
      <xsl:apply-templates mode="iso690.mode" select="./pagenums"/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="bibliomisc[@role='secnum']|bibliomisc[@role='sectitle']" mode="iso690.mode">
  <xsl:param name="sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'locs.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:apply-templates mode="iso690.mode"/>
  <xsl:call-template name="iso690.endsep">
    <xsl:with-param name="text" select="string(.)"/>
    <xsl:with-param name="sep" select="$sep"/>
  </xsl:call-template>
</xsl:template><xsl:template match="volumenum|issuenum" mode="iso690.mode">
  <xsl:param name="sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'locs.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:apply-templates mode="iso690.mode"/>
  <xsl:call-template name="iso690.endsep">
    <xsl:with-param name="text" select="string(.)"/>
    <xsl:with-param name="sep" select="$sep"/>
  </xsl:call-template>
</xsl:template><xsl:template match="pagenums" mode="iso690.mode">
  <xsl:param name="sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'location.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:apply-templates mode="iso690.mode"/>
  <xsl:call-template name="iso690.endsep">
    <xsl:with-param name="text" select="string(.)"/>
    <xsl:with-param name="sep" select="$sep"/>
  </xsl:call-template>
</xsl:template><xsl:template name="iso690.serie">
  <xsl:apply-templates mode="iso690.mode" select=".//bibliomisc[@role='serie']"/>
</xsl:template><xsl:template name="iso690.notice">
  <xsl:apply-templates mode="iso690.mode" select=".//bibliomisc[not(@role)]"/>
</xsl:template><xsl:template match="bibliomisc[not(@role)]|bibliomisc[@role='serie']" mode="iso690.mode">
  <xsl:param name="notice.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'notice.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:apply-templates mode="iso690.mode"/>
  <xsl:call-template name="iso690.endsep">
    <xsl:with-param name="text" select="string(.)"/>
    <xsl:with-param name="sep" select="$notice.sep"/>
  </xsl:call-template>
</xsl:template><xsl:template name="iso690.access">
  <xsl:for-each select="./biblioid[@class='uri']|./bibliomisc[@role='access']">
    <xsl:choose>
      <xsl:when test="position()=1">
        <xsl:apply-templates mode="iso690.mode" select="."/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates mode="iso690.mode" select=".">
          <xsl:with-param name="firstacc" select="0"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:for-each>
</xsl:template><xsl:template match="biblioid[@class='uri']/ulink|bibliomisc[@role='access']/ulink" mode="iso690.mode">
  <xsl:param name="link1">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'link1'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="link2">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'link2'"/></xsl:call-template>
  </xsl:param>
  <xsl:value-of select="$link1"/>
  <xsl:call-template name="ulink"/>
  <xsl:value-of select="$link2"/>
</xsl:template><xsl:template match="biblioid[@class='uri']|bibliomisc[@role='access']" mode="iso690.mode">
  <xsl:param name="firstacc" select="1"/>
  <xsl:param name="access">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'access'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="acctoo">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'acctoo'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="onwww">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'onwww'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="oninet">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'oninet'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="access.end">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'access.end'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="access.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'access.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:choose>
    <xsl:when test="$firstacc=1">
      <xsl:value-of select="$access"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$acctoo"/>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:choose>
    <xsl:when test="(./ulink)and(string(./ulink)=string(.))">
      <xsl:choose>
        <xsl:when test="(starts-with(./ulink/@url,'http://')or(starts-with(./ulink/@url,'https://')))">
          <xsl:value-of select="$onwww"/>
          <xsl:value-of select="$access.end"/>
          <xsl:apply-templates mode="iso690.mode" select="./ulink"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$oninet"/>
          <xsl:value-of select="$access.end"/>
          <xsl:apply-templates mode="iso690.mode" select="./ulink"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:when test="(./ulink)and(string(./ulink)!=string(.))">
      <xsl:value-of select="text()[1]"/>
      <xsl:call-template name="iso690.endsep">
        <xsl:with-param name="text" select="text()[1]"/>
        <xsl:with-param name="sep" select="$access.end"/>
      </xsl:call-template>
      <xsl:apply-templates mode="iso690.mode" select="./ulink"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="iso690.mode"/>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:value-of select="$access.sep"/>
</xsl:template><xsl:template name="iso690.isbn">
  <xsl:choose>
    <xsl:when test="./biblioid/@class='isbn'">
      <xsl:apply-templates mode="iso690.mode" select="./biblioid[@class='isbn']"/>
    </xsl:when>
    <xsl:when test="./isbn">
      <xsl:apply-templates mode="iso690.mode" select="./isbn"/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="isbn|biblioid[@class='isbn']" mode="iso690.mode">
  <xsl:param name="isbn">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'isbn'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="stdnum.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'stdnum.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:value-of select="$isbn"/>
  <xsl:apply-templates mode="iso690.mode"/>
  <xsl:value-of select="$stdnum.sep"/>
</xsl:template><xsl:template name="iso690.issn">
  <xsl:choose>
    <xsl:when test="./biblioid/@class='issn'">
      <xsl:apply-templates mode="iso690.mode" select="./biblioid[@class='issn']"/>
    </xsl:when>
    <xsl:when test="./issn">
      <xsl:apply-templates mode="iso690.mode" select="./issn"/>
    </xsl:when>
  </xsl:choose>
</xsl:template><xsl:template match="issn|biblioid[@class='issn']" mode="iso690.mode">
  <xsl:param name="issn">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'issn'"/></xsl:call-template>
  </xsl:param>
  <xsl:param name="stdnum.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'stdnum.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:value-of select="$issn"/>
  <xsl:apply-templates mode="iso690.mode"/>
  <xsl:value-of select="$stdnum.sep"/>
</xsl:template><xsl:template name="iso690.pat.ident">
  <xsl:param name="patdate.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'patdate.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:apply-templates mode="iso690.mode" select="./address/country"/>
  <xsl:apply-templates mode="iso690.mode" select="./bibliomisc[@role='patenttype']"/>
  <xsl:choose>
    <xsl:when test="./biblioid[@class='other' and @otherclass='patentnum']">
      <xsl:apply-templates mode="iso690.mode" select="./biblioid[@class='other' and @otherclass='patentnum']"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="iso690.mode" select="./bibliomisc[@role='patentnum']"/>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:apply-templates mode="iso690.mode" select="./pubdate[not(@role='issuing')]">
    <xsl:with-param name="sep" select="$patdate.sep"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="address/country" mode="iso690.mode">
  <xsl:param name="patcountry.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'patcountry.sep'"/></xsl:call-template>
  </xsl:param>
  <em xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
    <xsl:apply-templates mode="iso690.mode"/>
  </em>
  <xsl:value-of select="$patcountry.sep"/>
</xsl:template><xsl:template match="bibliomisc[@role='patenttype']" mode="iso690.mode">
  <xsl:param name="pattype.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'pattype.sep'"/></xsl:call-template>
  </xsl:param>
  <em xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
    <xsl:apply-templates mode="iso690.mode"/>
  </em>
  <xsl:value-of select="$pattype.sep"/>
</xsl:template><xsl:template match="biblioid[@class='other' and @otherclass='patentnum']|bibliomisc[@role='patentnum']" mode="iso690.mode">
  <xsl:param name="patnum.sep">
    <xsl:call-template name="gentext.template"><xsl:with-param name="context" select="'iso690'"/><xsl:with-param name="name" select="'patnum.sep'"/></xsl:call-template>
  </xsl:param>
  <xsl:apply-templates mode="iso690.mode"/>
  <xsl:value-of select="$patnum.sep"/>
</xsl:template><xsl:template name="iso690.endsep">
  <xsl:param name="text"/>
  <xsl:param name="sep" select=". "/>
  <xsl:choose>
    <xsl:when test="substring($text,string-length($text))!=substring($sep,1,1)">
      <xsl:value-of select="$sep"/>
    </xsl:when>
    <xsl:when test="substring($text,string-length($text))=' '">
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="' '"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="*" mode="iso690.mode">
  <xsl:apply-templates select="."/><!-- try the default mode -->
</xsl:template>
<xsl:template match="glossary">
  
<xsl:variable name="language">
  <xsl:call-template name="l10n.language"/>
</xsl:variable>

<xsl:variable name="lowercase">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key">normalize.sort.input</xsl:with-param>
  </xsl:call-template>
</xsl:variable>

<xsl:variable name="uppercase">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key">normalize.sort.output</xsl:with-param>
  </xsl:call-template>
</xsl:variable>

  <xsl:call-template name="id.warning"/>

  <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:call-template name="glossary.titlepage"/>

    <xsl:choose>
      <xsl:when test="glossdiv">
        <xsl:apply-templates select="(glossdiv[1]/preceding-sibling::*)"/>
      </xsl:when>
      <xsl:when test="glossentry">
        <xsl:apply-templates select="(glossentry[1]/preceding-sibling::*)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates/>
      </xsl:otherwise>
    </xsl:choose>

    <xsl:choose>
      <xsl:when test="glossdiv">
        <xsl:apply-templates select="glossdiv"/>
      </xsl:when>
      <xsl:when test="glossentry">
        <dl>
          <xsl:choose>
            <xsl:when test="$glossary.sort != 0">
              <xsl:apply-templates select="glossentry">
				<xsl:sort lang="{$language}" select="normalize-space(translate(concat(@sortas, glossterm[not(parent::glossentry/@sortas) or parent::glossentry/@sortas = '']), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'))"/>
              </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
              <xsl:apply-templates select="glossentry"/>
            </xsl:otherwise>
          </xsl:choose>
        </dl>
      </xsl:when>
      <xsl:otherwise>
        <!-- empty glossary -->
      </xsl:otherwise>
    </xsl:choose>

    <xsl:if test="not(parent::article)">
      <xsl:call-template name="process.footnotes"/>
    </xsl:if>
  </xsl:element>
</xsl:template><xsl:template match="glossary/glossaryinfo"/><xsl:template match="glossary/info"/><xsl:template match="glossary/title"/><xsl:template match="glossary/subtitle"/><xsl:template match="glossary/titleabbrev"/><xsl:template match="glosslist">
  
<xsl:variable name="language">
  <xsl:call-template name="l10n.language"/>
</xsl:variable>

<xsl:variable name="lowercase">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key">normalize.sort.input</xsl:with-param>
  </xsl:call-template>
</xsl:variable>

<xsl:variable name="uppercase">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key">normalize.sort.output</xsl:with-param>
  </xsl:call-template>
</xsl:variable>

  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:if test="blockinfo/title|info/title|title">
      <xsl:call-template name="formal.object.heading"/>
    </xsl:if>
    <dl>
      <xsl:choose>
        <xsl:when test="$glossary.sort != 0">
          <xsl:apply-templates select="glossentry">
				<xsl:sort lang="{$language}" select="normalize-space(translate(concat(@sortas, glossterm[not(parent::glossentry/@sortas) or parent::glossentry/@sortas = '']), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'))"/>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="glossentry"/>
        </xsl:otherwise>
      </xsl:choose>
    </dl>
  </div>
</xsl:template><xsl:template match="glossdiv">
  
<xsl:variable name="language">
  <xsl:call-template name="l10n.language"/>
</xsl:variable>

<xsl:variable name="lowercase">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key">normalize.sort.input</xsl:with-param>
  </xsl:call-template>
</xsl:variable>

<xsl:variable name="uppercase">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key">normalize.sort.output</xsl:with-param>
  </xsl:call-template>
</xsl:variable>

  <xsl:call-template name="id.warning"/>

  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:apply-templates select="(glossentry[1]/preceding-sibling::*)"/>

    <dl>
      <xsl:choose>
        <xsl:when test="$glossary.sort != 0">
          <xsl:apply-templates select="glossentry">
            <xsl:sort lang="{$language}" select="translate(glossterm, $lowercase,                                          $uppercase)"/>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="glossentry"/>
        </xsl:otherwise>
      </xsl:choose>
    </dl>
  </div>
</xsl:template><xsl:template match="glossdiv/title">
  <h3>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:apply-templates/>
  </h3>
</xsl:template><xsl:template match="glossentry">
  <xsl:choose>
    <xsl:when test="$glossentry.show.acronym = 'primary'">
      <dt>
        <xsl:call-template name="id.attribute">
          <xsl:with-param name="conditional">
            <xsl:choose>
              <xsl:when test="$glossterm.auto.link != 0">0</xsl:when>
              <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
        </xsl:call-template>
        <xsl:call-template name="anchor">
          <xsl:with-param name="conditional">
            <xsl:choose>
              <xsl:when test="$glossterm.auto.link != 0">0</xsl:when>
              <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
        </xsl:call-template>

        <xsl:choose>
          <xsl:when test="acronym|abbrev">
            <xsl:apply-templates select="acronym|abbrev"/>
            <xsl:text> (</xsl:text>
            <xsl:apply-templates select="glossterm"/>
            <xsl:text>)</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:apply-templates select="glossterm"/>
          </xsl:otherwise>
        </xsl:choose>
      </dt>
    </xsl:when>
    <xsl:when test="$glossentry.show.acronym = 'yes'">
      <dt>
        <xsl:call-template name="id.attribute">
          <xsl:with-param name="conditional">
            <xsl:choose>
              <xsl:when test="$glossterm.auto.link != 0">0</xsl:when>
              <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
        </xsl:call-template>
        <xsl:call-template name="anchor">
          <xsl:with-param name="conditional">
            <xsl:choose>
              <xsl:when test="$glossterm.auto.link != 0">0</xsl:when>
              <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
        </xsl:call-template>

        <xsl:apply-templates select="glossterm"/>

        <xsl:if test="acronym|abbrev">
          <xsl:text> (</xsl:text>
          <xsl:apply-templates select="acronym|abbrev"/>
          <xsl:text>)</xsl:text>
        </xsl:if>
      </dt>
    </xsl:when>
    <xsl:otherwise>
      <dt>
        <xsl:call-template name="id.attribute">
          <xsl:with-param name="conditional">
            <xsl:choose>
              <xsl:when test="$glossterm.auto.link != 0">0</xsl:when>
              <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
        </xsl:call-template>
        <xsl:call-template name="anchor">
          <xsl:with-param name="conditional">
            <xsl:choose>
              <xsl:when test="$glossterm.auto.link != 0">0</xsl:when>
              <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
        </xsl:call-template>

        <xsl:apply-templates select="glossterm"/>
      </dt>
    </xsl:otherwise>
  </xsl:choose>

  <xsl:apply-templates select="indexterm|revhistory|glosssee|glossdef"/>
</xsl:template><xsl:template match="glossentry/glossterm">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:apply-templates/>
  </span>
  <xsl:if test="following-sibling::glossterm">, </xsl:if>
</xsl:template><xsl:template match="glossentry/acronym">
  <xsl:apply-templates/>
  <xsl:if test="following-sibling::acronym|following-sibling::abbrev">, </xsl:if>
</xsl:template><xsl:template match="glossentry/abbrev">
  <xsl:apply-templates/>
  <xsl:if test="following-sibling::acronym|following-sibling::abbrev">, </xsl:if>
</xsl:template><xsl:template match="glossentry/revhistory">
</xsl:template><xsl:template match="glossentry/glosssee">
  <xsl:variable name="otherterm" select="@otherterm"/>
  <xsl:variable name="targets" select="key('id', $otherterm)"/>
  <xsl:variable name="target" select="$targets[1]"/>
  <xsl:variable name="xlink" select="@xlink:href"/>

  <dd>
    <p>
      <xsl:variable name="template">
        <xsl:call-template name="gentext.template">
          <xsl:with-param name="context" select="'glossary'"/>
          <xsl:with-param name="name" select="'see'"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:variable name="title">
        <xsl:choose>
          <xsl:when test="$target">
            <a>
              <xsl:apply-templates select="." mode="common.html.attributes"/>
              <xsl:call-template name="id.attribute"/>
              <xsl:attribute name="href">
                <xsl:call-template name="href.target">
                  <xsl:with-param name="object" select="$target"/>
                </xsl:call-template>
              </xsl:attribute>
              <xsl:apply-templates select="$target" mode="xref-to"/>
            </a>
          </xsl:when>
          <xsl:when test="$xlink">
            <xsl:call-template name="simple.xlink">
              <xsl:with-param name="content">
                <xsl:apply-templates/>
              </xsl:with-param>
            </xsl:call-template>
          </xsl:when>
          <xsl:when test="$otherterm != '' and not($target)">
            <xsl:message>
              <xsl:text>Warning: glosssee @otherterm reference not found: </xsl:text>
              <xsl:value-of select="$otherterm"/>
            </xsl:message>
            <xsl:apply-templates/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:apply-templates/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>

      <xsl:call-template name="substitute-markup">
        <xsl:with-param name="template" select="$template"/>
        <xsl:with-param name="title" select="$title"/>
      </xsl:call-template>
    </p>
  </dd>
</xsl:template><xsl:template match="glossentry/glossdef">
  <dd>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:apply-templates select="*[local-name(.) != 'glossseealso']"/>
    <xsl:if test="glossseealso">
      <p>
        <xsl:variable name="template">
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="'glossary'"/>
            <xsl:with-param name="name" select="'seealso'"/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="title">
          <xsl:apply-templates select="glossseealso"/>
        </xsl:variable>
        <xsl:call-template name="substitute-markup">
          <xsl:with-param name="template" select="$template"/>
          <xsl:with-param name="title" select="$title"/>
        </xsl:call-template>
      </p>
    </xsl:if>
  </dd>
</xsl:template><xsl:template match="glossseealso">
  <xsl:variable name="otherterm" select="@otherterm"/>
  <xsl:variable name="targets" select="key('id', $otherterm)"/>
  <xsl:variable name="target" select="$targets[1]"/>
  <xsl:variable name="xlink" select="@xlink:href"/>

  <xsl:choose>
    <xsl:when test="$target">
      <a>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:call-template name="id.attribute"/>
        <xsl:attribute name="href">
          <xsl:call-template name="href.target">
            <xsl:with-param name="object" select="$target"/>
          </xsl:call-template>
        </xsl:attribute>
        <xsl:apply-templates select="$target" mode="xref-to"/>
      </a>
    </xsl:when>
    <xsl:when test="$xlink">
      <xsl:call-template name="simple.xlink">
        <xsl:with-param name="content">
          <xsl:apply-templates/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$otherterm != '' and not($target)">
      <xsl:message>
        <xsl:text>Warning: glossseealso @otherterm reference not found: </xsl:text>
        <xsl:value-of select="$otherterm"/>
      </xsl:message>
      <xsl:apply-templates/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates/>
    </xsl:otherwise>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="position() = last()"/>
    <xsl:otherwise>
		<xsl:call-template name="gentext.template">
		  <xsl:with-param name="context" select="'glossary'"/>
		  <xsl:with-param name="name" select="'seealso-separator'"/>
		</xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="glossary[@role='auto']" priority="2">
  
<xsl:variable name="language">
  <xsl:call-template name="l10n.language"/>
</xsl:variable>

<xsl:variable name="lowercase">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key">normalize.sort.input</xsl:with-param>
  </xsl:call-template>
</xsl:variable>

<xsl:variable name="uppercase">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key">normalize.sort.output</xsl:with-param>
  </xsl:call-template>
</xsl:variable>

  <xsl:variable name="terms" select="//glossterm[not(parent::glossdef)]|//firstterm"/>
  <xsl:variable name="collection" select="document($glossary.collection, .)"/>

  <xsl:call-template name="id.warning"/>

  <xsl:if test="$glossary.collection = ''">
    <xsl:message>
      <xsl:text>Warning: processing automatic glossary </xsl:text>
      <xsl:text>without a glossary.collection file.</xsl:text>
    </xsl:message>
  </xsl:if>

  <xsl:if test="not($collection) and $glossary.collection != ''">
    <xsl:message>
      <xsl:text>Warning: processing automatic glossary but unable to </xsl:text>
      <xsl:text>open glossary.collection file '</xsl:text>
      <xsl:value-of select="$glossary.collection"/>
      <xsl:text>'</xsl:text>
    </xsl:message>
  </xsl:if>

  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>

    <xsl:call-template name="glossary.titlepage"/>

    <xsl:choose>
      <xsl:when test="glossdiv and $collection//glossdiv">
        <xsl:for-each select="$collection//glossdiv">
          <!-- first see if there are any in this div -->
          <xsl:variable name="exist.test">
            <xsl:for-each select="glossentry">
              <xsl:variable name="cterm" select="glossterm"/>
              <xsl:if test="$terms[@baseform = $cterm or . = $cterm]">
                <xsl:value-of select="glossterm"/>
              </xsl:if>
            </xsl:for-each>
          </xsl:variable>

          <xsl:if test="$exist.test != ''">
            <xsl:apply-templates select="." mode="auto-glossary">
              <xsl:with-param name="terms" select="$terms"/>
            </xsl:apply-templates>
          </xsl:if>
        </xsl:for-each>
      </xsl:when>
      <xsl:otherwise>
        <dl>
          <xsl:choose>
            <xsl:when test="$glossary.sort != 0">
              <xsl:for-each select="$collection//glossentry">
				<xsl:sort lang="{$language}" select="normalize-space(translate(concat(@sortas, glossterm[not(parent::glossentry/@sortas) or parent::glossentry/@sortas = '']), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'))"/>
                <xsl:variable name="cterm" select="glossterm"/>
                <xsl:if test="$terms[@baseform = $cterm or . = $cterm]">
                  <xsl:apply-templates select="." mode="auto-glossary"/>
                </xsl:if>
              </xsl:for-each>
            </xsl:when>
            <xsl:otherwise>
              <xsl:for-each select="$collection//glossentry">
                <xsl:variable name="cterm" select="glossterm"/>
                <xsl:if test="$terms[@baseform = $cterm or . = $cterm]">
                  <xsl:apply-templates select="." mode="auto-glossary"/>
                </xsl:if>
              </xsl:for-each>
            </xsl:otherwise>
          </xsl:choose>
        </dl>
      </xsl:otherwise>
    </xsl:choose>

    <xsl:if test="not(parent::article)">
      <xsl:call-template name="process.footnotes"/>
    </xsl:if>
  </div>
</xsl:template><xsl:template match="*" mode="auto-glossary">
  <!-- pop back out to the default mode for most elements -->
  <xsl:apply-templates select="."/>
</xsl:template><xsl:template match="glossdiv" mode="auto-glossary">
  <xsl:param name="terms" select="."/>

  
<xsl:variable name="language">
  <xsl:call-template name="l10n.language"/>
</xsl:variable>

<xsl:variable name="lowercase">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key">normalize.sort.input</xsl:with-param>
  </xsl:call-template>
</xsl:variable>

<xsl:variable name="uppercase">
  <xsl:call-template name="gentext">
    <xsl:with-param name="key">normalize.sort.output</xsl:with-param>
  </xsl:call-template>
</xsl:variable>


  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:apply-templates select="(glossentry[1]/preceding-sibling::*)"/>

    <dl>
      <xsl:choose>
        <xsl:when test="$glossary.sort != 0">
          <xsl:for-each select="glossentry">
				<xsl:sort lang="{$language}" select="normalize-space(translate(concat(@sortas, glossterm[not(parent::glossentry/@sortas) or parent::glossentry/@sortas = '']), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'))"/>
            <xsl:variable name="cterm" select="glossterm"/>
            <xsl:if test="$terms[@baseform = $cterm or . = $cterm]">
              <xsl:apply-templates select="." mode="auto-glossary"/>
            </xsl:if>
          </xsl:for-each>
        </xsl:when>
        <xsl:otherwise>
          <xsl:for-each select="glossentry">
            <xsl:variable name="cterm" select="glossterm"/>
            <xsl:if test="$terms[@baseform = $cterm or . = $cterm]">
              <xsl:apply-templates select="." mode="auto-glossary"/>
            </xsl:if>
          </xsl:for-each>
        </xsl:otherwise>
      </xsl:choose>
    </dl>
  </div>
</xsl:template>
<xsl:template match="blockinfo|info">
  <!-- suppress -->
</xsl:template><xsl:template name="block.object">
  <div>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="para">
  <xsl:call-template name="paragraph">
    <xsl:with-param name="class">
      <xsl:if test="@role and $para.propagates.style != 0">
        <xsl:value-of select="@role"/>
      </xsl:if>
    </xsl:with-param>
    <xsl:with-param name="content">
      <xsl:if test="position() = 1 and parent::listitem">
        <xsl:call-template name="anchor">
          <xsl:with-param name="node" select="parent::listitem"/>
        </xsl:call-template>
      </xsl:if>

      <xsl:call-template name="anchor"/>
      <xsl:apply-templates/>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template>
<xsl:template match="formalpara/info">
  <xsl:apply-templates select="title"/>
</xsl:template><xsl:template match="formalpara/para">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="blockquote">
  <div>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>

    <xsl:choose>
      <xsl:when test="attribution">
        <table border="{$table.border.off}" class="blockquote">
          <xsl:if test="$css.decoration != 0">
            <xsl:attribute name="style">
              <xsl:text>width: 100%; cellspacing: 0; cellpadding: 0;</xsl:text>
            </xsl:attribute>
          </xsl:if>
          <xsl:if test="$div.element != 'section'">
            <xsl:attribute name="summary">Block quote</xsl:attribute>
          </xsl:if>
          <tr>
            <td width="10%" valign="top">Â </td>
            <td width="80%" valign="top">
              <xsl:apply-templates select="child::*[local-name(.)!='attribution']"/>
            </td>
            <td width="10%" valign="top">Â </td>
          </tr>
          <tr>
            <td width="10%" valign="top">Â </td>
            <td colspan="2" align="{$direction.align.end}" valign="top">
              <xsl:text>--</xsl:text>
              <xsl:apply-templates select="attribution"/>
            </td>
          </tr>
        </table>
      </xsl:when>
      <xsl:otherwise>
        <blockquote>
          <xsl:call-template name="common.html.attributes"/>
          <xsl:apply-templates/>
        </blockquote>
      </xsl:otherwise>
    </xsl:choose>
  </div>
</xsl:template><xsl:template match="blockquote/title|blockquote/info/title">
  <xsl:choose>
    <xsl:when test="$make.clean.html != 0">
      <div class="blockquote-title">
        <xsl:apply-templates/>
      </div>
    </xsl:when>
    <xsl:otherwise>
      <div class="blockquote-title">
        <p>
          <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
            <xsl:apply-templates/>
          </strong>
        </p>
      </div>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="epigraph">
  <div>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates select="para|simpara|formalpara|literallayout"/>
    <xsl:if test="attribution">
      <div class="attribution">
        <span>â€”<xsl:apply-templates select="attribution"/></span>
      </div>
    </xsl:if>
  </div>
</xsl:template><xsl:template match="attribution">
  <span>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates/>
  </span>
</xsl:template><xsl:template match="sidebar">
  <div>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="sidebar.titlepage"/>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="abstract/title|sidebar/title">
</xsl:template><xsl:template match="sidebar/sidebarinfo|sidebar/info"/><xsl:template match="abstract">
  <div>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="anchor"/>
    <xsl:call-template name="formal.object.heading">
      <xsl:with-param name="title">
        <xsl:apply-templates select="." mode="title.markup">
          <xsl:with-param name="allow-anchors" select="'1'"/>
        </xsl:apply-templates>
      </xsl:with-param>
    </xsl:call-template>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="msgset">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="msgentry">
  <xsl:call-template name="block.object"/>
</xsl:template><xsl:template match="simplemsgentry">
  <xsl:call-template name="block.object"/>
</xsl:template><xsl:template match="msg">
  <xsl:call-template name="block.object"/>
</xsl:template><xsl:template match="msgmain">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="msgmain/title">
  <xsl:choose>
    <xsl:when test="$make.clean.html != 0">
      <span class="msgmain-title">
        <xsl:apply-templates/>
      </span>
    </xsl:when>
    <xsl:otherwise>
      <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform"><xsl:apply-templates/></strong>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="msgsub">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="msgsub/title">
  <xsl:choose>
    <xsl:when test="$make.clean.html != 0">
      <span class="msgsub-title">
        <xsl:apply-templates/>
      </span>
    </xsl:when>
    <xsl:otherwise>
      <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform"><xsl:apply-templates/></strong>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="msgrel">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="msgrel/title">
  <xsl:choose>
    <xsl:when test="$make.clean.html != 0">
      <span class="msgrel-title">
        <xsl:apply-templates/>
      </span>
    </xsl:when>
    <xsl:otherwise>
      <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform"><xsl:apply-templates/></strong>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="msgtext">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="msginfo">
  <xsl:call-template name="block.object"/>
</xsl:template><xsl:template match="msglevel">
  <xsl:choose>
    <xsl:when test="$make.clean.html != 0">
      <div class="msglevel">
        <span class="msglevel-title">
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="'msgset'"/>
            <xsl:with-param name="name" select="'MsgLevel'"/>
          </xsl:call-template>
        </span>
        <xsl:apply-templates/>
      </div>
    </xsl:when>
    <xsl:otherwise>
      <p>
        <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="'msgset'"/>
            <xsl:with-param name="name" select="'MsgLevel'"/>
          </xsl:call-template>
        </strong>
        <xsl:apply-templates/>
      </p>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="msgorig">
  <xsl:choose>
    <xsl:when test="$make.clean.html != 0">
      <div class="msgorig">
        <span class="msgorig-title">
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="'msgset'"/>
            <xsl:with-param name="name" select="'MsgOrig'"/>
          </xsl:call-template>
        </span>
        <xsl:apply-templates/>
      </div>
    </xsl:when>
    <xsl:otherwise>
      <p>
        <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="'msgset'"/>
            <xsl:with-param name="name" select="'MsgOrig'"/>
          </xsl:call-template>
        </strong>
        <xsl:apply-templates/>
      </p>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="msgaud">
  <xsl:choose>
    <xsl:when test="$make.clean.html != 0">
      <div class="msgaud">
        <span class="msgaud-title">
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="'msgset'"/>
            <xsl:with-param name="name" select="'MsgAud'"/>
          </xsl:call-template>
        </span>
        <xsl:apply-templates/>
      </div>
    </xsl:when>
    <xsl:otherwise>
      <p>
        <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
          <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="'msgset'"/>
            <xsl:with-param name="name" select="'MsgAud'"/>
          </xsl:call-template>
        </strong>
        <xsl:apply-templates/>
      </p>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="msgexplan">
  <xsl:call-template name="block.object"/>
</xsl:template><xsl:template match="msgexplan/title">
  <xsl:choose>
    <xsl:when test="$make.clean.html != 0">
      <div class="msgexplan">
        <span class="msgexplan-title">
          <xsl:apply-templates/>
        </span>
      </div>
    </xsl:when>
    <xsl:otherwise>
      <p>
        <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
          <xsl:apply-templates/>
        </strong>
      </p>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="revhistory">
  <div>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <table>
      <xsl:if test="$css.decoration != 0">
        <xsl:attribute name="style">
          <xsl:text>border-style:solid; width:100%;</xsl:text>
        </xsl:attribute>
      </xsl:if>
      <!-- include summary attribute if not HTML5 -->
      <xsl:if test="$div.element != 'section'">
        <xsl:attribute name="summary">
          <xsl:call-template name="gentext">
            <xsl:with-param name="key">revhistory</xsl:with-param>
          </xsl:call-template>
        </xsl:attribute>
      </xsl:if>
      <tr>
        <th align="{$direction.align.start}" valign="top" colspan="3">
          <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
            <xsl:call-template name="gentext">
              <xsl:with-param name="key" select="'RevHistory'"/>
            </xsl:call-template>
          </strong>
        </th>
      </tr>
      <xsl:apply-templates/>
    </table>
  </div>
</xsl:template><xsl:template match="revhistory/revision">
  <xsl:variable name="revnumber" select="revnumber"/>
  <xsl:variable name="revdate" select="date"/>
  <xsl:variable name="revauthor" select="authorinitials|author"/>
  <xsl:variable name="revremark" select="revremark|revdescription"/>
  <tr>
    <td align="{$direction.align.start}">
      <xsl:if test="$revnumber">
        <xsl:call-template name="gentext">
          <xsl:with-param name="key" select="'Revision'"/>
        </xsl:call-template>
        <xsl:call-template name="gentext.space"/>
        <xsl:apply-templates select="$revnumber"/>
      </xsl:if>
    </td>
    <td align="{$direction.align.start}">
      <xsl:apply-templates select="$revdate"/>
    </td>
    <xsl:choose>
      <xsl:when test="count($revauthor)=0">
        <td align="{$direction.align.start}">
          <xsl:call-template name="dingbat">
            <xsl:with-param name="dingbat">nbsp</xsl:with-param>
          </xsl:call-template>
        </td>
      </xsl:when>
      <xsl:otherwise>
        <td align="{$direction.align.start}">
          <xsl:for-each select="$revauthor">
            <xsl:apply-templates select="."/>
            <xsl:if test="position() != last()">
              <xsl:text>, </xsl:text>
            </xsl:if>
          </xsl:for-each>
        </td>
      </xsl:otherwise>
    </xsl:choose>
  </tr>
  <xsl:if test="$revremark">
    <tr>
      <td align="{$direction.align.start}" colspan="3">
        <xsl:apply-templates select="$revremark"/>
      </td>
    </tr>
  </xsl:if>
</xsl:template><xsl:template match="revision/revnumber">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="revision/date">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="revision/authorinitials">
  <xsl:text>, </xsl:text>
  <xsl:apply-templates/>
</xsl:template><xsl:template match="revision/authorinitials[1]" priority="2">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="revision/revremark">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="revision/revdescription">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="ackno|acknowledgements[parent::article]">
  <xsl:call-template name="block.object"/>
</xsl:template><xsl:template match="highlights">
  <xsl:call-template name="block.object"/>
</xsl:template>
<xsl:template match="task">
  <xsl:variable name="param.placement" select="substring-after(normalize-space($formal.title.placement),                                         concat(local-name(.), ' '))"/>

  <xsl:variable name="placement">
    <xsl:choose>
      <xsl:when test="contains($param.placement, ' ')">
        <xsl:value-of select="substring-before($param.placement, ' ')"/>
      </xsl:when>
      <xsl:when test="$param.placement = ''">before</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$param.placement"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="preamble" select="*[not(self::title                               or self::titleabbrev)]"/>

  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>

    <xsl:if test="(title or info/title) and $placement = 'before'">
      <xsl:call-template name="formal.object.heading"/>
    </xsl:if>

    <xsl:apply-templates select="$preamble"/>

    <xsl:if test="(title or info/title) and $placement != 'before'">
      <xsl:call-template name="formal.object.heading"/>
    </xsl:if>
  </div>
</xsl:template><xsl:template match="task/title">
  <!-- nop -->
</xsl:template><xsl:template match="tasksummary">
  <xsl:call-template name="semiformal.object"/>
</xsl:template><xsl:template match="tasksummary/title"/><xsl:template match="taskprerequisites">
  <xsl:call-template name="semiformal.object"/>
</xsl:template><xsl:template match="taskprerequisites/title"/><xsl:template match="taskrelated">
  <xsl:call-template name="semiformal.object"/>
</xsl:template><xsl:template match="taskrelated/title"/>
<xsl:template match="qandaset">
  <xsl:variable name="title" select="(blockinfo/title|info/title|title)[1]"/>
  <xsl:variable name="preamble" select="*[local-name(.) != 'title'                                           and local-name(.) != 'titleabbrev'                                           and local-name(.) != 'qandadiv'                                           and local-name(.) != 'qandaentry']"/>
  <xsl:variable name="toc">
    <xsl:call-template name="pi.dbhtml_toc"/>
  </xsl:variable>

  <xsl:variable name="toc.params">
    <xsl:call-template name="find.path.params">
      <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
    </xsl:call-template>
  </xsl:variable>

  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:apply-templates select="$title"/>
    <xsl:if test="not($title)">
      <!-- andhor is output on title if there is one -->
      <xsl:call-template name="anchor">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>
    </xsl:if>
    <xsl:if test="((contains($toc.params, 'toc') and $toc != '0') or $toc = '1')                   and not(ancestor::answer and not($qanda.nested.in.toc=0))">
      <xsl:call-template name="process.qanda.toc"/>
    </xsl:if>
    <xsl:apply-templates select="$preamble"/>
    <xsl:call-template name="process.qandaset"/>
  </div>
</xsl:template><xsl:template match="qandaset/blockinfo/title|                      qandaset/info/title|                      qandaset/title">
  <xsl:variable name="qalevel">
    <xsl:call-template name="qanda.section.level"/>
  </xsl:variable>
  <xsl:element name="h{string(number($qalevel)+1)}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:call-template name="anchor">
      <xsl:with-param name="node" select=".."/>
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:apply-templates/>
  </xsl:element>
</xsl:template><xsl:template match="qandaset/blockinfo|qandaset/info">
  <!-- what should this template really do? -->
  <xsl:apply-templates select="legalnotice" mode="titlepage.mode"/>
</xsl:template><xsl:template match="qandadiv/blockinfo/title|                      qandadiv/info/title|                      qandadiv/title">
  <xsl:variable name="qalevel">
    <xsl:call-template name="qandadiv.section.level"/>
  </xsl:variable>

  <xsl:element name="h{string(number($qalevel)+1)}" namespace="http://www.w3.org/1999/xhtml">
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:call-template name="id.attribute">
      <xsl:with-param name="node" select=".."/>
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:call-template name="anchor">
      <xsl:with-param name="node" select=".."/>
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
    <xsl:apply-templates select="parent::qandadiv" mode="label.markup"/>
    <xsl:if test="$qandadiv.autolabel != 0">
      <xsl:apply-templates select="." mode="intralabel.punctuation"/>
      <xsl:text> </xsl:text>
    </xsl:if>
    <xsl:apply-templates/>
  </xsl:element>
</xsl:template><xsl:template match="*" mode="qanda.defaultlabel">
  <xsl:choose>
    <xsl:when test="ancestor-or-self::*[@defaultlabel]">
      <xsl:value-of select="(ancestor-or-self::*[@defaultlabel])[last()]                             /@defaultlabel"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$qanda.defaultlabel"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="question" mode="qanda.label">
  <xsl:variable name="deflabel">
    <xsl:apply-templates select="." mode="qanda.defaultlabel"/>
  </xsl:variable>
  <xsl:apply-templates select="." mode="label.markup"/>
  <xsl:if test="contains($deflabel, 'number') and not(label)">
    <xsl:apply-templates select="." mode="intralabel.punctuation"/>
  </xsl:if>
</xsl:template><xsl:template match="answer" mode="qanda.label">
  <xsl:apply-templates select="." mode="label.markup"/>
</xsl:template><xsl:template match="label">
  <xsl:apply-templates/>
</xsl:template><xsl:template name="process.qanda.toc">
  <!-- * if user wants nested qandaset and qandaentry in main Qandaset TOC, -->
  <!-- * then don't also include the nested stuff in the sub TOCs -->
  <dl>
    <xsl:apply-templates select="qandadiv" mode="qandatoc.mode"/>
    <xsl:apply-templates select="qandaset|qandaentry" mode="qandatoc.mode"/>
  </dl>
</xsl:template><xsl:template match="qandadiv" mode="qandatoc.mode">
  <dt><xsl:apply-templates select="title" mode="qandatoc.mode"/></dt>
  <dd><xsl:call-template name="process.qanda.toc"/></dd>
</xsl:template><xsl:template match="qandadiv/blockinfo/title|                      qandadiv/info/title|                      qandadiv/title" mode="qandatoc.mode">
  <xsl:variable name="qalevel">
    <xsl:call-template name="qandadiv.section.level"/>
  </xsl:variable>
  <xsl:variable name="id">
    <xsl:call-template name="object.id">
      <xsl:with-param name="object" select="parent::*"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="div.label">
    <xsl:apply-templates select="parent::qandadiv" mode="label.markup"/>
  </xsl:variable>
  <xsl:if test="string-length($div.label) != 0">
    <xsl:copy-of select="$div.label"/>
    <xsl:value-of select="$autotoc.label.separator"/>
  </xsl:if>
  <xsl:text> </xsl:text>
  <a>
    <xsl:attribute name="href">
      <xsl:call-template name="href.target">
        <xsl:with-param name="object" select="parent::*"/>
      </xsl:call-template>
    </xsl:attribute>
    <xsl:apply-templates/>
  </a>
</xsl:template><xsl:template match="qandaset" mode="qandatoc.mode">
  <xsl:for-each select="qandaentry">
    <xsl:apply-templates select="." mode="qandatoc.mode"/>
  </xsl:for-each>
</xsl:template><xsl:template match="qandaentry" mode="qandatoc.mode">
  <xsl:apply-templates select="question" mode="qandatoc.mode"/>
</xsl:template><xsl:template match="question" mode="qandatoc.mode">
  <xsl:variable name="firstch">
    <!-- Use a titleabbrev or title if available -->
    <xsl:choose>
      <xsl:when test="../blockinfo/titleabbrev">
        <xsl:apply-templates select="../blockinfo/titleabbrev[1]/node()"/>
      </xsl:when>
      <xsl:when test="../blockinfo/title">
        <xsl:apply-templates select="../blockinfo/title[1]/node()"/>
      </xsl:when>
      <xsl:when test="../info/titleabbrev">
        <xsl:apply-templates select="../info/titleabbrev[1]/node()"/>
      </xsl:when>
      <xsl:when test="../titleabbrev">
        <xsl:apply-templates select="../titleabbrev[1]/node()"/>
      </xsl:when>
      <xsl:when test="../info/title">
        <xsl:apply-templates select="../info/title[1]/node()"/>
      </xsl:when>
      <xsl:when test="../title">
        <xsl:apply-templates select="../title[1]/node()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="(*[local-name(.)!='label'])[1]/node()"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:variable name="deflabel">
    <xsl:choose>
      <xsl:when test="ancestor-or-self::*[@defaultlabel]">
        <xsl:value-of select="(ancestor-or-self::*[@defaultlabel])[last()]                               /@defaultlabel"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$qanda.defaultlabel"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <dt>
    <xsl:apply-templates select="." mode="label.markup"/>
    <xsl:if test="contains($deflabel,'number') and not(label)">
      <xsl:apply-templates select="." mode="intralabel.punctuation"/>
    </xsl:if>
    <xsl:text> </xsl:text>
    <a>
      <xsl:attribute name="href">
        <xsl:call-template name="href.target">
          <xsl:with-param name="object" select=".."/>
        </xsl:call-template>
      </xsl:attribute>
      <xsl:value-of select="$firstch"/>
    </a>
  </dt>
  <!-- * include nested qandaset/qandaentry in TOC if user wants it -->
  <xsl:if test="not($qanda.nested.in.toc = 0)">
    <xsl:apply-templates select="following-sibling::answer" mode="qandatoc.mode"/>
  </xsl:if>
</xsl:template><xsl:template match="answer" mode="qandatoc.mode">
  <xsl:if test="descendant::question">
    <dd>
      <xsl:call-template name="process.qanda.toc"/>
    </dd>
  </xsl:if>
</xsl:template><xsl:template match="*" mode="no.wrapper.mode">
  <xsl:apply-templates/>
</xsl:template>
<xsl:template match="cmdsynopsis">
  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <p>
      <xsl:call-template name="id.attribute">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>
      <xsl:if test="..//processing-instruction('dbcmdlist')">
        <!-- * Placing a dbcmdlist PI as a child of a particular element -->
        <!-- * creates a hyperlinked list of all cmdsynopsis instances -->
        <!-- * that are descendants of that element; so for any -->
        <!-- * cmdsynopsis that is a descendant of an element containing -->
        <!-- * a dbcmdlist PI, we need to output an a@id instance so that -->
        <!-- * we will have something to link to -->
        <xsl:call-template name="anchor">
          <xsl:with-param name="conditional" select="0"/>
        </xsl:call-template>
      </xsl:if>
      <xsl:apply-templates/>
    </p>
  </div>
</xsl:template><xsl:template match="cmdsynopsis/command">
  <br/>
  <xsl:call-template name="inline.monoseq"/>
  <xsl:text> </xsl:text>
</xsl:template><xsl:template match="cmdsynopsis/command[1]" priority="2">
  <xsl:call-template name="inline.monoseq"/>
  <xsl:text> </xsl:text>
</xsl:template><xsl:template match="group|arg" name="group-or-arg">
  <xsl:variable name="choice" select="@choice"/>
  <xsl:variable name="rep" select="@rep"/>
  <xsl:variable name="sepchar">
    <xsl:choose>
      <xsl:when test="ancestor-or-self::*/@sepchar">
        <xsl:value-of select="ancestor-or-self::*/@sepchar"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text> </xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:if test="preceding-sibling::*">
    <xsl:value-of select="$sepchar"/>
  </xsl:if>
  <xsl:choose>
    <xsl:when test="$choice='plain'">
      <xsl:value-of select="$arg.choice.plain.open.str"/>
    </xsl:when>
    <xsl:when test="$choice='req'">
      <xsl:value-of select="$arg.choice.req.open.str"/>
    </xsl:when>
    <xsl:when test="$choice='opt'">
      <xsl:value-of select="$arg.choice.opt.open.str"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$arg.choice.def.open.str"/>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:apply-templates/>
  <xsl:choose>
    <xsl:when test="$rep='repeat'">
      <xsl:value-of select="$arg.rep.repeat.str"/>
    </xsl:when>
    <xsl:when test="$rep='norepeat'">
      <xsl:value-of select="$arg.rep.norepeat.str"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$arg.rep.def.str"/>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:choose>
    <xsl:when test="$choice='plain'">
      <xsl:value-of select="$arg.choice.plain.close.str"/>
    </xsl:when>
    <xsl:when test="$choice='req'">
      <xsl:value-of select="$arg.choice.req.close.str"/>
    </xsl:when>
    <xsl:when test="$choice='opt'">
      <xsl:value-of select="$arg.choice.opt.close.str"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$arg.choice.def.close.str"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="group/arg">
  <xsl:variable name="choice" select="@choice"/>
  <xsl:variable name="rep" select="@rep"/>
  <xsl:if test="preceding-sibling::*">
    <xsl:value-of select="$arg.or.sep"/>
  </xsl:if>
  <xsl:call-template name="group-or-arg"/>
</xsl:template><xsl:template match="sbr">
  <br/>
</xsl:template><xsl:template match="synopfragmentref">
  <xsl:variable name="target" select="key('id',@linkend)"/>
  <xsl:variable name="snum">
    <xsl:apply-templates select="$target" mode="synopfragment.number"/>
  </xsl:variable>
  <em xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
    <a href="#{@linkend}">
      <xsl:text>(</xsl:text>
      <xsl:value-of select="$snum"/>
      <xsl:text>)</xsl:text>
    </a>
    <xsl:text>Â </xsl:text>
    <xsl:apply-templates/>
  </em>
</xsl:template><xsl:template match="synopfragment" mode="synopfragment.number">
  <xsl:number format="1"/>
</xsl:template><xsl:template match="synopfragment">
  <xsl:variable name="snum">
    <xsl:apply-templates select="." mode="synopfragment.number"/>
  </xsl:variable>
  <!-- You can't introduce another <p> here, because you're 
       already in a <p> from cmdsynopsis-->
  <span>
    <xsl:variable name="id">
      <xsl:call-template name="object.id"/>
    </xsl:variable>
    <a id="{$id}">
      <xsl:text>(</xsl:text>
      <xsl:value-of select="$snum"/>
      <xsl:text>)</xsl:text>
    </a>
    <xsl:text> </xsl:text>
    <xsl:apply-templates/>
  </span>
</xsl:template><xsl:template match="funcsynopsis">
  <xsl:if test="..//processing-instruction('dbfunclist')">
    <!-- * Placing a dbfunclist PI as a child of a particular element -->
    <!-- * creates a hyperlinked list of all funcsynopsis instances that -->
    <!-- * are descendants of that element; so for any funcsynopsis that is -->
    <!-- * a descendant of an element containing a dbfunclist PI, we need -->
    <!-- * to output an a@id instance so that we will have something to -->
    <!-- * link to -->
    <span>
      <xsl:call-template name="id.attribute">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>
    </span>
    <xsl:call-template name="anchor">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
  </xsl:if>
  <xsl:call-template name="informal.object"/>
</xsl:template><xsl:template match="funcsynopsisinfo">
  <pre>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates/>
  </pre>
</xsl:template><xsl:template match="funcprototype" mode="kr-nontabular">
  <p>
    <xsl:apply-templates mode="kr-nontabular"/>
    <xsl:if test="paramdef">
      <br/>
      <xsl:apply-templates select="paramdef" mode="kr-funcsynopsis-mode"/>
    </xsl:if>
  </p>
</xsl:template><xsl:template match="funcdef" mode="kr-nontabular">
  <code>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="kr-nontabular"/>
    <xsl:text>(</xsl:text>
  </code>
</xsl:template><xsl:template match="funcdef/function" mode="kr-nontabular">
  <xsl:choose>
    <xsl:when test="$funcsynopsis.decoration != 0">
      <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform" class="fsfunc"><xsl:apply-templates mode="kr-nontabular"/></strong>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="kr-nontabular"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="void" mode="kr-nontabular">
  <code>)</code>
  <xsl:text>;</xsl:text>
</xsl:template><xsl:template match="varargs" mode="kr-nontabular">
  <xsl:text>...</xsl:text>
  <code>)</code>
  <xsl:text>;</xsl:text>
</xsl:template><xsl:template match="paramdef" mode="kr-nontabular">
  <xsl:apply-templates select="parameter" mode="kr-nontabular"/>
  <xsl:choose>
    <xsl:when test="following-sibling::*">
      <xsl:text>, </xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <code>)</code>
      <xsl:text>;</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="paramdef/parameter" mode="kr-nontabular">
  <xsl:choose>
    <xsl:when test="$funcsynopsis.decoration != 0">
      <var class="pdparam">
        <xsl:apply-templates mode="kr-nontabular"/>
      </var>
    </xsl:when>
    <xsl:otherwise>
      <code>
	<xsl:apply-templates mode="kr-nontabular"/>
      </code>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="paramdef" mode="kr-funcsynopsis-mode">
  <xsl:if test="preceding-sibling::paramdef"><br/></xsl:if>
  <code>
    <xsl:apply-templates mode="kr-funcsynopsis-mode"/>
  </code>
  <xsl:text>;</xsl:text>
</xsl:template><xsl:template match="paramdef/parameter" mode="kr-funcsynopsis-mode">
  <xsl:choose>
    <xsl:when test="$funcsynopsis.decoration != 0">
      <var class="pdparam">
        <xsl:apply-templates mode="kr-funcsynopsis-mode"/>
      </var>
    </xsl:when>
    <xsl:otherwise>
      <code>
	<xsl:apply-templates mode="kr-funcsynopsis-mode"/>
      </code>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="funcparams" mode="kr-funcsynopsis-mode">
  <code>(</code>
  <xsl:apply-templates mode="kr-funcsynopsis-mode"/>
  <code>)</code>
</xsl:template><xsl:template match="funcprototype" mode="kr-tabular">
  <table border="{$table.border.off}" class="funcprototype-table">
    <xsl:if test="$div.element != 'section'">
      <xsl:attribute name="summary">Function synopsis</xsl:attribute>
    </xsl:if>
    <xsl:if test="$css.decoration != 0">
      <xsl:attribute name="style">cellspacing: 0; cellpadding: 0;</xsl:attribute>
    </xsl:if>
    <tr>
      <td>
        <xsl:apply-templates select="funcdef" mode="kr-tabular"/>
      </td>
      <xsl:apply-templates select="(void|varargs|paramdef)[1]" mode="kr-tabular"/>
    </tr>
    <xsl:for-each select="(void|varargs|paramdef)[preceding-sibling::*[not(self::funcdef)]]">
      <tr>
        <td>Â </td>
        <xsl:apply-templates select="." mode="kr-tabular"/>
      </tr>
    </xsl:for-each>
  </table>
  <xsl:if test="paramdef">
    <div class="paramdef-list">
      <xsl:apply-templates select="paramdef" mode="kr-funcsynopsis-mode"/>
    </div>
  </xsl:if>
  <div class="funcprototype-spacer">Â </div> <!-- hACk: blank div for vertical spacing -->
</xsl:template><xsl:template match="funcdef" mode="kr-tabular">
  <code>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="kr-tabular"/>
    <xsl:text>(</xsl:text>
  </code>
</xsl:template><xsl:template match="funcdef/function" mode="kr-tabular">
  <xsl:choose>
    <xsl:when test="$funcsynopsis.decoration != 0">
      <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform" class="fsfunc"><xsl:apply-templates mode="kr-nontabular"/></strong>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="kr-tabular"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="void" mode="kr-tabular">
  <td>
    <code>)</code>
    <xsl:text>;</xsl:text>
  </td>
  <td>Â </td>
</xsl:template><xsl:template match="varargs" mode="kr-tabular">
  <td>
    <xsl:text>...</xsl:text>
    <code>)</code>
    <xsl:text>;</xsl:text>
  </td>
  <td>Â </td>
</xsl:template><xsl:template match="paramdef" mode="kr-tabular">
  <td>
    <xsl:apply-templates select="parameter" mode="kr-tabular"/>
    <xsl:choose>
      <xsl:when test="following-sibling::*">
	<xsl:text>, </xsl:text>
      </xsl:when>
      <xsl:otherwise>
	<code>)</code>
	<xsl:text>;</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </td>
  <td>Â </td>
</xsl:template><xsl:template match="paramdef/parameter" mode="kr-tabular">
  <xsl:choose>
    <xsl:when test="$funcsynopsis.decoration != 0">
      <var class="pdparam">
        <xsl:apply-templates mode="kr-tabular"/>
      </var>
    </xsl:when>
    <xsl:otherwise>
      <code>
	<xsl:apply-templates mode="kr-tabular"/>
      </code>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="paramdef" mode="kr-tabular-funcsynopsis-mode">
  <xsl:variable name="type">
    <xsl:choose>
      <xsl:when test="type">
	<xsl:apply-templates select="type" mode="kr-tabular-funcsynopsis-mode"/>
      </xsl:when>
      <xsl:when test="normalize-space(parameter/preceding-sibling::node()[not(self::parameter)]) != ''">
	<xsl:copy-of select="parameter/preceding-sibling::node()[not(self::parameter)]"/>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <tr>
    <xsl:choose>
      <xsl:when test="$type != '' and funcparams">
        <td>
	  <code>
	    <xsl:copy-of select="$type"/>
	  </code>
          <xsl:text>Â </xsl:text>
        </td>
        <td>
	  <code>
	    <xsl:choose>
	      <xsl:when test="type">
		<xsl:apply-templates select="type/following-sibling::*" mode="kr-tabular-funcsynopsis-mode"/>
	      </xsl:when>
	      <xsl:otherwise>
		<xsl:apply-templates select="*" mode="kr-tabular-funcsynopsis-mode"/>
	      </xsl:otherwise>
	    </xsl:choose>
	  </code>
        </td>
      </xsl:when>

      <xsl:when test="funcparams">
        <td colspan="2">
	  <code>
	    <xsl:apply-templates mode="kr-tabular-funcsynopsis-mode"/>
	  </code>
        </td>
      </xsl:when>

      <xsl:otherwise>
        <td>
	  <code>
	    <xsl:apply-templates select="parameter/preceding-sibling::node()[not(self::parameter)]" mode="kr-tabular-funcsynopsis-mode"/>
	  </code>
          <xsl:text>Â </xsl:text>
        </td>
        <td>
	  <code>
	    <xsl:apply-templates select="parameter" mode="kr-tabular"/>
	    <xsl:apply-templates select="parameter/following-sibling::*[not(self::parameter)]" mode="kr-tabular-funcsynopsis-mode"/>
	    <xsl:text>;</xsl:text>
	  </code>
        </td>
      </xsl:otherwise>
    </xsl:choose>
  </tr>
</xsl:template><xsl:template match="paramdef/parameter" mode="kr-tabular-funcsynopsis-mode">
  <xsl:choose>
    <xsl:when test="$funcsynopsis.decoration != 0">
      <var class="pdparam">
        <xsl:apply-templates mode="kr-tabular-funcsynopsis-mode"/>
      </var>
    </xsl:when>
    <xsl:otherwise>
      <code>
	<xsl:apply-templates mode="kr-tabular-funcsynopsis-mode"/>
      </code>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="funcparams" mode="kr-tabular-funcsynopsis-mode">
  <code>(</code>
  <xsl:apply-templates mode="kr-tabular-funcsynopsis-mode"/>
  <code>)</code>
  <xsl:text>;</xsl:text>
</xsl:template><xsl:template match="funcprototype" mode="ansi-nontabular">
  <p>
    <xsl:apply-templates mode="ansi-nontabular"/>
  </p>
</xsl:template><xsl:template match="funcdef" mode="ansi-nontabular">
  <code>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="ansi-nontabular"/>
    <xsl:text>(</xsl:text>
  </code>
</xsl:template><xsl:template match="funcdef/function" mode="ansi-nontabular">
  <xsl:choose>
    <xsl:when test="$funcsynopsis.decoration != 0">
      <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform" class="fsfunc"><xsl:apply-templates mode="ansi-nontabular"/></strong>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="ansi-nontabular"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="void" mode="ansi-nontabular">
  <code>void)</code>
  <xsl:text>;</xsl:text>
</xsl:template><xsl:template match="varargs" mode="ansi-nontabular">
  <xsl:text>...</xsl:text>
  <code>)</code>
  <xsl:text>;</xsl:text>
</xsl:template><xsl:template match="paramdef" mode="ansi-nontabular">
  <xsl:apply-templates mode="ansi-nontabular"/>
  <xsl:choose>
    <xsl:when test="following-sibling::*">
      <xsl:text>, </xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <code>)</code>
      <xsl:text>;</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="paramdef/parameter" mode="ansi-nontabular">
  <xsl:choose>
    <xsl:when test="$funcsynopsis.decoration != 0">
      <var class="pdparam">
        <xsl:apply-templates mode="ansi-nontabular"/>
      </var>
    </xsl:when>
    <xsl:otherwise>
      <code>
	<xsl:apply-templates mode="ansi-nontabular"/>
      </code>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="funcparams" mode="ansi-nontabular">
  <code>(</code>
  <xsl:apply-templates mode="ansi-nontabular"/>
  <code>)</code>
</xsl:template><xsl:template match="funcprototype" mode="ansi-tabular">
  <table border="{$table.border.off}" class="funcprototype-table">
    <xsl:if test="$div.element != 'section'">
      <xsl:attribute name="summary">Function synopsis</xsl:attribute>
    </xsl:if>
    <xsl:if test="$css.decoration != 0">
      <xsl:attribute name="style">cellspacing: 0; cellpadding: 0;</xsl:attribute>
    </xsl:if>
    <tr>
      <td>
        <xsl:apply-templates select="funcdef" mode="ansi-tabular"/>
      </td>
      <xsl:apply-templates select="(void|varargs|paramdef)[1]" mode="ansi-tabular"/>
    </tr>
    <xsl:for-each select="(void|varargs|paramdef)[preceding-sibling::*[not(self::funcdef)]]">
      <tr>
        <td>Â </td>
        <xsl:apply-templates select="." mode="ansi-tabular"/>
      </tr>
    </xsl:for-each>
  </table>
  <div class="funcprototype-spacer">Â </div> <!-- hACk: blank div for vertical spacing -->
</xsl:template><xsl:template match="funcdef" mode="ansi-tabular">
  <code>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="ansi-tabular"/>
    <xsl:text>(</xsl:text>
  </code>
</xsl:template><xsl:template match="funcdef/function" mode="ansi-tabular">
  <xsl:choose>
    <xsl:when test="$funcsynopsis.decoration != 0">
      <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform" class="fsfunc"><xsl:apply-templates mode="ansi-nontabular"/></strong>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="kr-tabular"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="void" mode="ansi-tabular">
  <td>
    <code>void)</code>
    <xsl:text>;</xsl:text>
  </td>
  <td>Â </td>
</xsl:template><xsl:template match="varargs" mode="ansi-tabular">
  <td>
    <xsl:text>...</xsl:text>
    <code>)</code>
    <xsl:text>;</xsl:text>
  </td>
  <td>Â </td>
</xsl:template><xsl:template match="paramdef" mode="ansi-tabular">
      <td>
        <xsl:apply-templates mode="ansi-tabular"/>
        <xsl:choose>
          <xsl:when test="following-sibling::*">
            <xsl:text>, </xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <code>)</code>
            <xsl:text>;</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </td>
</xsl:template><xsl:template match="paramdef/parameter" mode="ansi-tabular">
  <xsl:choose>
    <xsl:when test="$funcsynopsis.decoration != 0">
      <var class="pdparam">
        <xsl:apply-templates mode="ansi-tabular"/>
      </var>
    </xsl:when>
    <xsl:otherwise>
      <code>
	<xsl:apply-templates mode="ansi-tabular"/>
      </code>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="funcparams" mode="ansi-tabular">
  <code>(</code>
  <xsl:apply-templates/>
  <code>)</code>
</xsl:template><xsl:variable name="default-classsynopsis-language">java</xsl:variable><xsl:template match="classsynopsis                      |fieldsynopsis                      |methodsynopsis                      |constructorsynopsis                      |destructorsynopsis">
  <xsl:param name="language">
    <xsl:choose>
      <xsl:when test="@language">
	<xsl:value-of select="@language"/>
      </xsl:when>
      <xsl:otherwise>
	<xsl:value-of select="$default-classsynopsis-language"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:param>

  <xsl:choose>
    <xsl:when test="$language='java' or $language='Java'">
      <xsl:apply-templates select="." mode="java"/>
    </xsl:when>
    <xsl:when test="$language='perl' or $language='Perl'">
      <xsl:apply-templates select="." mode="perl"/>
    </xsl:when>
    <xsl:when test="$language='idl' or $language='IDL'">
      <xsl:apply-templates select="." mode="idl"/>
    </xsl:when>
    <xsl:when test="$language='cpp' or $language='c++' or $language='C++'">
      <xsl:apply-templates select="." mode="cpp"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:message>
	<xsl:text>Unrecognized language on </xsl:text>
        <xsl:value-of select="local-name(.)"/>
        <xsl:text>: </xsl:text>
	<xsl:value-of select="$language"/>
      </xsl:message>
      <xsl:apply-templates select=".">
	<xsl:with-param name="language" select="$default-classsynopsis-language"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="synop-break">
  <xsl:if test="parent::classsynopsis                 or (following-sibling::fieldsynopsis                     |following-sibling::methodsynopsis                     |following-sibling::constructorsynopsis                     |following-sibling::destructorsynopsis)">
    <br/>
  </xsl:if>
</xsl:template><xsl:template match="classsynopsis" mode="java">
  <pre>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates select="ooclass[1]" mode="java"/>
    <xsl:if test="ooclass[preceding-sibling::*]">
      <xsl:text> extends</xsl:text>
      <xsl:apply-templates select="ooclass[preceding-sibling::*]" mode="java"/>
      <xsl:if test="oointerface|ooexception">
        <br/>
	<xsl:text>Â Â Â Â </xsl:text>
      </xsl:if>
    </xsl:if>
    <xsl:if test="oointerface">
      <xsl:text>implements</xsl:text>
      <xsl:apply-templates select="oointerface" mode="java"/>
      <xsl:if test="ooexception">
        <br/>
	<xsl:text>Â Â Â Â </xsl:text>
      </xsl:if>
    </xsl:if>
    <xsl:if test="ooexception">
      <xsl:text>throws</xsl:text>
      <xsl:apply-templates select="ooexception" mode="java"/>
    </xsl:if>
    <xsl:text>Â {</xsl:text>
    <br/>
    <xsl:apply-templates select="constructorsynopsis                                  |destructorsynopsis                                  |fieldsynopsis                                  |methodsynopsis                                  |classsynopsisinfo" mode="java"/>
    <xsl:text>}</xsl:text>
  </pre>
</xsl:template><xsl:template match="classsynopsisinfo" mode="java">
  <xsl:apply-templates mode="java"/>
</xsl:template><xsl:template match="ooclass|oointerface|ooexception" mode="java">
  <xsl:choose>
    <xsl:when test="preceding-sibling::*">
      <xsl:text>, </xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text> </xsl:text>
    </xsl:otherwise>
  </xsl:choose>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="java"/>
  </span>
</xsl:template><xsl:template match="modifier|package" mode="java">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="java"/>
    <xsl:if test="following-sibling::*">
      <xsl:text>Â </xsl:text>
    </xsl:if>
  </span>
</xsl:template><xsl:template match="classname" mode="java">
  <xsl:if test="local-name(preceding-sibling::*[1]) = 'classname'">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="java"/>
  </span>
</xsl:template><xsl:template match="interfacename" mode="java">
  <xsl:if test="local-name(preceding-sibling::*[1]) = 'interfacename'">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="java"/>
  </span>
</xsl:template><xsl:template match="exceptionname" mode="java">
  <xsl:if test="local-name(preceding-sibling::*[1]) = 'exceptionname'">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="java"/>
  </span>
</xsl:template><xsl:template match="fieldsynopsis" mode="java">
  <code>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:if test="parent::classsynopsis">
      <xsl:text>Â Â </xsl:text>
    </xsl:if>
    <xsl:apply-templates mode="java"/>
    <xsl:text>;</xsl:text>
  </code>
  <xsl:call-template name="synop-break"/>
</xsl:template><xsl:template match="type" mode="java">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="java"/>
    <xsl:text>Â </xsl:text>
  </span>
</xsl:template><xsl:template match="varname" mode="java">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="java"/>
    <xsl:text>Â </xsl:text>
  </span>
</xsl:template><xsl:template match="initializer" mode="java">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:text>=Â </xsl:text>
    <xsl:apply-templates mode="java"/>
  </span>
</xsl:template><xsl:template match="void" mode="java">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:text>voidÂ </xsl:text>
  </span>
</xsl:template><xsl:template match="methodname" mode="java">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="java"/>
  </span>
</xsl:template><xsl:template match="methodparam" mode="java">
  <xsl:param name="indent">0</xsl:param>
  <xsl:if test="preceding-sibling::methodparam">
    <xsl:text>,</xsl:text>
    <br/>
    <xsl:if test="$indent &gt; 0">
      <xsl:call-template name="copy-string">
	<xsl:with-param name="string">Â </xsl:with-param>
	<xsl:with-param name="count" select="$indent + 1"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="java"/>
  </span>
</xsl:template><xsl:template match="parameter" mode="java">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="java"/>
  </span>
</xsl:template><xsl:template mode="java" match="constructorsynopsis|destructorsynopsis|methodsynopsis">
  <xsl:variable name="start-modifiers" select="modifier[following-sibling::*[local-name(.) != 'modifier']]"/>
  <xsl:variable name="notmod" select="*[local-name(.) != 'modifier']"/>
  <xsl:variable name="end-modifiers" select="modifier[preceding-sibling::*[local-name(.) != 'modifier']]"/>
  <xsl:variable name="decl">
    <xsl:if test="parent::classsynopsis">
      <xsl:text>Â Â </xsl:text>
    </xsl:if>
    <xsl:apply-templates select="$start-modifiers" mode="java"/>

    <!-- type -->
    <xsl:if test="local-name($notmod[1]) != 'methodname'">
      <xsl:apply-templates select="$notmod[1]" mode="java"/>
    </xsl:if>

    <xsl:apply-templates select="methodname" mode="java"/>
  </xsl:variable>

  <code>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:copy-of select="$decl"/>
    <xsl:text>(</xsl:text>
    <xsl:apply-templates select="methodparam" mode="java">
      <xsl:with-param name="indent" select="string-length($decl)"/>
    </xsl:apply-templates>
    <xsl:text>)</xsl:text>
    <xsl:if test="exceptionname">
      <br/>
      <xsl:text>Â Â Â Â throwsÂ </xsl:text>
      <xsl:apply-templates select="exceptionname" mode="java"/>
    </xsl:if>
    <xsl:if test="modifier[preceding-sibling::*[local-name(.) != 'modifier']]">
      <xsl:text> </xsl:text>
      <xsl:apply-templates select="$end-modifiers" mode="java"/>
    </xsl:if>
    <xsl:text>;</xsl:text>
  </code>
  <xsl:call-template name="synop-break"/>
</xsl:template><xsl:template match="classsynopsis" mode="cpp">
  <pre>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates select="ooclass[1]" mode="cpp"/>
    <xsl:if test="ooclass[preceding-sibling::*]">
      <xsl:text>: </xsl:text>
      <xsl:apply-templates select="ooclass[preceding-sibling::*]" mode="cpp"/>
      <xsl:if test="oointerface|ooexception">
        <br/>
	<xsl:text>Â Â Â Â </xsl:text>
      </xsl:if>
    </xsl:if>
    <xsl:if test="oointerface">
      <xsl:text> implements</xsl:text>
      <xsl:apply-templates select="oointerface" mode="cpp"/>
      <xsl:if test="ooexception">
        <br/>
	<xsl:text>Â Â Â Â </xsl:text>
      </xsl:if>
    </xsl:if>
    <xsl:if test="ooexception">
      <xsl:text> throws</xsl:text>
      <xsl:apply-templates select="ooexception" mode="cpp"/>
    </xsl:if>
    <xsl:text>Â {</xsl:text>
    <br/>
    <xsl:apply-templates select="constructorsynopsis                                  |destructorsynopsis                                  |fieldsynopsis                                  |methodsynopsis                                  |classsynopsisinfo" mode="cpp"/>
    <xsl:text>}</xsl:text>
  </pre>
</xsl:template><xsl:template match="classsynopsisinfo" mode="cpp">
  <xsl:apply-templates mode="cpp"/>
</xsl:template><xsl:template match="ooclass|oointerface|ooexception" mode="cpp">
  <xsl:if test="preceding-sibling::*">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="cpp"/>
  </span>
</xsl:template><xsl:template match="modifier|package" mode="cpp">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="cpp"/>
    <xsl:if test="following-sibling::*">
      <xsl:text>Â </xsl:text>
    </xsl:if>
  </span>
</xsl:template><xsl:template match="classname" mode="cpp">
  <xsl:if test="local-name(preceding-sibling::*[1]) = 'classname'">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="cpp"/>
  </span>
</xsl:template><xsl:template match="interfacename" mode="cpp">
  <xsl:if test="local-name(preceding-sibling::*[1]) = 'interfacename'">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="cpp"/>
  </span>
</xsl:template><xsl:template match="exceptionname" mode="cpp">
  <xsl:if test="local-name(preceding-sibling::*[1]) = 'exceptionname'">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="cpp"/>
  </span>
</xsl:template><xsl:template match="fieldsynopsis" mode="cpp">
  <code>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:if test="parent::classsynopsis">
      <xsl:text>Â Â </xsl:text>
    </xsl:if>
    <xsl:apply-templates mode="cpp"/>
    <xsl:text>;</xsl:text>
  </code>
  <xsl:call-template name="synop-break"/>
</xsl:template><xsl:template match="type" mode="cpp">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="cpp"/>
    <xsl:text>Â </xsl:text>
  </span>
</xsl:template><xsl:template match="varname" mode="cpp">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="cpp"/>
    <xsl:text>Â </xsl:text>
  </span>
</xsl:template><xsl:template match="initializer" mode="cpp">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:text>=Â </xsl:text>
    <xsl:apply-templates mode="cpp"/>
  </span>
</xsl:template><xsl:template match="void" mode="cpp">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:text>voidÂ </xsl:text>
  </span>
</xsl:template><xsl:template match="methodname" mode="cpp">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="cpp"/>
  </span>
</xsl:template><xsl:template match="methodparam" mode="cpp">
  <xsl:if test="preceding-sibling::methodparam">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="cpp"/>
  </span>
</xsl:template><xsl:template match="parameter" mode="cpp">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="cpp"/>
  </span>
</xsl:template><xsl:template mode="cpp" match="constructorsynopsis|destructorsynopsis|methodsynopsis">
  <xsl:variable name="start-modifiers" select="modifier[following-sibling::*[local-name(.) != 'modifier']]"/>
  <xsl:variable name="notmod" select="*[local-name(.) != 'modifier']"/>
  <xsl:variable name="end-modifiers" select="modifier[preceding-sibling::*[local-name(.) != 'modifier']]"/>

  <code>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:if test="parent::classsynopsis">
      <xsl:text>Â Â </xsl:text>
    </xsl:if>
    <xsl:apply-templates select="$start-modifiers" mode="cpp"/>

    <!-- type -->
    <xsl:if test="local-name($notmod[1]) != 'methodname'">
      <xsl:apply-templates select="$notmod[1]" mode="cpp"/>
    </xsl:if>

    <xsl:apply-templates select="methodname" mode="cpp"/>
    <xsl:text>(</xsl:text>
    <xsl:apply-templates select="methodparam" mode="cpp"/>
    <xsl:text>)</xsl:text>
    <xsl:if test="exceptionname">
      <br/>
      <xsl:text>Â Â Â Â throwsÂ </xsl:text>
      <xsl:apply-templates select="exceptionname" mode="cpp"/>
    </xsl:if>
    <xsl:if test="modifier[preceding-sibling::*[local-name(.) != 'modifier']]">
      <xsl:text> </xsl:text>
      <xsl:apply-templates select="$end-modifiers" mode="cpp"/>
    </xsl:if>
    <xsl:text>;</xsl:text>
  </code>
  <xsl:call-template name="synop-break"/>
</xsl:template><xsl:template match="classsynopsis" mode="idl">
  <pre>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:text>interface </xsl:text>
    <xsl:apply-templates select="ooclass[1]" mode="idl"/>
    <xsl:if test="ooclass[preceding-sibling::*]">
      <xsl:text>: </xsl:text>
      <xsl:apply-templates select="ooclass[preceding-sibling::*]" mode="idl"/>
      <xsl:if test="oointerface|ooexception">
        <br/>
	<xsl:text>Â Â Â Â </xsl:text>
      </xsl:if>
    </xsl:if>
    <xsl:if test="oointerface">
      <xsl:text> implements</xsl:text>
      <xsl:apply-templates select="oointerface" mode="idl"/>
      <xsl:if test="ooexception">
        <br/>
	<xsl:text>Â Â Â Â </xsl:text>
      </xsl:if>
    </xsl:if>
    <xsl:if test="ooexception">
      <xsl:text> throws</xsl:text>
      <xsl:apply-templates select="ooexception" mode="idl"/>
    </xsl:if>
    <xsl:text>Â {</xsl:text>
    <br/>
    <xsl:apply-templates select="constructorsynopsis                                  |destructorsynopsis                                  |fieldsynopsis                                  |methodsynopsis                                  |classsynopsisinfo" mode="idl"/>
    <xsl:text>}</xsl:text>
  </pre>
</xsl:template><xsl:template match="classsynopsisinfo" mode="idl">
  <xsl:apply-templates mode="idl"/>
</xsl:template><xsl:template match="ooclass|oointerface|ooexception" mode="idl">
  <xsl:if test="preceding-sibling::*">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="idl"/>
  </span>
</xsl:template><xsl:template match="modifier|package" mode="idl">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="idl"/>
    <xsl:if test="following-sibling::*">
      <xsl:text>Â </xsl:text>
    </xsl:if>
  </span>
</xsl:template><xsl:template match="classname" mode="idl">
  <xsl:if test="local-name(preceding-sibling::*[1]) = 'classname'">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="idl"/>
  </span>
</xsl:template><xsl:template match="interfacename" mode="idl">
  <xsl:if test="local-name(preceding-sibling::*[1]) = 'interfacename'">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="idl"/>
  </span>
</xsl:template><xsl:template match="exceptionname" mode="idl">
  <xsl:if test="local-name(preceding-sibling::*[1]) = 'exceptionname'">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="idl"/>
  </span>
</xsl:template><xsl:template match="fieldsynopsis" mode="idl">
  <code>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:if test="parent::classsynopsis">
      <xsl:text>Â Â </xsl:text>
    </xsl:if>
    <xsl:apply-templates mode="idl"/>
    <xsl:text>;</xsl:text>
  </code>
  <xsl:call-template name="synop-break"/>
</xsl:template><xsl:template match="type" mode="idl">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="idl"/>
    <xsl:text>Â </xsl:text>
  </span>
</xsl:template><xsl:template match="varname" mode="idl">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="idl"/>
    <xsl:text>Â </xsl:text>
  </span>
</xsl:template><xsl:template match="initializer" mode="idl">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:text>=Â </xsl:text>
    <xsl:apply-templates mode="idl"/>
  </span>
</xsl:template><xsl:template match="void" mode="idl">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:text>voidÂ </xsl:text>
  </span>
</xsl:template><xsl:template match="methodname" mode="idl">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="idl"/>
  </span>
</xsl:template><xsl:template match="methodparam" mode="idl">
  <xsl:if test="preceding-sibling::methodparam">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="idl"/>
  </span>
</xsl:template><xsl:template match="parameter" mode="idl">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="idl"/>
  </span>
</xsl:template><xsl:template mode="idl" match="constructorsynopsis|destructorsynopsis|methodsynopsis">
  <xsl:variable name="start-modifiers" select="modifier[following-sibling::*[local-name(.) != 'modifier']]"/>
  <xsl:variable name="notmod" select="*[local-name(.) != 'modifier']"/>
  <xsl:variable name="end-modifiers" select="modifier[preceding-sibling::*[local-name(.) != 'modifier']]"/>
  <code>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:if test="parent::classsynopsis">
      <xsl:text>Â Â </xsl:text>
    </xsl:if>
    <xsl:apply-templates select="$start-modifiers" mode="idl"/>

    <!-- type -->
    <xsl:if test="local-name($notmod[1]) != 'methodname'">
      <xsl:apply-templates select="$notmod[1]" mode="idl"/>
    </xsl:if>

    <xsl:apply-templates select="methodname" mode="idl"/>
    <xsl:text>(</xsl:text>
    <xsl:apply-templates select="methodparam" mode="idl"/>
    <xsl:text>)</xsl:text>
    <xsl:if test="exceptionname">
      <br/>
      <xsl:text>Â Â Â Â raises(</xsl:text>
      <xsl:apply-templates select="exceptionname" mode="idl"/>
      <xsl:text>)</xsl:text>
    </xsl:if>
    <xsl:if test="modifier[preceding-sibling::*[local-name(.) != 'modifier']]">
      <xsl:text> </xsl:text>
      <xsl:apply-templates select="$end-modifiers" mode="idl"/>
    </xsl:if>
    <xsl:text>;</xsl:text>
  </code>
  <xsl:call-template name="synop-break"/>
</xsl:template><xsl:template match="classsynopsis" mode="perl">
  <pre>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:text>package </xsl:text>
    <xsl:apply-templates select="ooclass[1]" mode="perl"/>
    <xsl:text>;</xsl:text>
    <br/>

    <xsl:if test="ooclass[preceding-sibling::*]">
      <xsl:text>@ISA = (</xsl:text>
      <xsl:apply-templates select="ooclass[preceding-sibling::*]" mode="perl"/>
      <xsl:text>);</xsl:text>
      <br/>
    </xsl:if>

    <xsl:apply-templates select="constructorsynopsis                                  |destructorsynopsis                                  |fieldsynopsis                                  |methodsynopsis                                  |classsynopsisinfo" mode="perl"/>
  </pre>
</xsl:template><xsl:template match="classsynopsisinfo" mode="perl">
  <xsl:apply-templates mode="perl"/>
</xsl:template><xsl:template match="ooclass|oointerface|ooexception" mode="perl">
  <xsl:if test="preceding-sibling::*">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="perl"/>
  </span>
</xsl:template><xsl:template match="modifier|package" mode="perl">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="perl"/>
    <xsl:if test="following-sibling::*">
      <xsl:text>Â </xsl:text>
    </xsl:if>
  </span>
</xsl:template><xsl:template match="classname" mode="perl">
  <xsl:if test="local-name(preceding-sibling::*[1]) = 'classname'">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="perl"/>
  </span>
</xsl:template><xsl:template match="interfacename" mode="perl">
  <xsl:if test="local-name(preceding-sibling::*[1]) = 'interfacename'">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="perl"/>
  </span>
</xsl:template><xsl:template match="exceptionname" mode="perl">
  <xsl:if test="local-name(preceding-sibling::*[1]) = 'exceptionname'">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="perl"/>
  </span>
</xsl:template><xsl:template match="fieldsynopsis" mode="perl">
  <code>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:if test="parent::classsynopsis">
      <xsl:text>Â Â </xsl:text>
    </xsl:if>
    <xsl:apply-templates mode="perl"/>
    <xsl:text>;</xsl:text>
  </code>
  <xsl:call-template name="synop-break"/>
</xsl:template><xsl:template match="type" mode="perl">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="perl"/>
    <xsl:text>Â </xsl:text>
  </span>
</xsl:template><xsl:template match="varname" mode="perl">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="perl"/>
    <xsl:text>Â </xsl:text>
  </span>
</xsl:template><xsl:template match="initializer" mode="perl">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:text>=Â </xsl:text>
    <xsl:apply-templates mode="perl"/>
  </span>
</xsl:template><xsl:template match="void" mode="perl">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:text>voidÂ </xsl:text>
  </span>
</xsl:template><xsl:template match="methodname" mode="perl">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="perl"/>
  </span>
</xsl:template><xsl:template match="methodparam" mode="perl">
  <xsl:if test="preceding-sibling::methodparam">
    <xsl:text>, </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="perl"/>
  </span>
</xsl:template><xsl:template match="parameter" mode="perl">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="perl"/>
  </span>
</xsl:template><xsl:template mode="perl" match="constructorsynopsis|destructorsynopsis|methodsynopsis">
  <xsl:variable name="start-modifiers" select="modifier[following-sibling::*[local-name(.) != 'modifier']]"/>
  <xsl:variable name="notmod" select="*[local-name(.) != 'modifier']"/>
  <xsl:variable name="end-modifiers" select="modifier[preceding-sibling::*[local-name(.) != 'modifier']]"/>

  <code>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:text>sub </xsl:text>

    <xsl:apply-templates select="methodname" mode="perl"/>
    <xsl:text> { ... };</xsl:text>
  </code>
  <xsl:call-template name="synop-break"/>
</xsl:template><xsl:template match="ooclass|oointerface|ooexception">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="link|olink|xref" mode="java">
  <xsl:apply-templates select="."/>
</xsl:template><xsl:template match="link|olink|xref" mode="cpp">
  <xsl:apply-templates select="."/>
</xsl:template><xsl:template match="link|olink|xref" mode="idl">
  <xsl:apply-templates select="."/>
</xsl:template><xsl:template match="link|olink|xref" mode="perl">
  <xsl:apply-templates select="."/>
</xsl:template><xsl:template match="link|olink|xref" mode="ansi-nontabular">
  <xsl:apply-templates select="."/>
</xsl:template><xsl:template match="link|olink|xref" mode="ansi-tabular">
  <xsl:apply-templates select="."/>
</xsl:template><xsl:template match="link|olink|xref" mode="kr-nontabular">
  <xsl:apply-templates select="."/>
</xsl:template><xsl:template match="link|olink|xref" mode="kr-tabular">
  <xsl:apply-templates select="."/>
</xsl:template>
<xsl:attribute-set name="book.titlepage.recto.style"/><xsl:attribute-set name="book.titlepage.verso.style"/><xsl:attribute-set name="article.titlepage.recto.style"/><xsl:attribute-set name="article.titlepage.verso.style"/><xsl:attribute-set name="set.titlepage.recto.style"/><xsl:attribute-set name="set.titlepage.verso.style"/><xsl:attribute-set name="part.titlepage.recto.style"/><xsl:attribute-set name="part.titlepage.verso.style"/><xsl:attribute-set name="partintro.titlepage.recto.style"/><xsl:attribute-set name="partintro.titlepage.verso.style"/><xsl:attribute-set name="reference.titlepage.recto.style"/><xsl:attribute-set name="reference.titlepage.verso.style"/><xsl:attribute-set name="refentry.titlepage.recto.style"/><xsl:attribute-set name="refentry.titlepage.verso.style"/><xsl:attribute-set name="dedication.titlepage.recto.style"/><xsl:attribute-set name="dedication.titlepage.verso.style"/><xsl:attribute-set name="acknowledgements.titlepage.recto.style"/><xsl:attribute-set name="acknowledgements.titlepage.verso.style"/><xsl:attribute-set name="preface.titlepage.recto.style"/><xsl:attribute-set name="preface.titlepage.verso.style"/><xsl:attribute-set name="chapter.titlepage.recto.style"/><xsl:attribute-set name="chapter.titlepage.verso.style"/><xsl:attribute-set name="appendix.titlepage.recto.style"/><xsl:attribute-set name="appendix.titlepage.verso.style"/><xsl:attribute-set name="bibliography.titlepage.recto.style"/><xsl:attribute-set name="bibliography.titlepage.verso.style"/><xsl:attribute-set name="glossary.titlepage.recto.style"/><xsl:attribute-set name="glossary.titlepage.verso.style"/><xsl:attribute-set name="index.titlepage.recto.style"/><xsl:attribute-set name="index.titlepage.verso.style"/><xsl:attribute-set name="setindex.titlepage.recto.style"/><xsl:attribute-set name="setindex.titlepage.verso.style"/><xsl:attribute-set name="sidebar.titlepage.recto.style"/><xsl:attribute-set name="sidebar.titlepage.verso.style"/><xsl:attribute-set name="topic.titlepage.recto.style"/><xsl:attribute-set name="topic.titlepage.verso.style"/><xsl:attribute-set name="section.titlepage.recto.style"/><xsl:attribute-set name="section.titlepage.verso.style"/><xsl:attribute-set name="sect1.titlepage.recto.style" use-attribute-sets="section.titlepage.recto.style"/><xsl:attribute-set name="sect1.titlepage.verso.style" use-attribute-sets="section.titlepage.verso.style"/><xsl:attribute-set name="sect2.titlepage.recto.style" use-attribute-sets="section.titlepage.recto.style"/><xsl:attribute-set name="sect2.titlepage.verso.style" use-attribute-sets="section.titlepage.verso.style"/><xsl:attribute-set name="sect3.titlepage.recto.style" use-attribute-sets="section.titlepage.recto.style"/><xsl:attribute-set name="sect3.titlepage.verso.style" use-attribute-sets="section.titlepage.verso.style"/><xsl:attribute-set name="sect4.titlepage.recto.style" use-attribute-sets="section.titlepage.recto.style"/><xsl:attribute-set name="sect4.titlepage.verso.style" use-attribute-sets="section.titlepage.verso.style"/><xsl:attribute-set name="sect5.titlepage.recto.style" use-attribute-sets="section.titlepage.recto.style"/><xsl:attribute-set name="sect5.titlepage.verso.style" use-attribute-sets="section.titlepage.verso.style"/><xsl:attribute-set name="simplesect.titlepage.recto.style" use-attribute-sets="section.titlepage.recto.style"/><xsl:attribute-set name="simplesect.titlepage.verso.style" use-attribute-sets="section.titlepage.verso.style"/><xsl:attribute-set name="table.of.contents.titlepage.recto.style"/><xsl:attribute-set name="table.of.contents.titlepage.verso.style"/><xsl:attribute-set name="list.of.tables.titlepage.recto.style"/><xsl:attribute-set name="list.of.tables.contents.titlepage.verso.style"/><xsl:attribute-set name="list.of.figures.titlepage.recto.style"/><xsl:attribute-set name="list.of.figures.contents.titlepage.verso.style"/><xsl:attribute-set name="list.of.equations.titlepage.recto.style"/><xsl:attribute-set name="list.of.equations.contents.titlepage.verso.style"/><xsl:attribute-set name="list.of.examples.titlepage.recto.style"/><xsl:attribute-set name="list.of.examples.contents.titlepage.verso.style"/><xsl:attribute-set name="list.of.unknowns.titlepage.recto.style"/><xsl:attribute-set name="list.of.unknowns.contents.titlepage.verso.style"/><xsl:template match="*" mode="titlepage.mode">
  <!-- if an element isn't found in this mode, try the default mode -->
  <xsl:apply-templates select="."/>
</xsl:template><xsl:template match="abbrev" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="abstract" mode="titlepage.mode">
  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:if test="$abstract.notitle.enabled = 0">
      <xsl:call-template name="formal.object.heading">
        <xsl:with-param name="title">
          <xsl:apply-templates select="." mode="title.markup"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:if>
    <xsl:apply-templates mode="titlepage.mode"/>
    <xsl:call-template name="process.footnotes"/>
  </div>
</xsl:template><xsl:template match="abstract/title" mode="titlepage.mode">
</xsl:template><xsl:template match="address" mode="titlepage.mode">
  <xsl:param name="suppress-numbers" select="'0'"/>

  <xsl:variable name="rtf">
    <xsl:apply-templates mode="titlepage.mode"/>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$suppress-numbers = '0'                     and @linenumbering = 'numbered'                     and $use.extensions != '0'                     and $linenumbering.extension != '0'">
      <div>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:call-template name="paragraph">
          <xsl:with-param name="content">
            <xsl:call-template name="number.rtf.lines">
              <xsl:with-param name="rtf" select="$rtf"/>
            </xsl:call-template>
          </xsl:with-param>
        </xsl:call-template>
      </div>
    </xsl:when>

    <xsl:otherwise>
      <div>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:call-template name="paragraph">
          <xsl:with-param name="content">
            <xsl:call-template name="make-verbatim">
              <xsl:with-param name="rtf" select="$rtf"/>
            </xsl:call-template>
          </xsl:with-param>
        </xsl:call-template>
      </div>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="affiliation" mode="titlepage.mode">
  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </div>
</xsl:template><xsl:template match="artpagenums" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="author|editor" mode="titlepage.mode">
  <xsl:call-template name="credits.div"/>
</xsl:template><xsl:template name="credits.div">
  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:if test="self::editor[position()=1] and not($editedby.enabled = 0)">
      <h4 class="editedby"><xsl:call-template name="gentext.edited.by"/></h4>
    </xsl:if>
    <h3>
      <xsl:apply-templates select="." mode="common.html.attributes"/>
      <xsl:choose>
        <xsl:when test="orgname">
          <xsl:apply-templates/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="person.name"/>
        </xsl:otherwise>
      </xsl:choose>
    </h3>
    <xsl:if test="not($contrib.inline.enabled = 0)">
      <xsl:apply-templates mode="titlepage.mode" select="contrib"/>
    </xsl:if>
    <xsl:apply-templates mode="titlepage.mode" select="affiliation"/>
    <xsl:apply-templates mode="titlepage.mode" select="email"/>
    <xsl:if test="not($blurb.on.titlepage.enabled = 0)">
      <xsl:choose>
        <xsl:when test="$contrib.inline.enabled = 0">
          <xsl:apply-templates mode="titlepage.mode" select="contrib|authorblurb|personblurb"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates mode="titlepage.mode" select="authorblurb|personblurb"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </div>
</xsl:template><xsl:template match="authorblurb|personblurb" mode="titlepage.mode">
  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </div>
</xsl:template><xsl:template match="authorgroup" mode="titlepage.mode">
  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:if test="parent::refentryinfo">
      <h2>Authors</h2>
    </xsl:if>
      
    <xsl:call-template name="anchor"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </div>
</xsl:template><xsl:template match="authorinitials" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="bibliomisc" mode="titlepage.mode">
  <xsl:apply-templates mode="titlepage.mode"/>
</xsl:template><xsl:template match="bibliomset" mode="titlepage.mode">
  <xsl:apply-templates mode="titlepage.mode"/>
</xsl:template><xsl:template match="collabname" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </span>
</xsl:template><xsl:template match="confgroup" mode="titlepage.mode">
  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </div>
</xsl:template><xsl:template match="confdates" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="confsponsor" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="conftitle" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="confnum" mode="titlepage.mode">
  <!-- suppress -->
</xsl:template><xsl:template match="contractnum" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="contractsponsor" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="contrib" mode="titlepage.mode">
  <xsl:choose>
    <xsl:when test="not($contrib.inline.enabled = 0)">
      <span>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:call-template name="id.attribute"/>
        <xsl:apply-templates mode="titlepage.mode"/>
      </span><xsl:text>Â </xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <div>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:call-template name="id.attribute"/>
        <p><xsl:apply-templates mode="titlepage.mode"/></p>
      </div>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="copyright" mode="titlepage.mode">

  <xsl:if test="generate-id() = generate-id(//refentryinfo/copyright[1])       and ($stylesheet.result.type = 'html' or $stylesheet.result.type = 'xhtml')">
    <h2>Copyright</h2>
  </xsl:if>

  <p>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="gentext">
      <xsl:with-param name="key" select="'Copyright'"/>
    </xsl:call-template>
    <xsl:call-template name="gentext.space"/>
    <xsl:call-template name="dingbat">
      <xsl:with-param name="dingbat">copyright</xsl:with-param>
    </xsl:call-template>
    <xsl:call-template name="gentext.space"/>
    <xsl:call-template name="copyright.years">
      <xsl:with-param name="years" select="year"/>
      <xsl:with-param name="print.ranges" select="$make.year.ranges"/>
      <xsl:with-param name="single.year.ranges" select="$make.single.year.ranges"/>
    </xsl:call-template>
    <xsl:call-template name="gentext.space"/>
    <xsl:apply-templates select="holder" mode="titlepage.mode"/>
  </p>
</xsl:template><xsl:template match="year" mode="titlepage.mode">
  <xsl:choose>
    <xsl:when test="$show.revisionflag != 0 and @revisionflag">
      <span class="{@revisionflag}">
        <xsl:apply-templates mode="titlepage.mode"/>
      </span>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="titlepage.mode"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="holder" mode="titlepage.mode">
  <xsl:choose>
    <xsl:when test="$show.revisionflag != 0 and @revisionflag">
      <span class="{@revisionflag}">
        <xsl:apply-templates mode="titlepage.mode"/>
      </span>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates mode="titlepage.mode"/>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:if test="position() &lt; last()">
    <xsl:text>, </xsl:text>
  </xsl:if>
</xsl:template><xsl:template match="corpauthor" mode="titlepage.mode">
  <h3>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </h3>
</xsl:template><xsl:template match="corpcredit" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="corpname" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="date" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="edition" mode="titlepage.mode">
  <p>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <xsl:call-template name="gentext.space"/>
    <xsl:call-template name="gentext">
      <xsl:with-param name="key" select="'Edition'"/>
    </xsl:call-template>
  </p>
</xsl:template><xsl:template match="email" mode="titlepage.mode">
  <!-- use the normal e-mail handling code -->
  <xsl:apply-templates select="."/>
</xsl:template><xsl:template match="firstname" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="graphic" mode="titlepage.mode">
  <!-- use the normal graphic handling code -->
  <xsl:apply-templates select="."/>
</xsl:template><xsl:template match="honorific" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="isbn" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="issn" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="biblioid" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="itermset" mode="titlepage.mode">
</xsl:template><xsl:template match="invpartnumber" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="issuenum" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="jobtitle" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="keywordset" mode="titlepage.mode">
</xsl:template><xsl:template match="legalnotice" mode="titlepage.mode">
  <xsl:variable name="id"><xsl:call-template name="object.id"/></xsl:variable>

  <xsl:choose>
    <xsl:when test="$generate.legalnotice.link != 0">
      
      <!-- Compute name of legalnotice file -->
      <xsl:variable name="file">
	<xsl:call-template name="ln.or.rh.filename"/>
      </xsl:variable>

      <xsl:variable name="filename">
        <xsl:call-template name="make-relative-filename">
          <xsl:with-param name="base.dir" select="$chunk.base.dir"/>
	  <xsl:with-param name="base.name" select="$file"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:variable name="title">
        <xsl:apply-templates select="." mode="title.markup"/>
      </xsl:variable>

      <a href="{$file}">
        <xsl:copy-of select="$title"/>
      </a>

      <xsl:call-template name="write.chunk">
        <xsl:with-param name="filename" select="$filename"/>
        <xsl:with-param name="quiet" select="$chunk.quietly"/>
        <xsl:with-param name="content">
        <xsl:call-template name="user.preroot"/>
          <html>
            <head>
              <xsl:call-template name="system.head.content"/>
              <xsl:call-template name="head.content"/>
              <xsl:call-template name="user.head.content"/>
            </head>
            <body>
              <xsl:call-template name="body.attributes"/>
              <div>
                <xsl:apply-templates select="." mode="common.html.attributes"/>
                <xsl:call-template name="id.attribute">
                  <xsl:with-param name="conditional" select="0"/>
                </xsl:call-template>
                <xsl:apply-templates mode="titlepage.mode"/>
              </div>
            </body>
          </html>
          <xsl:value-of select="$chunk.append"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <div>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:call-template name="id.attribute">
          <xsl:with-param name="conditional" select="0"/>
        </xsl:call-template>
        <xsl:call-template name="anchor">
          <xsl:with-param name="conditional" select="0"/>
        </xsl:call-template>
        <xsl:apply-templates mode="titlepage.mode"/>
      </div>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="legalnotice/title" mode="titlepage.mode">
  <p class="legalnotice-title"><strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform"><xsl:apply-templates/></strong></p>
</xsl:template><xsl:template match="lineage" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="modespec" mode="titlepage.mode">
</xsl:template><xsl:template match="orgdiv" mode="titlepage.mode">
  <xsl:if test="preceding-sibling::*[1][self::orgname]">
    <xsl:text> </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="orgname" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="othercredit" mode="titlepage.mode">
<xsl:choose>
  <xsl:when test="not($othercredit.like.author.enabled = 0)">
  <xsl:variable name="contrib" select="string(contrib)"/>
  <xsl:choose>
    <xsl:when test="contrib">
      <xsl:if test="not(preceding-sibling::othercredit[string(contrib)=$contrib])">
        <xsl:call-template name="paragraph">
          <xsl:with-param name="class" select="local-name(.)"/>
          <xsl:with-param name="content">
            <xsl:apply-templates mode="titlepage.mode" select="contrib"/>
            <xsl:text>: </xsl:text>
            <xsl:call-template name="person.name"/>
            <xsl:apply-templates mode="titlepage.mode" select="affiliation"/>
            <xsl:apply-templates select="following-sibling::othercredit[string(contrib)=$contrib]" mode="titlepage.othercredits"/>
          </xsl:with-param>
        </xsl:call-template>
      </xsl:if>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="paragraph">
        <xsl:with-param name="class" select="local-name(.)"/>
        <xsl:with-param name="content">
          <xsl:call-template name="person.name"/>
        </xsl:with-param>
      </xsl:call-template>
      <xsl:apply-templates mode="titlepage.mode" select="affiliation"/>
    </xsl:otherwise>
  </xsl:choose>
  </xsl:when>
  <xsl:otherwise>
    <xsl:call-template name="credits.div"/>
  </xsl:otherwise>
</xsl:choose>
</xsl:template><xsl:template match="othercredit" mode="titlepage.othercredits">
  <xsl:text>, </xsl:text>
  <xsl:call-template name="person.name"/>
</xsl:template><xsl:template match="othername" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="pagenums" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="printhistory" mode="titlepage.mode">
  <div>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </div>
</xsl:template><xsl:template match="productname" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="productnumber" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="pubdate" mode="titlepage.mode">
  <xsl:call-template name="paragraph">
    <xsl:with-param name="class" select="local-name(.)"/>
    <xsl:with-param name="content">
      <xsl:apply-templates mode="titlepage.mode"/>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template><xsl:template match="publisher" mode="titlepage.mode">
  <xsl:call-template name="paragraph">
    <xsl:with-param name="class" select="local-name(.)"/>
    <xsl:with-param name="content">
      <xsl:apply-templates mode="titlepage.mode"/>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template><xsl:template match="publishername" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="pubsnumber" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="releaseinfo" mode="titlepage.mode">
  <xsl:call-template name="paragraph">
    <xsl:with-param name="class" select="local-name(.)"/>
    <xsl:with-param name="content">
      <xsl:apply-templates mode="titlepage.mode"/>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template><xsl:template match="revhistory" mode="titlepage.mode">
  <xsl:variable name="numcols">
    <xsl:choose>
      <xsl:when test=".//authorinitials|.//author">3</xsl:when>
      <xsl:otherwise>2</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="id"><xsl:call-template name="object.id"/></xsl:variable>

  <xsl:variable name="title">
    <xsl:call-template name="gentext">
      <xsl:with-param name="key">RevHistory</xsl:with-param>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="contents">
    <div>
      <xsl:apply-templates select="." mode="common.html.attributes"/>
      <xsl:call-template name="id.attribute"/>
      <table>
        <xsl:if test="$css.decoration != 0">
          <xsl:attribute name="style">
            <xsl:text>border-style:solid; width:100%;</xsl:text>
          </xsl:attribute>
        </xsl:if>
        <!-- include summary attribute if not HTML5 -->
        <xsl:if test="$div.element != 'section'">
          <xsl:attribute name="summary">
            <xsl:call-template name="gentext">
              <xsl:with-param name="key">revhistory</xsl:with-param>
            </xsl:call-template>
          </xsl:attribute>
        </xsl:if>
        <tr>
          <th align="{$direction.align.start}" valign="top" colspan="{$numcols}">
            <strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform">
              <xsl:call-template name="gentext">
                <xsl:with-param name="key" select="'RevHistory'"/>
              </xsl:call-template>
            </strong>
          </th>
        </tr>
        <xsl:apply-templates mode="titlepage.mode">
          <xsl:with-param name="numcols" select="$numcols"/>
        </xsl:apply-templates>
      </table>
    </div>
  </xsl:variable>
  
  <xsl:choose>
    <xsl:when test="$generate.revhistory.link != 0">
      
      <!-- Compute name of revhistory file -->
      <xsl:variable name="file">
	<xsl:call-template name="ln.or.rh.filename">
	  <xsl:with-param name="is.ln" select="false()"/>
	</xsl:call-template>
      </xsl:variable>

      <xsl:variable name="filename">
        <xsl:call-template name="make-relative-filename">
          <xsl:with-param name="base.dir" select="$chunk.base.dir"/>
          <xsl:with-param name="base.name" select="$file"/>
        </xsl:call-template>
      </xsl:variable>

      <a href="{$file}">
        <xsl:copy-of select="$title"/>
      </a>

      <xsl:call-template name="write.chunk">
        <xsl:with-param name="filename" select="$filename"/>
        <xsl:with-param name="quiet" select="$chunk.quietly"/>
        <xsl:with-param name="content">
        <xsl:call-template name="user.preroot"/>
          <html>
            <head>
              <xsl:call-template name="system.head.content"/>
              <xsl:call-template name="head.content">
                <xsl:with-param name="title">
                    <xsl:value-of select="$title"/>
                    <xsl:if test="../../title">
                        <xsl:value-of select="concat(' (', ../../title, ')')"/>
                    </xsl:if>
                </xsl:with-param>
              </xsl:call-template>
              <xsl:call-template name="user.head.content"/>
            </head>
            <body>
              <xsl:call-template name="body.attributes"/>
              <xsl:copy-of select="$contents"/>
            </body>
          </html>
          <xsl:text>
</xsl:text>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="$contents"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="revhistory/revision" mode="titlepage.mode">
  <xsl:param name="numcols" select="'3'"/>
  <xsl:variable name="revnumber" select="revnumber"/>
  <xsl:variable name="revdate" select="date"/>
  <xsl:variable name="revauthor" select="authorinitials|author"/>
  <xsl:variable name="revremark" select="revremark|revdescription"/>
  <tr>
    <td align="{$direction.align.start}">
      <xsl:if test="$revnumber">
        <xsl:call-template name="gentext">
          <xsl:with-param name="key" select="'Revision'"/>
        </xsl:call-template>
        <xsl:call-template name="gentext.space"/>
        <xsl:apply-templates select="$revnumber[1]" mode="titlepage.mode"/>
      </xsl:if>
    </td>
    <td align="{$direction.align.start}">
      <xsl:apply-templates select="$revdate[1]" mode="titlepage.mode"/>
    </td>
    <xsl:choose>
      <xsl:when test="$revauthor">
        <td align="{$direction.align.start}">
          <xsl:for-each select="$revauthor">
            <xsl:apply-templates select="." mode="titlepage.mode"/>
            <xsl:if test="position() != last()">
	      <xsl:text>, </xsl:text>
	    </xsl:if>
	  </xsl:for-each>
        </td>
      </xsl:when>
      <xsl:when test="$numcols &gt; 2">
        <td>Â </td>
      </xsl:when>
      <xsl:otherwise/>
    </xsl:choose>
  </tr>
  <xsl:if test="$revremark">
    <tr>
      <td align="{$direction.align.start}" colspan="{$numcols}">
        <xsl:apply-templates select="$revremark[1]" mode="titlepage.mode"/>
      </td>
    </tr>
  </xsl:if>
</xsl:template><xsl:template match="revision/revnumber" mode="titlepage.mode">
  <xsl:apply-templates mode="titlepage.mode"/>
</xsl:template><xsl:template match="revision/date" mode="titlepage.mode">
  <xsl:apply-templates mode="titlepage.mode"/>
</xsl:template><xsl:template match="revision/authorinitials" mode="titlepage.mode">
  <xsl:apply-templates mode="titlepage.mode"/>
</xsl:template><xsl:template match="revision/author" mode="titlepage.mode">
  <xsl:apply-templates mode="titlepage.mode"/>
</xsl:template><xsl:template match="revision/revremark" mode="titlepage.mode">
  <xsl:apply-templates mode="titlepage.mode"/>
</xsl:template><xsl:template match="revision/revdescription" mode="titlepage.mode">
  <xsl:apply-templates mode="titlepage.mode"/>
</xsl:template><xsl:template match="seriesvolnums" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="shortaffil" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="subjectset" mode="titlepage.mode">
</xsl:template><xsl:template match="subtitle" mode="titlepage.mode">
  <h2>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </h2>
</xsl:template><xsl:template match="surname" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template match="title" mode="titlepage.mode">
  <xsl:variable name="id">
    <xsl:choose>
      <!-- if title is in an *info wrapper, get the grandparent -->
      <xsl:when test="contains(local-name(..), 'info')">
        <xsl:call-template name="object.id">
          <xsl:with-param name="object" select="../.."/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="object.id">
          <xsl:with-param name="object" select=".."/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <h1>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:choose>
      <xsl:when test="$generate.id.attributes = 0">
        <a id="{$id}"/>
      </xsl:when>
      <xsl:otherwise>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:choose>
      <xsl:when test="$show.revisionflag != 0 and @revisionflag">
	<span class="{@revisionflag}">
	  <xsl:apply-templates mode="titlepage.mode"/>
	</span>
      </xsl:when>
      <xsl:otherwise>
	<xsl:apply-templates mode="titlepage.mode"/>
      </xsl:otherwise>
    </xsl:choose>
  </h1>
</xsl:template><xsl:template match="titleabbrev" mode="titlepage.mode">
  <!-- nop; title abbreviations don't belong on the title page! -->
</xsl:template><xsl:template match="volumenum" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="common.html.attributes"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
    <br/>
  </span>
</xsl:template><xsl:template name="ln.or.rh.filename">
  <xsl:param name="node" select="."/>
  <xsl:param name="is.ln" select="true()"/>

  <xsl:variable name="dbhtml-filename">
    <xsl:call-template name="pi.dbhtml_filename">
      <xsl:with-param name="node" select="$node"/>
    </xsl:call-template>
  </xsl:variable>
 
  <xsl:choose>
    <!--  1. If there is a dbhtml_filename PI, use that -->
    <xsl:when test="$dbhtml-filename != ''">
      <xsl:value-of select="$dbhtml-filename"/>
    </xsl:when>
    <xsl:when test="($node/@id or $node/@xml:id) and not($use.id.as.filename = 0)">
      <!-- * 2. If this legalnotice/revhistory has an ID, then go ahead and use -->
      <!-- * just the value of that ID as the basename for the file -->
      <!-- * (that is, without prepending an "ln-" or "rh-" to it) -->
      <xsl:value-of select="($node/@id|$node/@xml:id)[1]"/>
      <xsl:value-of select="$html.ext"/>
    </xsl:when>
    <xsl:when test="not ($node/@id or $node/@xml:id) or $use.id.as.filename = 0">
      <!-- * 3. Otherwise, if this legalnotice/revhistory does not have an ID, or -->
      <!-- * if $use.id.as.filename = 0 -->
      <!-- * then we generate an ID... -->
      <xsl:variable name="id">
	<xsl:value-of select="generate-id($node)"/>
      </xsl:variable>
      <!-- * ...and then we take that generated ID, prepend a -->
      <!-- * prefix to it, and use that as the basename for the file -->
      <xsl:choose>
	<xsl:when test="$is.ln">
	  <xsl:value-of select="concat('ln-',$id,$html.ext)"/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:value-of select="concat('rh-',$id,$html.ext)"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:when>
  </xsl:choose>
</xsl:template>
<xsl:template name="article.titlepage.recto">
  <xsl:choose>
    <xsl:when test="articleinfo/title">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/title"/>
    </xsl:when>
    <xsl:when test="artheader/title">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="articleinfo/subtitle">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="artheader/subtitle">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/corpauthor"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/corpauthor"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/authorgroup"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/authorgroup"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/author"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/author"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/othercredit"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/othercredit"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/releaseinfo"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/releaseinfo"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/copyright"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/copyright"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/legalnotice"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/legalnotice"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/pubdate"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/pubdate"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/revision"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/revision"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/revhistory"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/revhistory"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/abstract"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/abstract"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="article.titlepage.verso">
</xsl:template><xsl:template name="article.titlepage.separator">
</xsl:template><xsl:template name="article.titlepage.before.recto">
</xsl:template><xsl:template name="article.titlepage.before.verso">
</xsl:template><xsl:template name="article.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="article.titlepage.before.recto"/>
      <xsl:call-template name="article.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="article.titlepage.before.verso"/>
      <xsl:call-template name="article.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="article.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="article.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="article.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="article.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="article.titlepage.recto.style">
<xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="article.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="article.titlepage.recto.style">
<xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="article.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="article.titlepage.recto.style">
<xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="article.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="article.titlepage.recto.style">
<xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="article.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="article.titlepage.recto.style">
<xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="article.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="article.titlepage.recto.style">
<xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="article.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="article.titlepage.recto.style">
<xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="article.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="article.titlepage.recto.style">
<xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="article.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="article.titlepage.recto.style">
<xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="article.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="article.titlepage.recto.style">
<xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="article.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="article.titlepage.recto.style">
<xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="article.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="article.titlepage.recto.style">
<xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="article.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="article.titlepage.recto.style">
<xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="set.titlepage.recto">
  <xsl:choose>
    <xsl:when test="setinfo/title">
      <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="setinfo/subtitle">
      <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/corpauthor"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/authorgroup"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/author"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/othercredit"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/releaseinfo"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/copyright"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/legalnotice"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/pubdate"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/revision"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/revhistory"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/abstract"/>
  <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="set.titlepage.verso">
</xsl:template><xsl:template name="set.titlepage.separator">
</xsl:template><xsl:template name="set.titlepage.before.recto">
</xsl:template><xsl:template name="set.titlepage.before.verso">
</xsl:template><xsl:template name="set.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="set.titlepage.before.recto"/>
      <xsl:call-template name="set.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="set.titlepage.before.verso"/>
      <xsl:call-template name="set.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="set.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="set.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="set.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="set.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="set.titlepage.recto.style">
<xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="set.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="set.titlepage.recto.style">
<xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="set.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="set.titlepage.recto.style">
<xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="set.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="set.titlepage.recto.style">
<xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="set.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="set.titlepage.recto.style">
<xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="set.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="set.titlepage.recto.style">
<xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="set.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="set.titlepage.recto.style">
<xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="set.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="set.titlepage.recto.style">
<xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="set.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="set.titlepage.recto.style">
<xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="set.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="set.titlepage.recto.style">
<xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="set.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="set.titlepage.recto.style">
<xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="set.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="set.titlepage.recto.style">
<xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="set.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="set.titlepage.recto.style">
<xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="book.titlepage.recto">
  <xsl:choose>
    <xsl:when test="bookinfo/title">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="bookinfo/subtitle">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/corpauthor"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/authorgroup"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/author"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/othercredit"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/releaseinfo"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/copyright"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/legalnotice"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/pubdate"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/revision"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/revhistory"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/abstract"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="book.titlepage.verso">
</xsl:template><xsl:template name="book.titlepage.separator">
</xsl:template><xsl:template name="book.titlepage.before.recto">
</xsl:template><xsl:template name="book.titlepage.before.verso">
</xsl:template><xsl:template name="book.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="book.titlepage.before.recto"/>
      <xsl:call-template name="book.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="book.titlepage.before.verso"/>
      <xsl:call-template name="book.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="book.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="book.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="book.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="book.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="book.titlepage.recto.style">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="book.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="book.titlepage.recto.style">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="book.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="book.titlepage.recto.style">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="book.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="book.titlepage.recto.style">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="book.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="book.titlepage.recto.style">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="book.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="book.titlepage.recto.style">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="book.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="book.titlepage.recto.style">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="book.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="book.titlepage.recto.style">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="book.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="book.titlepage.recto.style">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="book.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="book.titlepage.recto.style">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="book.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="book.titlepage.recto.style">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="book.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="book.titlepage.recto.style">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="book.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="book.titlepage.recto.style">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="part.titlepage.recto">
  <div xsl:use-attribute-sets="part.titlepage.recto.style">
<xsl:call-template name="division.title">
<xsl:with-param name="node" select="ancestor-or-self::part[1]"/>
</xsl:call-template></div>
  <xsl:choose>
    <xsl:when test="partinfo/subtitle">
      <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="docinfo/subtitle">
      <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/corpauthor"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/corpauthor"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/authorgroup"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/authorgroup"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/author"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/author"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/othercredit"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/othercredit"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/releaseinfo"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/releaseinfo"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/copyright"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/copyright"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/legalnotice"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/legalnotice"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/pubdate"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/pubdate"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/revision"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/revision"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/revhistory"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/revhistory"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/abstract"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/abstract"/>
  <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="part.titlepage.verso">
</xsl:template><xsl:template name="part.titlepage.separator">
</xsl:template><xsl:template name="part.titlepage.before.recto">
</xsl:template><xsl:template name="part.titlepage.before.verso">
</xsl:template><xsl:template name="part.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="part.titlepage.before.recto"/>
      <xsl:call-template name="part.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="part.titlepage.before.verso"/>
      <xsl:call-template name="part.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="part.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="part.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="part.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="subtitle" mode="part.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="part.titlepage.recto.style">
<xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="part.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="part.titlepage.recto.style">
<xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="part.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="part.titlepage.recto.style">
<xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="part.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="part.titlepage.recto.style">
<xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="part.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="part.titlepage.recto.style">
<xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="part.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="part.titlepage.recto.style">
<xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="part.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="part.titlepage.recto.style">
<xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="part.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="part.titlepage.recto.style">
<xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="part.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="part.titlepage.recto.style">
<xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="part.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="part.titlepage.recto.style">
<xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="part.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="part.titlepage.recto.style">
<xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="part.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="part.titlepage.recto.style">
<xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="partintro.titlepage.recto">
  <xsl:choose>
    <xsl:when test="partintroinfo/title">
      <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/title"/>
    </xsl:when>
    <xsl:when test="docinfo/title">
      <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="partintroinfo/subtitle">
      <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="docinfo/subtitle">
      <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/corpauthor"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/corpauthor"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/authorgroup"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/authorgroup"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/author"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/author"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/othercredit"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/othercredit"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/releaseinfo"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/releaseinfo"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/copyright"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/copyright"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/legalnotice"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/legalnotice"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/pubdate"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/pubdate"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/revision"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/revision"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/revhistory"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/revhistory"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/abstract"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/abstract"/>
  <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="partintro.titlepage.verso">
</xsl:template><xsl:template name="partintro.titlepage.separator">
</xsl:template><xsl:template name="partintro.titlepage.before.recto">
</xsl:template><xsl:template name="partintro.titlepage.before.verso">
</xsl:template><xsl:template name="partintro.titlepage">
  <div>
    <xsl:variable name="recto.content">
      <xsl:call-template name="partintro.titlepage.before.recto"/>
      <xsl:call-template name="partintro.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="partintro.titlepage.before.verso"/>
      <xsl:call-template name="partintro.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="partintro.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="partintro.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="partintro.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="partintro.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="partintro.titlepage.recto.style">
<xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="partintro.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="partintro.titlepage.recto.style">
<xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="partintro.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="partintro.titlepage.recto.style">
<xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="partintro.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="partintro.titlepage.recto.style">
<xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="partintro.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="partintro.titlepage.recto.style">
<xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="partintro.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="partintro.titlepage.recto.style">
<xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="partintro.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="partintro.titlepage.recto.style">
<xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="partintro.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="partintro.titlepage.recto.style">
<xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="partintro.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="partintro.titlepage.recto.style">
<xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="partintro.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="partintro.titlepage.recto.style">
<xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="partintro.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="partintro.titlepage.recto.style">
<xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="partintro.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="partintro.titlepage.recto.style">
<xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="partintro.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="partintro.titlepage.recto.style">
<xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="reference.titlepage.recto">
  <xsl:choose>
    <xsl:when test="referenceinfo/title">
      <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/title"/>
    </xsl:when>
    <xsl:when test="docinfo/title">
      <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="referenceinfo/subtitle">
      <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="docinfo/subtitle">
      <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/corpauthor"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/corpauthor"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/authorgroup"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/authorgroup"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/author"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/author"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/othercredit"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/othercredit"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/releaseinfo"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/releaseinfo"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/copyright"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/copyright"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/legalnotice"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/legalnotice"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/pubdate"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/pubdate"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/revision"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/revision"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/revhistory"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/revhistory"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/abstract"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/abstract"/>
  <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="reference.titlepage.verso">
</xsl:template><xsl:template name="reference.titlepage.separator">
</xsl:template><xsl:template name="reference.titlepage.before.recto">
</xsl:template><xsl:template name="reference.titlepage.before.verso">
</xsl:template><xsl:template name="reference.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="reference.titlepage.before.recto"/>
      <xsl:call-template name="reference.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="reference.titlepage.before.verso"/>
      <xsl:call-template name="reference.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="reference.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="reference.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="reference.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="reference.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="reference.titlepage.recto.style">
<xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="reference.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="reference.titlepage.recto.style">
<xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="reference.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="reference.titlepage.recto.style">
<xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="reference.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="reference.titlepage.recto.style">
<xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="reference.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="reference.titlepage.recto.style">
<xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="reference.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="reference.titlepage.recto.style">
<xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="reference.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="reference.titlepage.recto.style">
<xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="reference.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="reference.titlepage.recto.style">
<xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="reference.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="reference.titlepage.recto.style">
<xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="reference.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="reference.titlepage.recto.style">
<xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="reference.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="reference.titlepage.recto.style">
<xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="reference.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="reference.titlepage.recto.style">
<xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="reference.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="reference.titlepage.recto.style">
<xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="refentry.titlepage.recto">
</xsl:template><xsl:template name="refentry.titlepage.verso">
</xsl:template><xsl:template name="refentry.titlepage.separator">
</xsl:template><xsl:template name="refentry.titlepage.before.recto">
</xsl:template><xsl:template name="refentry.titlepage.before.verso">
</xsl:template><xsl:template name="refentry.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="refentry.titlepage.before.recto"/>
      <xsl:call-template name="refentry.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="refentry.titlepage.before.verso"/>
      <xsl:call-template name="refentry.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="refentry.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="refentry.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="refentry.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template name="dedication.titlepage.recto">
  <div xsl:use-attribute-sets="dedication.titlepage.recto.style">
<xsl:call-template name="component.title">
<xsl:with-param name="node" select="ancestor-or-self::dedication[1]"/>
</xsl:call-template></div>
  <xsl:choose>
    <xsl:when test="dedicationinfo/subtitle">
      <xsl:apply-templates mode="dedication.titlepage.recto.auto.mode" select="dedicationinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="docinfo/subtitle">
      <xsl:apply-templates mode="dedication.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="dedication.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="dedication.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

</xsl:template><xsl:template name="dedication.titlepage.verso">
</xsl:template><xsl:template name="dedication.titlepage.separator">
</xsl:template><xsl:template name="dedication.titlepage.before.recto">
</xsl:template><xsl:template name="dedication.titlepage.before.verso">
</xsl:template><xsl:template name="dedication.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="dedication.titlepage.before.recto"/>
      <xsl:call-template name="dedication.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="dedication.titlepage.before.verso"/>
      <xsl:call-template name="dedication.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="dedication.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="dedication.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="dedication.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="subtitle" mode="dedication.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="dedication.titlepage.recto.style">
<xsl:apply-templates select="." mode="dedication.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="acknowledgements.titlepage.recto">
  <div xsl:use-attribute-sets="acknowledgements.titlepage.recto.style">
<xsl:call-template name="component.title">
<xsl:with-param name="node" select="ancestor-or-self::acknowledgements[1]"/>
</xsl:call-template></div>
  <xsl:choose>
    <xsl:when test="acknowledgementsinfo/subtitle">
      <xsl:apply-templates mode="acknowledgements.titlepage.recto.auto.mode" select="acknowledgementsinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="docinfo/subtitle">
      <xsl:apply-templates mode="acknowledgements.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="acknowledgements.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="acknowledgements.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

</xsl:template><xsl:template name="acknowledgements.titlepage.verso">
</xsl:template><xsl:template name="acknowledgements.titlepage.separator">
</xsl:template><xsl:template name="acknowledgements.titlepage.before.recto">
</xsl:template><xsl:template name="acknowledgements.titlepage.before.verso">
</xsl:template><xsl:template name="acknowledgements.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="acknowledgements.titlepage.before.recto"/>
      <xsl:call-template name="acknowledgements.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="acknowledgements.titlepage.before.verso"/>
      <xsl:call-template name="acknowledgements.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="acknowledgements.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="acknowledgements.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="acknowledgements.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="subtitle" mode="acknowledgements.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="acknowledgements.titlepage.recto.style">
<xsl:apply-templates select="." mode="acknowledgements.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="preface.titlepage.recto">
  <xsl:choose>
    <xsl:when test="prefaceinfo/title">
      <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/title"/>
    </xsl:when>
    <xsl:when test="docinfo/title">
      <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="prefaceinfo/subtitle">
      <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="docinfo/subtitle">
      <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/corpauthor"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/corpauthor"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/authorgroup"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/authorgroup"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/author"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/author"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/othercredit"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/othercredit"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/releaseinfo"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/releaseinfo"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/copyright"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/copyright"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/legalnotice"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/legalnotice"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/pubdate"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/pubdate"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/revision"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/revision"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/revhistory"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/revhistory"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/abstract"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/abstract"/>
  <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="preface.titlepage.verso">
</xsl:template><xsl:template name="preface.titlepage.separator">
</xsl:template><xsl:template name="preface.titlepage.before.recto">
</xsl:template><xsl:template name="preface.titlepage.before.verso">
</xsl:template><xsl:template name="preface.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="preface.titlepage.before.recto"/>
      <xsl:call-template name="preface.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="preface.titlepage.before.verso"/>
      <xsl:call-template name="preface.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="preface.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="preface.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="preface.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="preface.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="preface.titlepage.recto.style">
<xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="preface.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="preface.titlepage.recto.style">
<xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="preface.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="preface.titlepage.recto.style">
<xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="preface.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="preface.titlepage.recto.style">
<xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="preface.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="preface.titlepage.recto.style">
<xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="preface.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="preface.titlepage.recto.style">
<xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="preface.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="preface.titlepage.recto.style">
<xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="preface.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="preface.titlepage.recto.style">
<xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="preface.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="preface.titlepage.recto.style">
<xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="preface.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="preface.titlepage.recto.style">
<xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="preface.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="preface.titlepage.recto.style">
<xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="preface.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="preface.titlepage.recto.style">
<xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="preface.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="preface.titlepage.recto.style">
<xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="chapter.titlepage.recto">
  <xsl:choose>
    <xsl:when test="chapterinfo/title">
      <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/title"/>
    </xsl:when>
    <xsl:when test="docinfo/title">
      <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="chapterinfo/subtitle">
      <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="docinfo/subtitle">
      <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/corpauthor"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/corpauthor"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/authorgroup"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/authorgroup"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/author"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/author"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/othercredit"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/othercredit"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/releaseinfo"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/releaseinfo"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/copyright"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/copyright"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/legalnotice"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/legalnotice"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/pubdate"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/pubdate"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/revision"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/revision"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/revhistory"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/revhistory"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/abstract"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/abstract"/>
  <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="chapter.titlepage.verso">
</xsl:template><xsl:template name="chapter.titlepage.separator">
</xsl:template><xsl:template name="chapter.titlepage.before.recto">
</xsl:template><xsl:template name="chapter.titlepage.before.verso">
</xsl:template><xsl:template name="chapter.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="chapter.titlepage.before.recto"/>
      <xsl:call-template name="chapter.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="chapter.titlepage.before.verso"/>
      <xsl:call-template name="chapter.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="chapter.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="chapter.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="chapter.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="chapter.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="chapter.titlepage.recto.style">
<xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="chapter.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="chapter.titlepage.recto.style">
<xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="chapter.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="chapter.titlepage.recto.style">
<xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="chapter.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="chapter.titlepage.recto.style">
<xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="chapter.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="chapter.titlepage.recto.style">
<xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="chapter.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="chapter.titlepage.recto.style">
<xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="chapter.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="chapter.titlepage.recto.style">
<xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="chapter.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="chapter.titlepage.recto.style">
<xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="chapter.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="chapter.titlepage.recto.style">
<xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="chapter.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="chapter.titlepage.recto.style">
<xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="chapter.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="chapter.titlepage.recto.style">
<xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="chapter.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="chapter.titlepage.recto.style">
<xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="chapter.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="chapter.titlepage.recto.style">
<xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="topic.titlepage.recto">
  <xsl:choose>
    <xsl:when test="topicinfo/title">
      <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="topicinfo/subtitle">
      <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/corpauthor"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/authorgroup"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/author"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/othercredit"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/releaseinfo"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/copyright"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/legalnotice"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/pubdate"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/revision"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/revhistory"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/abstract"/>
  <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="topic.titlepage.verso">
</xsl:template><xsl:template name="topic.titlepage.separator">
</xsl:template><xsl:template name="topic.titlepage.before.recto">
</xsl:template><xsl:template name="topic.titlepage.before.verso">
</xsl:template><xsl:template name="topic.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="topic.titlepage.before.recto"/>
      <xsl:call-template name="topic.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="topic.titlepage.before.verso"/>
      <xsl:call-template name="topic.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="topic.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="topic.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="topic.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="topic.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="topic.titlepage.recto.style">
<xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="topic.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="topic.titlepage.recto.style">
<xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="topic.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="topic.titlepage.recto.style">
<xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="topic.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="topic.titlepage.recto.style">
<xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="topic.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="topic.titlepage.recto.style">
<xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="topic.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="topic.titlepage.recto.style">
<xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="topic.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="topic.titlepage.recto.style">
<xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="topic.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="topic.titlepage.recto.style">
<xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="topic.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="topic.titlepage.recto.style">
<xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="topic.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="topic.titlepage.recto.style">
<xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="topic.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="topic.titlepage.recto.style">
<xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="topic.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="topic.titlepage.recto.style">
<xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="topic.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="topic.titlepage.recto.style">
<xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="appendix.titlepage.recto">
  <xsl:choose>
    <xsl:when test="appendixinfo/title">
      <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/title"/>
    </xsl:when>
    <xsl:when test="docinfo/title">
      <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="appendixinfo/subtitle">
      <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="docinfo/subtitle">
      <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/corpauthor"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/corpauthor"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/authorgroup"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/authorgroup"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/author"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/author"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/othercredit"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/othercredit"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/releaseinfo"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/releaseinfo"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/copyright"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/copyright"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/legalnotice"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/legalnotice"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/pubdate"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/pubdate"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/revision"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/revision"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/revhistory"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/revhistory"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/abstract"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/abstract"/>
  <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="appendix.titlepage.verso">
</xsl:template><xsl:template name="appendix.titlepage.separator">
</xsl:template><xsl:template name="appendix.titlepage.before.recto">
</xsl:template><xsl:template name="appendix.titlepage.before.verso">
</xsl:template><xsl:template name="appendix.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="appendix.titlepage.before.recto"/>
      <xsl:call-template name="appendix.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="appendix.titlepage.before.verso"/>
      <xsl:call-template name="appendix.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="appendix.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="appendix.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="appendix.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="appendix.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="appendix.titlepage.recto.style">
<xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="appendix.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="appendix.titlepage.recto.style">
<xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="appendix.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="appendix.titlepage.recto.style">
<xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="appendix.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="appendix.titlepage.recto.style">
<xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="appendix.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="appendix.titlepage.recto.style">
<xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="appendix.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="appendix.titlepage.recto.style">
<xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="appendix.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="appendix.titlepage.recto.style">
<xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="appendix.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="appendix.titlepage.recto.style">
<xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="appendix.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="appendix.titlepage.recto.style">
<xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="appendix.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="appendix.titlepage.recto.style">
<xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="appendix.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="appendix.titlepage.recto.style">
<xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="appendix.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="appendix.titlepage.recto.style">
<xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="appendix.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="appendix.titlepage.recto.style">
<xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="section.titlepage.recto">
  <xsl:choose>
    <xsl:when test="sectioninfo/title">
      <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="sectioninfo/subtitle">
      <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/corpauthor"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/authorgroup"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/author"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/othercredit"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/releaseinfo"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/copyright"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/legalnotice"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/pubdate"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/revision"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/revhistory"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/abstract"/>
  <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="section.titlepage.verso">
</xsl:template><xsl:template name="section.titlepage.separator"><xsl:if test="count(parent::*)='0'"><hr/></xsl:if>
</xsl:template><xsl:template name="section.titlepage.before.recto">
</xsl:template><xsl:template name="section.titlepage.before.verso">
</xsl:template><xsl:template name="section.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="section.titlepage.before.recto"/>
      <xsl:call-template name="section.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="section.titlepage.before.verso"/>
      <xsl:call-template name="section.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="section.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="section.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="section.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="section.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="section.titlepage.recto.style">
<xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="section.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="section.titlepage.recto.style">
<xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="section.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="section.titlepage.recto.style">
<xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="section.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="section.titlepage.recto.style">
<xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="section.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="section.titlepage.recto.style">
<xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="section.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="section.titlepage.recto.style">
<xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="section.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="section.titlepage.recto.style">
<xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="section.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="section.titlepage.recto.style">
<xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="section.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="section.titlepage.recto.style">
<xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="section.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="section.titlepage.recto.style">
<xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="section.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="section.titlepage.recto.style">
<xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="section.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="section.titlepage.recto.style">
<xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="section.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="section.titlepage.recto.style">
<xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="sect1.titlepage.recto">
  <xsl:choose>
    <xsl:when test="sect1info/title">
      <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="sect1info/subtitle">
      <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/corpauthor"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/authorgroup"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/author"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/othercredit"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/releaseinfo"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/copyright"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/legalnotice"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/pubdate"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/revision"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/revhistory"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/abstract"/>
  <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="sect1.titlepage.verso">
</xsl:template><xsl:template name="sect1.titlepage.separator"><xsl:if test="count(parent::*)='0'"><hr/></xsl:if>
</xsl:template><xsl:template name="sect1.titlepage.before.recto">
</xsl:template><xsl:template name="sect1.titlepage.before.verso">
</xsl:template><xsl:template name="sect1.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="sect1.titlepage.before.recto"/>
      <xsl:call-template name="sect1.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="sect1.titlepage.before.verso"/>
      <xsl:call-template name="sect1.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="sect1.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="sect1.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="sect1.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="sect1.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect1.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="sect1.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect1.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="sect1.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect1.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="sect1.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect1.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="sect1.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect1.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="sect1.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect1.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="sect1.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect1.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="sect1.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect1.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="sect1.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect1.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="sect1.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect1.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="sect1.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect1.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="sect1.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect1.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="sect1.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect1.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="sect2.titlepage.recto">
  <xsl:choose>
    <xsl:when test="sect2info/title">
      <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="sect2info/subtitle">
      <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/corpauthor"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/authorgroup"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/author"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/othercredit"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/releaseinfo"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/copyright"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/legalnotice"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/pubdate"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/revision"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/revhistory"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/abstract"/>
  <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="sect2.titlepage.verso">
</xsl:template><xsl:template name="sect2.titlepage.separator"><xsl:if test="count(parent::*)='0'"><hr/></xsl:if>
</xsl:template><xsl:template name="sect2.titlepage.before.recto">
</xsl:template><xsl:template name="sect2.titlepage.before.verso">
</xsl:template><xsl:template name="sect2.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="sect2.titlepage.before.recto"/>
      <xsl:call-template name="sect2.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="sect2.titlepage.before.verso"/>
      <xsl:call-template name="sect2.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="sect2.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="sect2.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="sect2.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="sect2.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect2.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="sect2.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect2.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="sect2.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect2.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="sect2.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect2.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="sect2.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect2.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="sect2.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect2.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="sect2.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect2.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="sect2.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect2.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="sect2.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect2.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="sect2.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect2.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="sect2.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect2.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="sect2.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect2.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="sect2.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect2.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="sect3.titlepage.recto">
  <xsl:choose>
    <xsl:when test="sect3info/title">
      <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="sect3info/subtitle">
      <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/corpauthor"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/authorgroup"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/author"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/othercredit"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/releaseinfo"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/copyright"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/legalnotice"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/pubdate"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/revision"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/revhistory"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/abstract"/>
  <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="sect3.titlepage.verso">
</xsl:template><xsl:template name="sect3.titlepage.separator"><xsl:if test="count(parent::*)='0'"><hr/></xsl:if>
</xsl:template><xsl:template name="sect3.titlepage.before.recto">
</xsl:template><xsl:template name="sect3.titlepage.before.verso">
</xsl:template><xsl:template name="sect3.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="sect3.titlepage.before.recto"/>
      <xsl:call-template name="sect3.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="sect3.titlepage.before.verso"/>
      <xsl:call-template name="sect3.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="sect3.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="sect3.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="sect3.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="sect3.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect3.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="sect3.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect3.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="sect3.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect3.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="sect3.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect3.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="sect3.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect3.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="sect3.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect3.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="sect3.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect3.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="sect3.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect3.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="sect3.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect3.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="sect3.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect3.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="sect3.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect3.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="sect3.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect3.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="sect3.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect3.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="sect4.titlepage.recto">
  <xsl:choose>
    <xsl:when test="sect4info/title">
      <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="sect4info/subtitle">
      <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/corpauthor"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/authorgroup"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/author"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/othercredit"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/releaseinfo"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/copyright"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/legalnotice"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/pubdate"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/revision"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/revhistory"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/abstract"/>
  <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="sect4.titlepage.verso">
</xsl:template><xsl:template name="sect4.titlepage.separator"><xsl:if test="count(parent::*)='0'"><hr/></xsl:if>
</xsl:template><xsl:template name="sect4.titlepage.before.recto">
</xsl:template><xsl:template name="sect4.titlepage.before.verso">
</xsl:template><xsl:template name="sect4.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="sect4.titlepage.before.recto"/>
      <xsl:call-template name="sect4.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="sect4.titlepage.before.verso"/>
      <xsl:call-template name="sect4.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="sect4.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="sect4.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="sect4.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="sect4.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect4.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="sect4.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect4.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="sect4.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect4.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="sect4.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect4.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="sect4.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect4.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="sect4.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect4.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="sect4.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect4.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="sect4.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect4.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="sect4.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect4.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="sect4.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect4.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="sect4.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect4.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="sect4.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect4.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="sect4.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect4.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="sect5.titlepage.recto">
  <xsl:choose>
    <xsl:when test="sect5info/title">
      <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="sect5info/subtitle">
      <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/corpauthor"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/authorgroup"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/author"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/othercredit"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/releaseinfo"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/copyright"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/legalnotice"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/pubdate"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/revision"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/revhistory"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/abstract"/>
  <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="sect5.titlepage.verso">
</xsl:template><xsl:template name="sect5.titlepage.separator"><xsl:if test="count(parent::*)='0'"><hr/></xsl:if>
</xsl:template><xsl:template name="sect5.titlepage.before.recto">
</xsl:template><xsl:template name="sect5.titlepage.before.verso">
</xsl:template><xsl:template name="sect5.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="sect5.titlepage.before.recto"/>
      <xsl:call-template name="sect5.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="sect5.titlepage.before.verso"/>
      <xsl:call-template name="sect5.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="sect5.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="sect5.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="sect5.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="sect5.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect5.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="sect5.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect5.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="sect5.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect5.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="sect5.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect5.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="sect5.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect5.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="sect5.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect5.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="sect5.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect5.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="sect5.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect5.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="sect5.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect5.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="sect5.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect5.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="sect5.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect5.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="sect5.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect5.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="sect5.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sect5.titlepage.recto.style">
<xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="simplesect.titlepage.recto">
  <xsl:choose>
    <xsl:when test="simplesectinfo/title">
      <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/title"/>
    </xsl:when>
    <xsl:when test="docinfo/title">
      <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="simplesectinfo/subtitle">
      <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="docinfo/subtitle">
      <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/corpauthor"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/corpauthor"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/authorgroup"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/authorgroup"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/author"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/author"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/othercredit"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/othercredit"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/releaseinfo"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/releaseinfo"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/copyright"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/copyright"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/legalnotice"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/legalnotice"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/pubdate"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/pubdate"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/revision"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/revision"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/revhistory"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/revhistory"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/abstract"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/abstract"/>
  <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template name="simplesect.titlepage.verso">
</xsl:template><xsl:template name="simplesect.titlepage.separator"><xsl:if test="count(parent::*)='0'"><hr/></xsl:if>
</xsl:template><xsl:template name="simplesect.titlepage.before.recto">
</xsl:template><xsl:template name="simplesect.titlepage.before.verso">
</xsl:template><xsl:template name="simplesect.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="simplesect.titlepage.before.recto"/>
      <xsl:call-template name="simplesect.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="simplesect.titlepage.before.verso"/>
      <xsl:call-template name="simplesect.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="simplesect.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="simplesect.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="simplesect.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="simplesect.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
<xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="subtitle" mode="simplesect.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
<xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="corpauthor" mode="simplesect.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
<xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="authorgroup" mode="simplesect.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
<xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="author" mode="simplesect.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
<xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="othercredit" mode="simplesect.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
<xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="releaseinfo" mode="simplesect.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
<xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="copyright" mode="simplesect.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
<xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="legalnotice" mode="simplesect.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
<xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="pubdate" mode="simplesect.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
<xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revision" mode="simplesect.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
<xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="revhistory" mode="simplesect.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
<xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template match="abstract" mode="simplesect.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
<xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="bibliography.titlepage.recto">
  <div xsl:use-attribute-sets="bibliography.titlepage.recto.style">
<xsl:call-template name="component.title">
<xsl:with-param name="node" select="ancestor-or-self::bibliography[1]"/>
</xsl:call-template></div>
  <xsl:choose>
    <xsl:when test="bibliographyinfo/subtitle">
      <xsl:apply-templates mode="bibliography.titlepage.recto.auto.mode" select="bibliographyinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="docinfo/subtitle">
      <xsl:apply-templates mode="bibliography.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="bibliography.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="bibliography.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

</xsl:template><xsl:template name="bibliography.titlepage.verso">
</xsl:template><xsl:template name="bibliography.titlepage.separator">
</xsl:template><xsl:template name="bibliography.titlepage.before.recto">
</xsl:template><xsl:template name="bibliography.titlepage.before.verso">
</xsl:template><xsl:template name="bibliography.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="bibliography.titlepage.before.recto"/>
      <xsl:call-template name="bibliography.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="bibliography.titlepage.before.verso"/>
      <xsl:call-template name="bibliography.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="bibliography.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="bibliography.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="bibliography.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="subtitle" mode="bibliography.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="bibliography.titlepage.recto.style">
<xsl:apply-templates select="." mode="bibliography.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="glossary.titlepage.recto">
  <div xsl:use-attribute-sets="glossary.titlepage.recto.style">
<xsl:call-template name="component.title">
<xsl:with-param name="node" select="ancestor-or-self::glossary[1]"/>
</xsl:call-template></div>
  <xsl:choose>
    <xsl:when test="glossaryinfo/subtitle">
      <xsl:apply-templates mode="glossary.titlepage.recto.auto.mode" select="glossaryinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="docinfo/subtitle">
      <xsl:apply-templates mode="glossary.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="glossary.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="glossary.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

</xsl:template><xsl:template name="glossary.titlepage.verso">
</xsl:template><xsl:template name="glossary.titlepage.separator">
</xsl:template><xsl:template name="glossary.titlepage.before.recto">
</xsl:template><xsl:template name="glossary.titlepage.before.verso">
</xsl:template><xsl:template name="glossary.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="glossary.titlepage.before.recto"/>
      <xsl:call-template name="glossary.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="glossary.titlepage.before.verso"/>
      <xsl:call-template name="glossary.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="glossary.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="glossary.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="glossary.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="subtitle" mode="glossary.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="glossary.titlepage.recto.style">
<xsl:apply-templates select="." mode="glossary.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="index.titlepage.recto">
  <div xsl:use-attribute-sets="index.titlepage.recto.style">
<xsl:call-template name="component.title">
<xsl:with-param name="node" select="ancestor-or-self::index[1]"/>
</xsl:call-template></div>
  <xsl:choose>
    <xsl:when test="indexinfo/subtitle">
      <xsl:apply-templates mode="index.titlepage.recto.auto.mode" select="indexinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="docinfo/subtitle">
      <xsl:apply-templates mode="index.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="index.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="index.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

</xsl:template><xsl:template name="index.titlepage.verso">
</xsl:template><xsl:template name="index.titlepage.separator">
</xsl:template><xsl:template name="index.titlepage.before.recto">
</xsl:template><xsl:template name="index.titlepage.before.verso">
</xsl:template><xsl:template name="index.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="index.titlepage.before.recto"/>
      <xsl:call-template name="index.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="index.titlepage.before.verso"/>
      <xsl:call-template name="index.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="index.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="index.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="index.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="subtitle" mode="index.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="index.titlepage.recto.style">
<xsl:apply-templates select="." mode="index.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="setindex.titlepage.recto">
  <div xsl:use-attribute-sets="setindex.titlepage.recto.style">
<xsl:call-template name="component.title">
<xsl:with-param name="node" select="ancestor-or-self::setindex[1]"/>
</xsl:call-template></div>
  <xsl:choose>
    <xsl:when test="setindexinfo/subtitle">
      <xsl:apply-templates mode="setindex.titlepage.recto.auto.mode" select="setindexinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="docinfo/subtitle">
      <xsl:apply-templates mode="setindex.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="setindex.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="setindex.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

</xsl:template><xsl:template name="setindex.titlepage.verso">
</xsl:template><xsl:template name="setindex.titlepage.separator">
</xsl:template><xsl:template name="setindex.titlepage.before.recto">
</xsl:template><xsl:template name="setindex.titlepage.before.verso">
</xsl:template><xsl:template name="setindex.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="setindex.titlepage.before.recto"/>
      <xsl:call-template name="setindex.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="setindex.titlepage.before.verso"/>
      <xsl:call-template name="setindex.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="setindex.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="setindex.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="setindex.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="subtitle" mode="setindex.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="setindex.titlepage.recto.style">
<xsl:apply-templates select="." mode="setindex.titlepage.recto.mode"/>
</div>
</xsl:template><xsl:template name="sidebar.titlepage.recto">
  <xsl:choose>
    <xsl:when test="sidebarinfo/title">
      <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="sidebarinfo/title"/>
    </xsl:when>
    <xsl:when test="docinfo/title">
      <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="docinfo/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="sidebarinfo/subtitle">
      <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="sidebarinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="docinfo/subtitle">
      <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

</xsl:template><xsl:template name="sidebar.titlepage.verso">
</xsl:template><xsl:template name="sidebar.titlepage.separator">
</xsl:template><xsl:template name="sidebar.titlepage.before.recto">
</xsl:template><xsl:template name="sidebar.titlepage.before.verso">
</xsl:template><xsl:template name="sidebar.titlepage">
  <div class="titlepage">
    <xsl:variable name="recto.content">
      <xsl:call-template name="sidebar.titlepage.before.recto"/>
      <xsl:call-template name="sidebar.titlepage.recto"/>
    </xsl:variable>
    <xsl:variable name="recto.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($recto.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
      <div><xsl:copy-of select="$recto.content"/></div>
    </xsl:if>
    <xsl:variable name="verso.content">
      <xsl:call-template name="sidebar.titlepage.before.verso"/>
      <xsl:call-template name="sidebar.titlepage.verso"/>
    </xsl:variable>
    <xsl:variable name="verso.elements.count">
      <xsl:choose>
        <xsl:when test="function-available('exsl:node-set')"><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
          <!--Xalan quirk--><xsl:value-of select="count(exsl:node-set($verso.content)/*)"/></xsl:when>
        <xsl:otherwise>1</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
      <div><xsl:copy-of select="$verso.content"/></div>
    </xsl:if>
    <xsl:call-template name="sidebar.titlepage.separator"/>
  </div>
</xsl:template><xsl:template match="*" mode="sidebar.titlepage.recto.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="*" mode="sidebar.titlepage.verso.mode">
  <!-- if an element isn't found in this mode, -->
  <!-- try the generic titlepage.mode -->
  <xsl:apply-templates select="." mode="titlepage.mode"/>
</xsl:template><xsl:template match="title" mode="sidebar.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sidebar.titlepage.recto.style">
<xsl:call-template name="formal.object.heading">
<xsl:with-param name="object" select="ancestor-or-self::sidebar[1]"/>
</xsl:call-template>
</div>
</xsl:template><xsl:template match="subtitle" mode="sidebar.titlepage.recto.auto.mode">
<div xsl:use-attribute-sets="sidebar.titlepage.recto.style">
<xsl:apply-templates select="." mode="sidebar.titlepage.recto.mode"/>
</div>
</xsl:template>
<doc:reference xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0"><info xmlns="http://www.w3.org/1999/xhtml"><title>HTML Processing Instruction Reference</title>
    <releaseinfo role="meta">
      $Id: pi.xsl 9022 2011-07-14 19:21:36Z bobstayton $
    </releaseinfo>
  </info>
  <partintro xmlns="http://www.w3.org/1999/xhtml" id="partintro">
    <title>Introduction</title>
    <para>This is generated reference documentation for all
      user-specifiable processing instructions (PIs) in the DocBook
      XSL stylesheets for HTML output.
      <note>
        <para>You add these PIs at particular points in a document to
          cause specific â€œexceptionsâ€ to formatting/output behavior. To
          make global changes in formatting/output behavior across an
          entire document, itâ€™s better to do it by setting an
          appropriate stylesheet parameter (if there is one).</para>
      </note>
    </para>
  </partintro>
</doc:reference><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_background-color">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Sets background color for an image</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml background-color</tag> PI before or
      after an image (<tag>graphic</tag>, <tag>inlinegraphic</tag>,
      <tag>imagedata</tag>, or <tag>videodata</tag> element) as a
      sibling to the element, to set a background color for the
      image.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml background-color="<replaceable>color</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>background-color="<replaceable>color</replaceable>"</term>
        <listitem>
          <para>An HTML color value</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="BGcolor.html">Background color</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_background-color">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'background-color'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_bgcolor">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Sets background color on a CALS table row or table cell</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml bgcolor</tag> PI as child of a CALS table row
      or cell to set a background color for that table row or cell.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml bgcolor="<replaceable>color</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>bgcolor="<replaceable>color</replaceable>"</term>
        <listitem>
          <para>An HTML color value</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="BGtableColor.html#CellBGColor">Cell background color</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_bgcolor">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'bgcolor'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_cellpadding">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies cellpadding in CALS table or qandaset output</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml cellpadding</tag> PI as a child of a
      CALS <tag>table</tag> or <tag>qandaset</tag> to specify the value
      for the HTML <literal>cellpadding</literal> attribute in the
      output HTML table.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml cellpadding="<replaceable>number</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>cellpadding="<replaceable>number</replaceable>"</term>
        <listitem>
          <para>Specifies the cellpadding</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
    <para><parameter>html.cellpadding</parameter></para>
  </refsee>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="CellSpacing.html">Cell spacing and cell padding</link>,
      <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="QandAformat.html">Q and A formatting</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_cellpadding">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'cellpadding'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_cellspacing">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies cellspacing in CALS table or qandaset output</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml cellspacing</tag> PI as a child of a
      CALS <tag>table</tag> or <tag>qandaset</tag> to specify the value
      for the HTML <literal>cellspacing</literal> attribute in the
      output HTML table.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml cellspacing="<replaceable>number</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>cellspacing="<replaceable>number</replaceable>"</term>
        <listitem>
          <para>Specifies the cellspacing</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
    <para><parameter>html.cellspacing</parameter></para>
  </refsee>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="CellSpacing.html">Cell spacing and cell padding</link>,
      <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="QandAformat.html">Q and A formatting</link></para>
    </refsee>
</doc:pi><xsl:template name="pi.dbhtml_cellspacing">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'cellspacing'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_class">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Set value of the class attribute for a CALS table row</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml class</tag> PI as a child of a
      <tag>row</tag> to specify a <literal>class</literal>
      attribute and value in the HTML output for that row.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml class="<replaceable>name</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>class="<replaceable>name</replaceable>"</term>
        <listitem>
          <para>Specifies the class name</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="CSSTableCells.html">Table styles in HTML output</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_class">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'class'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_dir">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies a directory name in which to write files</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>When chunking output, use the <tag class="xmlpi">dbhtml dir</tag> PI
      as a child of a chunk source to cause the output of that
      chunk to be written to the specified directory; also, use it
      as a child of a <tag>mediaobject</tag> to specify a
      directory into which any long-description files for that
      <tag>mediaobject</tag> will be written.</para>

<para>The output directory specification is inherited by all
chunks of the descendants of the element.  If descendants need
to go to a different directory, then add another 
<tag class="xmlpi">dbhtml dir</tag> processing
instruction as a child of the source element
for that chunk, and specify the path relative to the
ancestor path.</para>

<para>For example, to put most chunk files into 
<filename class="directory">shared</filename>
but one chapter into 
<filename class="directory">exception</filename>
at the same level, use:</para>

<programlisting>&lt;book&gt;
  &lt;?dbhtml dir="shared"?&gt;
  ...
  &lt;chapter&gt;
    &lt;?dbhtml dir="../exception"?&gt;
  &lt;/chapter&gt;
&lt;/book&gt;
</programlisting>


  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml dir="<replaceable>path</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>dir="<replaceable>path</replaceable>"</term>
        <listitem>
          <para>Specifies the pathname for the directory</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
    <para><parameter>base.dir</parameter></para>
  </refsee>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Chunking.html#dbhtmlDirPI">dbhtml dir processing instruction</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_dir">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'dir'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_filename">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies a filename for a chunk</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
<para>When chunking output, use the <tag class="xmlpi">dbhtml filename</tag>
      PI as a child of a chunk source to specify a filename for
      the output file for that chunk. Include the filename suffix.</para>

<para>You cannot include a directory path in the filename value,
or your links may not work.  Add a 
<tag class="xmlpi">dbhtml dir</tag> processing instruction
to specify the output directory. You can also combine the two
specifications in one processing instruction: 
<tag class="xmlpi">dbhtml dir="mydir" filename="myfile.html"</tag>.</para>

  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml filename="<replaceable>filename</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>filename="<replaceable>path</replaceable>"</term>
        <listitem>
          <para>Specifies the filename for the file</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
    <para><parameter>use.id.as.filename</parameter></para>
  </refsee>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Chunking.html#DbhtmlFilenames">dbhtml filenames</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_filename">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'filename'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_funcsynopsis-style">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies presentation style for a funcsynopsis</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml funcsynopsis-style</tag> PI as a child of
      a <tag>funcsynopsis</tag> or anywhere within a funcsynopsis
      to control the presentation style for output of all
      <tag>funcprototype</tag> instances within that funcsynopsis.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml funcsynopsis-style="kr"|"ansi"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>funcsynopsis-style="kr"</term>
        <listitem>
          <para>Displays <tag>funcprototype</tag> output in K&amp;R style</para>
        </listitem>
      </varlistentry>
      <varlistentry><term>funcsynopsis-style="ansi"</term>
        <listitem>
          <para>Displays <tag>funcprototype</tag> output in ANSI style</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
    <para><parameter>funcsynopsis.style</parameter></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_funcsynopsis-style">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'funcsynopsis-style'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_img.src.path">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies a path to the location of an image file</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml img.src.path</tag> PI before or
      after an image (<tag>graphic</tag>,
      <tag>inlinegraphic</tag>, <tag>imagedata</tag>, or
      <tag>videodata</tag> element) as a sibling to the element,
      to specify a path to the location of the image; in HTML
      output, the value specified for the
      <code>img.src.path</code> attribute is prepended to the
      filename.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml img.src.path="<replaceable>path</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>img.src.path="<replaceable>path</replaceable>"</term>
        <listitem>
          <para>Specifies the pathname to prepend to the name of the image file</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
    <para><parameter>img.src.path</parameter></para>
  </refsee>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="GraphicsLocations.html#UsingFileref">Using fileref</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_img.src.path">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'img.src.path'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_label-width">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies the label width for a qandaset</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml label-width</tag> PI as a child of a
      <tag>qandaset</tag> to specify the width of labels.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml label-width="<replaceable>width</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>label-width="<replaceable>width</replaceable>"</term>
        <listitem>
          <para>Specifies the label width (including units)</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="QandAformat.html">Q and A formatting</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_label-width">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'label-width'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_linenumbering.everyNth">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies interval for line numbers in verbatims</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml linenumbering.everyNth</tag> PI as a child
      of a â€œverbatimâ€ element â€“ <tag>programlisting</tag>,
      <tag>screen</tag>, <tag>synopsis</tag> â€” to specify
      the interval at which lines are numbered.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml linenumbering.everyNth="<replaceable>N</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>linenumbering.everyNth="<replaceable>N</replaceable>"</term>
        <listitem>
          <para>Specifies numbering interval; a number is output
            before every <replaceable>N</replaceable>th line</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
    <para><parameter>linenumbering.everyNth</parameter></para>
  </refsee>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="AnnotateListing.html#LineNumbering">Line numbering</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_linenumbering.everyNth">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'linenumbering.everyNth'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_linenumbering.separator">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies separator text for line numbers in verbatims</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml linenumbering.separator</tag> PI as a child
      of a â€œverbatimâ€ element â€“ <tag>programlisting</tag>,
      <tag>screen</tag>, <tag>synopsis</tag> â€” to specify
      the separator text output between the line numbers and content.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml linenumbering.separator="<replaceable>text</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>linenumbering.separator="<replaceable>text</replaceable>"</term>
        <listitem>
          <para>Specifies the text (zero or more characters)</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
    <para><parameter>linenumbering.separator</parameter></para>
  </refsee>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="AnnotateListing.html#LineNumbering">Line numbering</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_linenumbering.separator">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'linenumbering.separator'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_linenumbering.width">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies width for line numbers in verbatims</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml linenumbering.width</tag> PI as a child
      of a â€œverbatimâ€ element â€“ <tag>programlisting</tag>,
      <tag>screen</tag>, <tag>synopsis</tag> â€” to specify
      the width set aside for line numbers.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml linenumbering.width="<replaceable>width</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>linenumbering.width="<replaceable>width</replaceable>"</term>
        <listitem>
          <para>Specifies the width (inluding units)</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
    <para><parameter>linenumbering.width</parameter></para>
  </refsee>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="AnnotateListing.html#LineNumbering">Line numbering</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_linenumbering.width">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'linenumbering.width'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_list-presentation">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies presentation style for a variablelist or
    segmentedlist</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml list-presentation</tag> PI as a child of
      a <tag>variablelist</tag> or <tag>segmentedlist</tag> to
      control the presentation style for the list (to cause it, for
      example, to be displayed as a table).</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml list-presentation="list"|"table"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>list-presentation="list"</term>
        <listitem>
          <para>Displays the list as a list</para>
        </listitem>
      </varlistentry>
      <varlistentry><term>list-presentation="table"</term>
        <listitem>
          <para>Displays the list as a table</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
    <itemizedlist>
      <listitem>
        <para><parameter>variablelist.as.table</parameter></para>
      </listitem>
      <listitem>
        <para><parameter>segmentedlist.as.table</parameter></para>
      </listitem>
    </itemizedlist>
  </refsee>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Variablelists.html#VarListFormatting">Variable list formatting in HTML</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_list-presentation">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'list-presentation'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_list-width">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies the width of a variablelist or simplelist</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml list-width</tag> PI as a child of a
      <tag>variablelist</tag> or a <tag>simplelist</tag> presented
      as a table, to specify the output width.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml list-width="<replaceable>width</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>list-width="<replaceable>width</replaceable>"</term>
        <listitem>
          <para>Specifies the output width (including units)</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Variablelists.html#VarListFormatting">Variable list formatting in HTML</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_list-width">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'list-width'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_row-height">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies the height for a CALS table row</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml row-height</tag> PI as a child of a
      <tag>row</tag> to specify the height of the row.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml row-height="<replaceable>height</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>row-height="<replaceable>height</replaceable>"</term>
        <listitem>
          <para>Specifies the row height (including units)</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="RowHeight.html">Row height</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_row-height">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'row-height'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_start">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">(obsolete) Sets the starting number on an ordered list</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para><emphasis>This PI is obsolete</emphasis>. The intent of
      this PI was to provide a means for setting a specific starting
      number for an ordered list. Instead of this PI, set a value
      for the <literal>override</literal> attribute on the first
      <tag>listitem</tag> in the list; that will have the same
      effect as what this PI was intended for.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml start="<replaceable>character</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>start="<replaceable>character</replaceable>"</term>
        <listitem>
          <para>Specifies the character to use as the starting
            number; use 0-9, a-z, A-Z, or lowercase or uppercase
            Roman numerals</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Orderedlists.html#ListStartNum">List starting number</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_start">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="pi-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'start'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_stop-chunking">
	<refpurpose xmlns="http://www.w3.org/1999/xhtml">Do not chunk any descendants of this element.</refpurpose>
	<refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>When generating chunked HTML output, adding this PI as the child of an element that contains elements that would normally be generated on separate pages if generating chunked output causes chunking to stop at this point. No descendants of the current element will be split into new HTML pages:
<programlisting>&lt;section&gt;
&lt;title&gt;Configuring pencil&lt;/title&gt;
&lt;?dbhtml stop-chunking?&gt;

...

&lt;/section&gt;</programlisting>
</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml stop-chunking</tag></synopsis>
  </refsynopsisdiv>	
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Chunking.html">Chunking into multiple HTML files</link></para>
  </refsee>
  </doc:pi><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_table-summary">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies summary for CALS table, variablelist, segmentedlist, or qandaset output</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml table-summary</tag> PI as a child of
      a CALS <tag>table</tag>, <tag>variablelist</tag>,
      <tag>segmentedlist</tag>, or <tag>qandaset</tag> to specify
      the text for the HTML <literal>summary</literal> attribute
      in the output HTML table.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml table-summary="<replaceable>text</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>table-summary="<replaceable>text</replaceable>"</term>
        <listitem>
          <para>Specifies the summary text (zero or more characters)</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Variablelists.html#VarListFormatting">Variable list formatting in HTML</link>,
      <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="TableSummary.html">Table summary text</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_table-summary">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'table-summary'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_table-width">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies the width for a CALS table</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml table-width</tag> PI as a child of a
      CALS <tag>table</tag> to specify the width of the table in
      output.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml table-width="<replaceable>width</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>table-width="<replaceable>width</replaceable>"</term>
        <listitem>
          <para>Specifies the table width (including units or as a percentage)</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
    <para><parameter>default.table.width</parameter></para>
  </refsee>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Tables.html#TableWidth">Table width</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_table-width">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'table-width'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_term-presentation">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Sets character formatting for terms in a variablelist</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml term-presentation</tag> PI as a child
      of a <tag>variablelist</tag> to set character formatting for
      the <tag>term</tag> output of the list.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml term-presentation="bold"|"italic"|"bold-italic"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>term-presentation="<replaceable>bold</replaceable>"</term>
        <listitem>
          <para>Specifies that terms are displayed in bold</para>
        </listitem>
      </varlistentry>
      <varlistentry><term>term-presentation="<replaceable>italic</replaceable>"</term>
        <listitem>
          <para>Specifies that terms are displayed in italic</para>
        </listitem>
      </varlistentry>
      <varlistentry><term>term-presentation="<replaceable>bold-italic</replaceable>"</term>
        <listitem>
          <para>Specifies that terms are displayed in bold-italic</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Variablelists.html#VarListFormatting">Variable list formatting in HTML</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_term-presentation">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'term-presentation'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_term-separator">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies separator text among terms in a varlistentry</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml term-separator</tag> PI as a child
      of a <tag>variablelist</tag> to specify the separator text
      among <tag>term</tag> instances.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml term-separator="<replaceable>text</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>term-separator="<replaceable>text</replaceable>"</term>
        <listitem>
          <para>Specifies the text (zero or more characters)</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
    <para><parameter>variablelist.term.separator</parameter></para>
  </refsee>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Variablelists.html#VarListFormatting">Variable list formatting in HTML</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_term-separator">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'term-separator'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_term-width">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies the term width for a variablelist</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml term-width</tag> PI as a child of a
      <tag>variablelist</tag> to specify the width for
      <tag>term</tag> output.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml term-width="<replaceable>width</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>term-width="<replaceable>width</replaceable>"</term>
        <listitem>
          <para>Specifies the term width (including units)</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Variablelists.html#VarListFormatting">Variable list formatting in HTML</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_term-width">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'term-width'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_toc">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies whether a TOC should be generated for a qandaset</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhtml toc</tag> PI as a child of a
      <tag>qandaset</tag> to specify whether a table of contents
      (TOC) is generated for the <tag>qandaset</tag>.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhtml toc="0"|"1"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>toc="0"</term>
        <listitem>
          <para>If zero, no TOC is generated</para>
        </listitem>
      </varlistentry>
      <varlistentry><term>toc="1"</term>
        <listitem>
          <para>If <code>1</code> (or any non-zero value),
            a TOC is generated</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="QandAtoc.html">Q and A list of questions</link>,
      <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="QandAformat.html">Q and A formatting</link></para>
  </refsee>
</doc:pi><xsl:template name="pi.dbhtml_toc">
  <xsl:param name="node" select="."/>
  <xsl:call-template name="dbhtml-attribute">
    <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
    <xsl:with-param name="attribute" select="'toc'"/>
  </xsl:call-template>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbcmdlist">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Generates a hyperlinked list of commands</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbcmdlist</tag> PI as the child of any
      element (for example, <tag>refsynopsisdiv</tag>) containing multiple
      <tag>cmdsynopsis</tag> instances; a hyperlinked navigational
      â€œcommand listâ€ will be generated at the top of output for that
      element, enabling users to quickly jump
      to each command synopsis.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbcmdlist</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <para>[No parameters]</para>
  </refparameter>
</doc:pi><xsl:template name="pi.dbcmdlist">
  <xsl:variable name="cmdsynopses" select="..//cmdsynopsis"/>
  <xsl:if test="count($cmdsynopses)&lt;1">
    <xsl:message><xsl:text>No cmdsynopsis elements matched dbcmdlist PI, perhaps it's nested too deep?</xsl:text>
    </xsl:message>
  </xsl:if>
  <dl>
    <xsl:call-template name="process.cmdsynopsis.list">
      <xsl:with-param name="cmdsynopses" select="$cmdsynopses"/>
    </xsl:call-template>
  </dl>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbfunclist">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Generates a hyperlinked list of functions</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbfunclist</tag> PI as the child of any
      element (for example, <tag>refsynopsisdiv</tag>) containing multiple
      <tag>funcsynopsis</tag> instances; a hyperlinked
      navigational â€œfunction listâ€ will be generated at the top of
      output for that element, enabling users to quickly
      jump to to each function synopsis.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbfunclist</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <para>[No parameters]</para>
  </refparameter>
</doc:pi><xsl:template name="pi.dbfunclist">
  <xsl:variable name="funcsynopses" select="..//funcsynopsis"/>
  <xsl:if test="count($funcsynopses)&lt;1">
    <xsl:message><xsl:text>No funcsynopsis elements matched dbfunclist PI, perhaps it's nested too deep?</xsl:text>
    </xsl:message>
  </xsl:if>
  <dl>
    <xsl:call-template name="process.funcsynopsis.list">
      <xsl:with-param name="funcsynopses" select="$funcsynopses"/>
    </xsl:call-template>
  </dl>
</xsl:template><doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhh">
  <refpurpose xmlns="http://www.w3.org/1999/xhtml">Sets topic name and topic id for context-sensitive HTML Help</refpurpose>
  <refdescription xmlns="http://www.w3.org/1999/xhtml">
    <para>Use the <tag class="xmlpi">dbhh</tag> PI as a child of components
      that should be used as targets for context-sensitive help requests.</para>
  </refdescription>
  <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
    <synopsis><tag class="xmlpi">dbhh topicname="<replaceable>name</replaceable>" topicid="<replaceable>id</replaceable>"</tag></synopsis>
  </refsynopsisdiv>
  <refparameter xmlns="http://www.w3.org/1999/xhtml">
    <variablelist>
      <varlistentry><term>topicname="<replaceable>name</replaceable>"</term>
        <listitem>
          <para>Specifies a unique string constant that identifies a help topic</para>
        </listitem>
      </varlistentry>
      <varlistentry><term>topicid="<replaceable>id</replaceable>"</term>
        <listitem>
          <para>Specifies a unique integer value for the <literal>topicname</literal> string</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refparameter>
  <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
    <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="HtmlHelp.html#HHContextHelp">Context-sensitive help</link></para>
  </refsee>
</doc:pi><xsl:template name="dbhtml-attribute">
  <!-- * dbhtml-attribute is an interal utility template for retrieving -->
  <!-- * pseudo-attributes/parameters from PIs -->
  <xsl:param name="pis" select="processing-instruction('dbhtml')"/>
  <xsl:param name="attribute">filename</xsl:param>
  <xsl:call-template name="pi-attribute">
    <xsl:with-param name="pis" select="$pis"/>
    <xsl:with-param name="attribute" select="$attribute"/>
  </xsl:call-template>
</xsl:template><xsl:template match="processing-instruction()">
</xsl:template><xsl:template match="processing-instruction('dbhtml')">
  <!-- nop -->
</xsl:template><xsl:template match="processing-instruction('dbcmdlist')">
  <xsl:call-template name="pi.dbcmdlist"/>
</xsl:template><xsl:template name="process.cmdsynopsis.list">
  <xsl:param name="cmdsynopses"/><!-- empty node list by default -->
  <xsl:param name="count" select="1"/>

  <xsl:choose>
    <xsl:when test="$count&gt;count($cmdsynopses)"/>
    <xsl:otherwise>
      <xsl:variable name="cmdsyn" select="$cmdsynopses[$count]"/>

       <dt>
       <a>
         <xsl:attribute name="href">
           <xsl:text>#</xsl:text>
           <xsl:call-template name="object.id">
             <xsl:with-param name="object" select="$cmdsyn"/>
           </xsl:call-template>
         </xsl:attribute>

         <xsl:choose>
           <xsl:when test="$cmdsyn/@xreflabel">
             <xsl:call-template name="xref.xreflabel">
               <xsl:with-param name="target" select="$cmdsyn"/>
             </xsl:call-template>
           </xsl:when>
           <xsl:otherwise>
             <xsl:apply-templates select="$cmdsyn" mode="xref-to">
               <xsl:with-param name="target" select="$cmdsyn"/>
             </xsl:apply-templates>
           </xsl:otherwise>
         </xsl:choose>
       </a>
       </dt>

        <xsl:call-template name="process.cmdsynopsis.list">
          <xsl:with-param name="cmdsynopses" select="$cmdsynopses"/>
          <xsl:with-param name="count" select="$count+1"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template><xsl:template match="processing-instruction('dbfunclist')">
  <xsl:call-template name="pi.dbfunclist"/>
</xsl:template><xsl:template name="process.funcsynopsis.list">
  <xsl:param name="funcsynopses"/><!-- empty node list by default -->
  <xsl:param name="count" select="1"/>

  <xsl:choose>
    <xsl:when test="$count&gt;count($funcsynopses)"/>
    <xsl:otherwise>
      <xsl:variable name="cmdsyn" select="$funcsynopses[$count]"/>

       <dt>
       <a>
         <xsl:attribute name="href">
           <xsl:text>#</xsl:text>
           <xsl:call-template name="object.id">
             <xsl:with-param name="object" select="$cmdsyn"/>
           </xsl:call-template>
         </xsl:attribute>

         <xsl:choose>
           <xsl:when test="$cmdsyn/@xreflabel">
             <xsl:call-template name="xref.xreflabel">
               <xsl:with-param name="target" select="$cmdsyn"/>
             </xsl:call-template>
           </xsl:when>
           <xsl:otherwise>
              <xsl:apply-templates select="$cmdsyn" mode="xref-to">
                <xsl:with-param name="target" select="$cmdsyn"/>
              </xsl:apply-templates>
           </xsl:otherwise>
         </xsl:choose>
       </a>
       </dt>

        <xsl:call-template name="process.funcsynopsis.list">
          <xsl:with-param name="funcsynopses" select="$funcsynopses"/>
          <xsl:with-param name="count" select="$count+1"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template><xsl:template name="dbhtml-dir">
  <xsl:param name="context" select="."/>
  <!-- directories are now inherited from previous levels -->
  <xsl:variable name="ppath">
    <xsl:if test="$context/parent::*">
      <xsl:call-template name="dbhtml-dir">
        <xsl:with-param name="context" select="$context/parent::*"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:variable>
  <xsl:variable name="path">
    <xsl:call-template name="pi.dbhtml_dir">
      <xsl:with-param name="node" select="$context"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:choose>
    <xsl:when test="$path = ''">
      <xsl:if test="$ppath != ''">
        <xsl:value-of select="$ppath"/>
      </xsl:if>
    </xsl:when>
    <xsl:otherwise>
      <xsl:if test="$ppath != ''">
        <xsl:value-of select="$ppath"/>
        <xsl:if test="substring($ppath, string-length($ppath), 1) != '/'">
          <xsl:text>/</xsl:text>
        </xsl:if>
      </xsl:if>
      <xsl:value-of select="$path"/>
      <xsl:text>/</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<doc:reference xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0">
<referenceinfo xmlns="http://www.w3.org/1999/xhtml">
<releaseinfo role="meta">
$Id: ebnf.xsl 9664 2012-11-07 20:02:17Z bobstayton $
</releaseinfo>
<author><surname>Walsh</surname>
<firstname>Norman</firstname></author>
<copyright><year>1999</year><year>2000</year>
<holder>Norman Walsh</holder>
</copyright>
</referenceinfo>
<title xmlns="http://www.w3.org/1999/xhtml">HTML EBNF Reference</title>

<partintro xmlns="http://www.w3.org/1999/xhtml">
<section><title>Introduction</title>

<para>This is technical reference documentation for the DocBook XSL
Stylesheets; it documents (some of) the parameters, templates, and
other elements of the stylesheets.</para>

<para>This reference describes the templates and parameters relevant
to formatting EBNF markup.</para>

<para>This is not intended to be <quote>user</quote> documentation.
It is provided for developers writing customization layers for the
stylesheets, and for anyone who's interested in <quote>how it
works</quote>.</para>

<para>Although I am trying to be thorough, this documentation is known
to be incomplete. Don't forget to read the source, too :-)</para>
</section>
</partintro>
</doc:reference><xsl:template match="productionset">
  <table width="100%" cellpadding="5">
    <xsl:if test="$ebnf.table.bgcolor != ''">
      <xsl:attribute name="bgcolor">
        <xsl:value-of select="$ebnf.table.bgcolor"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:if test="$ebnf.table.border != 0">
      <xsl:attribute name="border">1</xsl:attribute>
    </xsl:if>
    <xsl:attribute name="class">
      <xsl:value-of select="local-name(.)"/>
    </xsl:attribute>
    <xsl:attribute name="summary">
      <xsl:text>EBNF</xsl:text>
      <xsl:if test="title|info/title">
        <xsl:text> for </xsl:text>
        <xsl:value-of select="title|info/title[1]"/>
      </xsl:if>
    </xsl:attribute>

    <xsl:if test="title|info/title">
      <tr>
        <th align="{$direction.align.start}" valign="top">
          <xsl:apply-templates select="." mode="class.attribute"/>
          <xsl:apply-templates select="title|info/title[1]"/>
        </th>
      </tr>
    </xsl:if>
    <tr>
      <td>
        <table border="0" width="99%" cellpadding="0">
          <xsl:if test="$ebnf.table.bgcolor != ''">
            <xsl:attribute name="bgcolor">
              <xsl:value-of select="$ebnf.table.bgcolor"/>
            </xsl:attribute>
          </xsl:if>
          <xsl:attribute name="class">
            <xsl:value-of select="local-name(.)"/>
          </xsl:attribute>
          <xsl:attribute name="summary">EBNF productions</xsl:attribute>
          <xsl:apply-templates select="production|productionrecap"/>
        </table>
      </td>
    </tr>
  </table>
</xsl:template><xsl:template match="productionset/title">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="production">
  <xsl:param name="recap" select="false()"/>
  <tr>
    <td align="{$direction.align.start}" valign="top" width="3%">
      <xsl:text>[</xsl:text>
      <xsl:apply-templates select="." mode="label.markup"/>
      <xsl:text>]</xsl:text>
    </td>
    <td align="{$direction.align.end}" valign="top" width="10%">
      <xsl:choose>
        <xsl:when test="$recap">
          <a>
            <xsl:attribute name="href">
              <xsl:call-template name="href.target">
                <xsl:with-param name="object" select="."/>
              </xsl:call-template>
            </xsl:attribute>
            <xsl:apply-templates select="lhs"/>
          </a>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="id.attribute"/>
          <xsl:call-template name="anchor"/>
          <xsl:apply-templates select="lhs"/>
        </xsl:otherwise>
      </xsl:choose>
    </td>
    <td valign="top" width="5%" align="center">
      <xsl:copy-of select="$ebnf.assignment"/>
    </td>
    <td valign="top" width="52%">
      <xsl:apply-templates select="rhs"/>
      <xsl:copy-of select="$ebnf.statement.terminator"/>
    </td>
    <td align="{$direction.align.start}" valign="top" width="30%">
      <xsl:choose>
        <xsl:when test="rhs/lineannotation|constraint">
          <xsl:apply-templates select="rhs/lineannotation" mode="rhslo"/>
          <xsl:apply-templates select="constraint"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>Â </xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </td>
  </tr>
</xsl:template><xsl:template match="productionrecap">
  <xsl:variable name="targets" select="key('id',@linkend)"/>
  <xsl:variable name="target" select="$targets[1]"/>

  <xsl:if test="count($targets)=0">
    <xsl:message>
      <xsl:text>Error: no ID for productionrecap linkend: </xsl:text>
      <xsl:value-of select="@linkend"/>
      <xsl:text>.</xsl:text>
    </xsl:message>
  </xsl:if>

  <xsl:if test="count($targets)&gt;1">
    <xsl:message>
      <xsl:text>Warning: multiple "IDs" for productionrecap linkend: </xsl:text>
      <xsl:value-of select="@linkend"/>
      <xsl:text>.</xsl:text>
    </xsl:message>
  </xsl:if>

  <xsl:apply-templates select="$target">
    <xsl:with-param name="recap" select="true()"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="lhs">
  <xsl:apply-templates/>
</xsl:template><xsl:template match="rhs">
  <xsl:apply-templates/>
  <xsl:if test="following-sibling::rhs">
    <xsl:text> |</xsl:text>
    <br/>
  </xsl:if>
</xsl:template><xsl:template match="nonterminal">
  <xsl:variable name="linkend">
    <xsl:call-template name="xpointer.idref">
      <xsl:with-param name="xpointer" select="@def"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:call-template name="check.id.unique">
    <xsl:with-param name="linkend" select="$linkend"/>
  </xsl:call-template>

  <xsl:call-template name="check.idref.targets">
    <xsl:with-param name="linkend" select="$linkend"/>
    <xsl:with-param name="element-list">production</xsl:with-param>
  </xsl:call-template>

  <!-- If you don't provide content, you can't point outside this doc. -->
  <xsl:choose>
    <xsl:when test="*|text()"><!--nop--></xsl:when>
    <xsl:otherwise>
      <xsl:if test="$linkend = ''">
        <xsl:message>
          <xsl:text>Non-terminals with no content must point to </xsl:text>
          <xsl:text>production elements in the current document.</xsl:text>
        </xsl:message>
        <xsl:message>
          <xsl:text>Invalid xpointer for empty nt: </xsl:text>
          <xsl:value-of select="@def"/>
        </xsl:message>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>

  <xsl:variable name="href">
    <xsl:choose>
      <xsl:when test="$linkend != ''">
        <xsl:variable name="targets" select="key('id',$linkend)"/>
        <xsl:variable name="target" select="$targets[1]"/>
        <xsl:call-template name="href.target">
          <xsl:with-param name="object" select="$target"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="@def"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <a href="{$href}">
    <xsl:choose>
      <xsl:when test="*|text()">
        <xsl:apply-templates/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$linkend != ''">
            <xsl:variable name="targets" select="key('id',$linkend)"/>
            <xsl:variable name="target" select="$targets[1]"/>
            <xsl:apply-templates select="$target/lhs"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>???</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </a>
</xsl:template><xsl:template match="rhs/lineannotation">
  <!--nop-->
</xsl:template><xsl:template match="rhs/lineannotation" mode="rhslo">
  <xsl:text>/*Â </xsl:text>
  <xsl:apply-templates/>
  <xsl:text>Â */</xsl:text>
  <br/>
</xsl:template><xsl:template match="constraint">
  <xsl:call-template name="check.id.unique">
    <xsl:with-param name="linkend" select="@linkend"/>
  </xsl:call-template>

  <xsl:call-template name="check.idref.targets">
    <xsl:with-param name="linkend" select="@linkend"/>
    <xsl:with-param name="element-list">constraintdef</xsl:with-param>
  </xsl:call-template>

  <xsl:variable name="href">
    <xsl:variable name="targets" select="key('id',@linkend)"/>
    <xsl:variable name="target" select="$targets[1]"/>
    <xsl:call-template name="href.target">
      <xsl:with-param name="object" select="$target"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:text>[Â </xsl:text>

  <xsl:choose>
    <xsl:when test="@role">
      <xsl:value-of select="@role"/>
      <xsl:text>: </xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="targets" select="key('id',@linkend)"/>
      <xsl:variable name="target" select="$targets[1]"/>
      <xsl:if test="$target/@role">
        <xsl:value-of select="$target/@role"/>
        <xsl:text>: </xsl:text>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>

  <a href="{$href}">
    <xsl:variable name="targets" select="key('id',@linkend)"/>
    <xsl:variable name="target" select="$targets[1]"/>
    <xsl:apply-templates select="$target" mode="title.markup"/>
  </a>
  <xsl:text>Â ]</xsl:text>
  <xsl:if test="following-sibling::constraint">
    <br/>
  </xsl:if>
</xsl:template><xsl:template match="constraintdef">
  <div>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:call-template name="id.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:apply-templates/>
  </div>
</xsl:template><xsl:template match="constraintdef/title">
  <p><strong xmlns:xslo="http://www.w3.org/1999/XSL/Transform"><xsl:apply-templates/></strong></p>
</xsl:template>
<xsl:param name="chunker.output.method" select="'xml'"/>
<xsl:param name="chunker.output.encoding" select="'UTF-8'"/>
<xsl:param name="chunker.output.indent" select="'no'"/>
<xsl:param name="chunker.output.omit-xml-declaration" select="'no'"/>
<xsl:param name="chunker.output.standalone" select="'no'"/>
<xsl:param name="chunker.output.doctype-public" select="'-//W3C//DTD XHTML 1.0 Strict//EN'"/>
<xsl:param name="chunker.output.doctype-system" select="'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'"/>
<xsl:param name="chunker.output.media-type" select="''"/>
<xsl:param name="chunker.output.cdata-section-elements" select="''"/>
<xsl:param name="chunk.base.dir">
  <xsl:choose>
    <xsl:when test="string-length($base.dir) = 0"/>
    <!-- make sure to add trailing slash if omitted by user -->
    <xsl:when test="substring($base.dir, string-length($base.dir), 1) = '/'">
      <xsl:value-of select="$base.dir"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="concat($base.dir, '/')"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:param><xsl:param name="saxon.character.representation" select="'entity;decimal'"/><xsl:template name="make-relative-filename">
  <xsl:param name="base.dir" select="'./'"/>
  <xsl:param name="base.name" select="''"/>

  <xsl:choose>
    <!-- put Saxon first to work around a bug in libxslt -->
    <xsl:when test="element-available('saxon:output')">
      <!-- Saxon doesn't make the chunks relative -->
      <xsl:value-of select="concat($base.dir,$base.name)"/>
    </xsl:when>
    <xsl:when test="element-available('exsl:document')">
      <!-- EXSL document does make the chunks relative, I think -->
      <xsl:choose>
        <xsl:when test="count(parent::*) = 0">
          <xsl:value-of select="concat($base.dir,$base.name)"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$base.name"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:when test="element-available('redirect:write')">
      <!-- Xalan doesn't make the chunks relative -->
      <xsl:value-of select="concat($base.dir,$base.name)"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:message terminate="yes">
        <xsl:text>Don't know how to chunk with </xsl:text>
        <xsl:value-of select="system-property('xsl:vendor')"/>
      </xsl:message>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="write.chunk">
  <xsl:param name="filename" select="''"/>
  <xsl:param name="quiet" select="$chunk.quietly"/>
  <xsl:param name="suppress-context-node-name" select="0"/>
  <xsl:param name="message-prolog"/>
  <xsl:param name="message-epilog"/>

  <xsl:param name="method" select="$chunker.output.method"/>
  <xsl:param name="encoding" select="$chunker.output.encoding"/>
  <xsl:param name="indent" select="$chunker.output.indent"/>
  <xsl:param name="omit-xml-declaration" select="$chunker.output.omit-xml-declaration"/>
  <xsl:param name="standalone" select="$chunker.output.standalone"/>
  <xsl:param name="doctype-public" select="$chunker.output.doctype-public"/>
  <xsl:param name="doctype-system" select="$chunker.output.doctype-system"/>
  <xsl:param name="media-type" select="$chunker.output.media-type"/>
  <xsl:param name="cdata-section-elements" select="$chunker.output.cdata-section-elements"/>

  <xsl:param name="content"/>

  <xsl:if test="$quiet = 0">
    <xsl:message>
      <xsl:if test="not($message-prolog = '')">
        <xsl:value-of select="$message-prolog"/>
      </xsl:if>
      <xsl:text>Writing </xsl:text>
      <xsl:value-of select="$filename"/>
      <xsl:if test="name(.) != '' and $suppress-context-node-name = 0">
        <xsl:text> for </xsl:text>
        <xsl:value-of select="name(.)"/>
        <xsl:if test="@id or @xml:id">
          <xsl:text>(</xsl:text>
          <xsl:value-of select="(@id|@xml:id)[1]"/>
          <xsl:text>)</xsl:text>
        </xsl:if>
      </xsl:if>
      <xsl:if test="not($message-epilog = '')">
        <xsl:value-of select="$message-epilog"/>
      </xsl:if>
    </xsl:message>
  </xsl:if>

  <xsl:choose>
    <xsl:when test="element-available('exsl:document')">
      <xsl:choose>
        <!-- Handle the permutations ... -->
        <xsl:when test="$media-type != ''">
          <xsl:choose>
            <xsl:when test="$doctype-public != '' and $doctype-system != ''">
              <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" media-type="{$media-type}" doctype-public="{$doctype-public}" doctype-system="{$doctype-system}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:when>
            <xsl:when test="$doctype-public != '' and $doctype-system = ''">
              <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" media-type="{$media-type}" doctype-public="{$doctype-public}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:when>
            <xsl:when test="$doctype-public = '' and $doctype-system != ''">
              <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" media-type="{$media-type}" doctype-system="{$doctype-system}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:when>
            <xsl:otherwise><!-- $doctype-public = '' and $doctype-system = ''"> -->
              <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" media-type="{$media-type}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:choose>
            <xsl:when test="$doctype-public != '' and $doctype-system != ''">
              <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" doctype-public="{$doctype-public}" doctype-system="{$doctype-system}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:when>
            <xsl:when test="$doctype-public != '' and $doctype-system = ''">
              <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" doctype-public="{$doctype-public}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:when>
            <xsl:when test="$doctype-public = '' and $doctype-system != ''">
              <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" doctype-system="{$doctype-system}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:when>
            <xsl:otherwise><!-- $doctype-public = '' and $doctype-system = ''"> -->
              <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </exsl:document>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>

    <xsl:when test="element-available('saxon:output')">
      <xsl:choose>
        <!-- Handle the permutations ... -->
        <xsl:when test="$media-type != ''">
          <xsl:choose>
            <xsl:when test="$doctype-public != '' and $doctype-system != ''">
              <saxon:output xmlns:saxon="http://icl.com/saxon" saxon:character-representation="{$saxon.character.representation}" href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" media-type="{$media-type}" doctype-public="{$doctype-public}" doctype-system="{$doctype-system}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:when>
            <xsl:when test="$doctype-public != '' and $doctype-system = ''">
              <saxon:output xmlns:saxon="http://icl.com/saxon" saxon:character-representation="{$saxon.character.representation}" href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" media-type="{$media-type}" doctype-public="{$doctype-public}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:when>
            <xsl:when test="$doctype-public = '' and $doctype-system != ''">
              <saxon:output xmlns:saxon="http://icl.com/saxon" saxon:character-representation="{$saxon.character.representation}" href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" media-type="{$media-type}" doctype-system="{$doctype-system}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:when>
            <xsl:otherwise><!-- $doctype-public = '' and $doctype-system = ''"> -->
              <saxon:output xmlns:saxon="http://icl.com/saxon" saxon:character-representation="{$saxon.character.representation}" href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" media-type="{$media-type}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:choose>
            <xsl:when test="$doctype-public != '' and $doctype-system != ''">
              <saxon:output xmlns:saxon="http://icl.com/saxon" saxon:character-representation="{$saxon.character.representation}" href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" doctype-public="{$doctype-public}" doctype-system="{$doctype-system}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:when>
            <xsl:when test="$doctype-public != '' and $doctype-system = ''">
              <saxon:output xmlns:saxon="http://icl.com/saxon" saxon:character-representation="{$saxon.character.representation}" href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" doctype-public="{$doctype-public}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:when>
            <xsl:when test="$doctype-public = '' and $doctype-system != ''">
              <saxon:output xmlns:saxon="http://icl.com/saxon" saxon:character-representation="{$saxon.character.representation}" href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" doctype-system="{$doctype-system}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:when>
            <xsl:otherwise><!-- $doctype-public = '' and $doctype-system = ''"> -->
              <saxon:output xmlns:saxon="http://icl.com/saxon" saxon:character-representation="{$saxon.character.representation}" href="{$filename}" method="{$method}" encoding="{$encoding}" indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}" cdata-section-elements="{$cdata-section-elements}" standalone="{$standalone}">
                <xsl:copy-of select="$content"/>
              </saxon:output>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>

    <xsl:when test="element-available('redirect:write')">
      <!-- Xalan uses redirect -->
      <redirect:write xmlns:redirect="http://xml.apache.org/xalan/redirect" file="{$filename}">
        <xsl:copy-of select="$content"/>
      </redirect:write>
    </xsl:when>

    <xsl:otherwise>
      <!-- it doesn't matter since we won't be making chunks... -->
      <xsl:message terminate="yes">
        <xsl:text>Can't make chunks with </xsl:text>
        <xsl:value-of select="system-property('xsl:vendor')"/>
        <xsl:text>'s processor.</xsl:text>
      </xsl:message>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="write.chunk.with.doctype">
  <xsl:param name="filename" select="''"/>
  <xsl:param name="quiet" select="$chunk.quietly"/>

  <xsl:param name="method" select="$chunker.output.method"/>
  <xsl:param name="encoding" select="$chunker.output.encoding"/>
  <xsl:param name="indent" select="$chunker.output.indent"/>
  <xsl:param name="omit-xml-declaration" select="$chunker.output.omit-xml-declaration"/>
  <xsl:param name="standalone" select="$chunker.output.standalone"/>
  <xsl:param name="doctype-public" select="$chunker.output.doctype-public"/>
  <xsl:param name="doctype-system" select="$chunker.output.doctype-system"/>
  <xsl:param name="media-type" select="$chunker.output.media-type"/>
  <xsl:param name="cdata-section-elements" select="$chunker.output.cdata-section-elements"/>

  <xsl:param name="content"/>

  <xsl:call-template name="write.chunk">
    <xsl:with-param name="filename" select="$filename"/>
    <xsl:with-param name="quiet" select="$quiet"/>
    <xsl:with-param name="method" select="$method"/>
    <xsl:with-param name="encoding" select="$encoding"/>
    <xsl:with-param name="indent" select="$indent"/>
    <xsl:with-param name="omit-xml-declaration" select="$omit-xml-declaration"/>
    <xsl:with-param name="standalone" select="$standalone"/>
    <xsl:with-param name="doctype-public" select="$doctype-public"/>
    <xsl:with-param name="doctype-system" select="$doctype-system"/>
    <xsl:with-param name="media-type" select="$media-type"/>
    <xsl:with-param name="cdata-section-elements" select="$cdata-section-elements"/>
    <xsl:with-param name="content" select="$content"/>
  </xsl:call-template>
</xsl:template><xsl:template name="write.text.chunk">
  <xsl:param name="filename" select="''"/>
  <xsl:param name="quiet" select="$chunk.quietly"/>
  <xsl:param name="suppress-context-node-name" select="0"/>
  <xsl:param name="message-prolog"/>
  <xsl:param name="message-epilog"/>
  <xsl:param name="method" select="'text'"/>
  <xsl:param name="encoding" select="$chunker.output.encoding"/>
  <xsl:param name="media-type" select="$chunker.output.media-type"/>
  <xsl:param name="content"/>

  <xsl:call-template name="write.chunk">
    <xsl:with-param name="filename" select="$filename"/>
    <xsl:with-param name="quiet" select="$quiet"/>
    <xsl:with-param name="suppress-context-node-name" select="$suppress-context-node-name"/>
    <xsl:with-param name="message-prolog" select="$message-prolog"/>
    <xsl:with-param name="message-epilog" select="$message-epilog"/>
    <xsl:with-param name="method" select="$method"/>
    <xsl:with-param name="encoding" select="$encoding"/>
    <xsl:with-param name="indent" select="'no'"/>
    <xsl:with-param name="omit-xml-declaration" select="'yes'"/>
    <xsl:with-param name="standalone" select="'no'"/>
    <xsl:with-param name="doctype-public"/>
    <xsl:with-param name="doctype-system"/>
    <xsl:with-param name="media-type" select="$media-type"/>
    <xsl:with-param name="cdata-section-elements"/>
    <xsl:with-param name="content" select="$content"/>
  </xsl:call-template>
</xsl:template>
<xsl:template match="/" mode="insert.html.p">
  <xsl:param name="mark" select="'?'"/>
  <xsl:apply-templates mode="insert.html.p">
    <xsl:with-param name="mark" select="$mark"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="*" mode="insert.html.p">
  <xsl:param name="mark" select="'?'"/>
  <xsl:copy>
    <xsl:copy-of select="@*"/>
    <xsl:apply-templates mode="insert.html.p">
      <xsl:with-param name="mark" select="$mark"/>
    </xsl:apply-templates>
  </xsl:copy>
</xsl:template><xsl:template xmlns:html="http://www.w3.org/1999/xhtml" match="html:p|p" mode="insert.html.p">
  <xsl:param name="mark" select="'?'"/>
  <xsl:copy>
    <xsl:copy-of select="@*"/>
    <xsl:if test="not(preceding::p|preceding::html:p)">
      <xsl:copy-of select="$mark"/>
    </xsl:if>
    <xsl:apply-templates mode="insert.html.p">
      <xsl:with-param name="mark" select="$mark"/>
    </xsl:apply-templates>
  </xsl:copy>
</xsl:template><xsl:template match="text()|processing-instruction()|comment()" mode="insert.html.p">
  <xsl:param name="mark" select="'?'"/>
  <xsl:copy/>
</xsl:template><xsl:template match="/" mode="insert.html.text">
  <xsl:param name="mark" select="'?'"/>
  <xsl:apply-templates mode="insert.html.text">
    <xsl:with-param name="mark" select="$mark"/>
  </xsl:apply-templates>
</xsl:template><xsl:template match="*" mode="insert.html.text">
  <xsl:param name="mark" select="'?'"/>
  <xsl:copy>
    <xsl:copy-of select="@*"/>
    <xsl:apply-templates mode="insert.html.text">
      <xsl:with-param name="mark" select="$mark"/>
    </xsl:apply-templates>
  </xsl:copy>
</xsl:template><xsl:template match="text()|processing-instruction()|comment()" mode="insert.html.text">
  <xsl:param name="mark" select="'?'"/>

  <xsl:if test="not(preceding::text())">
    <xsl:copy-of select="$mark"/>
  </xsl:if>

  <xsl:copy/>
</xsl:template><xsl:template match="processing-instruction()|comment()" mode="insert.html.text">
  <xsl:param name="mark" select="'?'"/>
  <xsl:copy/>
</xsl:template><xsl:template name="unwrap.p">
  <xsl:param name="p"/>
  <xsl:choose>
    <xsl:when test="$exsl.node.set.available != 0                     and function-available('set:leading')                     and function-available('set:trailing')">
      <xsl:apply-templates select="exsl:node-set($p)" mode="unwrap.p"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="$p"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template xmlns:html="http://www.w3.org/1999/xhtml" match="html:p|p" mode="unwrap.p">
  <!-- xmlns:html is necessary for the xhtml stylesheet case -->
  <xsl:variable name="blocks" select="address|blockquote|div|hr|h1|h2|h3|h4|h5|h6                         |layer|p|pre|table|dl|menu|ol|ul|form                         |html:address|html:blockquote|html:div|html:hr                         |html:h1|html:h2|html:h3|html:h4|html:h5|html:h6                         |html:layer|html:p|html:pre|html:table|html:dl                         |html:menu|html:ol|html:ul|html:form"/>
  <xsl:choose>
    <xsl:when test="$blocks">
      <xsl:call-template name="unwrap.p.nodes">
        <xsl:with-param name="wrap" select="."/>
        <xsl:with-param name="first" select="1"/>
        <xsl:with-param name="nodes" select="node()"/>
        <xsl:with-param name="blocks" select="$blocks"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy>
        <xsl:copy-of select="@*"/>
        <xsl:apply-templates mode="unwrap.p"/>
      </xsl:copy>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="*" mode="unwrap.p">
  <xsl:copy>
    <xsl:copy-of select="@*"/>
    <xsl:apply-templates mode="unwrap.p"/>
  </xsl:copy>
</xsl:template><xsl:template match="text()|processing-instruction()|comment()" mode="unwrap.p">
  <xsl:copy/>
</xsl:template><xsl:template name="unwrap.p.nodes">
  <xsl:param name="wrap" select="."/>
  <xsl:param name="first" select="0"/>
  <xsl:param name="nodes"/>
  <xsl:param name="blocks"/>
  <xsl:variable name="block" select="$blocks[1]"/>

  <!-- This template should never get called if these functions aren't available -->
  <!-- but this test is still necessary so that processors don't choke on the -->
  <!-- function calls if they don't support the set: functions -->
  <xsl:if test="function-available('set:leading')                 and function-available('set:trailing')">
    <xsl:choose>
      <xsl:when test="$blocks">
        <xsl:variable name="leading" select="set:leading($nodes,$block)"/>
        <xsl:variable name="trailing" select="set:trailing($nodes,$block)"/>

        <xsl:if test="(($wrap/@id or $wrap/@xml:id)                          and $first = 1) or $leading">
          <xsl:element name="{local-name($wrap)}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:for-each select="$wrap/@*">
              <xsl:if test="$first != 0 or local-name(.) != 'id'">
                <xsl:copy/>
              </xsl:if>
            </xsl:for-each>
            <xsl:apply-templates select="$leading" mode="unwrap.p"/>
          </xsl:element>
        </xsl:if>

        <xsl:apply-templates select="$block" mode="unwrap.p"/>

        <xsl:if test="$trailing">
          <xsl:call-template name="unwrap.p.nodes">
            <xsl:with-param name="wrap" select="$wrap"/>
            <xsl:with-param name="nodes" select="$trailing"/>
            <xsl:with-param name="blocks" select="$blocks[position() &gt; 1]"/>
          </xsl:call-template>
        </xsl:if>
      </xsl:when>

      <xsl:otherwise>
        <xsl:if test="(($wrap/@id or $wrap/@xml:id) and $first = 1) or $nodes">
          <xsl:element name="{local-name($wrap)}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:for-each select="$wrap/@*">
              <xsl:if test="$first != 0 or local-name(.) != 'id'">
                <xsl:copy/>
              </xsl:if>
            </xsl:for-each>
            <xsl:apply-templates select="$nodes" mode="unwrap.p"/>
          </xsl:element>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>
</xsl:template><xsl:template match="/" mode="make.verbatim.mode">
  <xsl:apply-templates mode="make.verbatim.mode"/>
</xsl:template><xsl:template match="*" mode="make.verbatim.mode">
  <xsl:copy>
    <xsl:copy-of select="@*"/>
    <xsl:apply-templates mode="make.verbatim.mode"/>
  </xsl:copy>
</xsl:template><xsl:template match="processing-instruction()|comment()" mode="make.verbatim.mode">
  <xsl:copy/>
</xsl:template><xsl:template match="text()" mode="make.verbatim.mode">
  <xsl:variable name="text" select="translate(., ' ', '&#xA0;')"/>

  <xsl:choose>
    <xsl:when test="not(contains($text, '&#10;'))">
      <xsl:value-of select="$text"/>
    </xsl:when>

    <xsl:otherwise>
      <xsl:variable name="len" select="string-length($text)"/>

      <xsl:choose>
        <xsl:when test="$len = 1">
          <br/><xsl:text>
</xsl:text>
        </xsl:when>

        <xsl:otherwise>
          <xsl:variable name="half" select="$len div 2"/>
          <xsl:call-template name="make-verbatim-recursive">
            <xsl:with-param name="text" select="substring($text, 1, $half)"/>
          </xsl:call-template>
          <xsl:call-template name="make-verbatim-recursive">
            <xsl:with-param name="text" select="substring($text, ($half + 1), $len)"/>
          </xsl:call-template>
    	</xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="make-verbatim-recursive">
  <xsl:param name="text" select="''"/>

  <xsl:choose>
    <xsl:when test="not(contains($text, '&#10;'))">
      <xsl:value-of select="$text"/>
    </xsl:when>

    <xsl:otherwise>
      <xsl:variable name="len" select="string-length($text)"/>

      <xsl:choose>
        <xsl:when test="$len = 1">
          <br/><xsl:text>
</xsl:text>
        </xsl:when>

        <xsl:otherwise>
    	  <xsl:variable name="half" select="$len div 2"/>
          <xsl:call-template name="make-verbatim-recursive">
    	    <xsl:with-param name="text" select="substring($text, 1, $half)"/>
    	  </xsl:call-template>
    	  <xsl:call-template name="make-verbatim-recursive">
    	    <xsl:with-param name="text" select="substring($text, ($half + 1), $len)"/>
    	  </xsl:call-template>
    	</xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="remove.empty.div">
  <xsl:param name="div"/>
  <xsl:choose>
    <xsl:when test="$exsl.node.set.available != 0">
      <xsl:apply-templates select="exsl:node-set($div)" mode="remove.empty.div"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="$div"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template xmlns:html="http://www.w3.org/1999/xhtml" match="html:p|p|html:div|div" mode="remove.empty.div">
  <xsl:if test="node()">
    <xsl:copy>
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates mode="remove.empty.div"/>
    </xsl:copy>
  </xsl:if>
</xsl:template><xsl:template match="*" mode="remove.empty.div">
  <xsl:copy>
    <xsl:copy-of select="@*"/>
    <xsl:apply-templates mode="remove.empty.div"/>
  </xsl:copy>
</xsl:template><xsl:template match="text()|processing-instruction()|comment()" mode="remove.empty.div">
  <xsl:copy/>
</xsl:template>
<xsl:template name="add.annotation.links">
  <xsl:param name="scripts" select="normalize-space($annotation.js)"/>
  <xsl:choose>
    <xsl:when test="contains($scripts, ' ')">
      <script type="text/javascript" src="{substring-before($scripts, ' ')}"/>
      <xsl:call-template name="add.annotation.links">
        <xsl:with-param name="scripts" select="substring-after($scripts, ' ')"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <script type="text/javascript" src="{$scripts}"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="annotation"/><xsl:template name="apply-annotations">
  <xsl:if test="$annotation.support != 0">
  <!-- do any annotations apply to the context node? -->
  <xsl:variable name="id" select="(@id|@xml:id)[1]"/>

  <xsl:variable name="aids">
    <xsl:for-each select="//annotation">
      <xsl:if test="@annotates=$id                     or starts-with(@annotates, concat($id, ' '))                     or contains(@annotates, concat(' ', $id, ' '))                     or substring(@annotates, string-length(@annotates)-3)                        = concat(' ', $id)">
        <xsl:value-of select="generate-id()"/>
        <xsl:text> </xsl:text>
      </xsl:if>
    </xsl:for-each>
    <xsl:if test="normalize-space(@annotations) != ''">
      <xsl:call-template name="annotations-pointed-to">
        <xsl:with-param name="annotations" select="normalize-space(@annotations)"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:variable>

  <xsl:if test="$aids != ''">
    <xsl:call-template name="apply-annotations-by-gid">
      <xsl:with-param name="gids" select="normalize-space($aids)"/>
    </xsl:call-template>
  </xsl:if>
  </xsl:if>
</xsl:template><xsl:template name="annotations-pointed-to">
  <xsl:param name="annotations"/>
  <xsl:choose>
    <xsl:when test="contains($annotations, ' ')">
      <xsl:variable name="a" select="key('id', substring-before($annotations, ' '))"/>
      <xsl:if test="$a">
        <xsl:value-of select="generate-id($a)"/>
        <xsl:text> </xsl:text>
      </xsl:if>
      <xsl:call-template name="annotations-pointed-to">
        <xsl:with-param name="annotations" select="substring-after($annotations, ' ')"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="a" select="key('id', $annotations)"/>
      <xsl:if test="$a">
        <xsl:value-of select="generate-id($a)"/>
        <xsl:text> </xsl:text>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template name="apply-annotations-by-gid">
  <xsl:param name="gids"/>

  <xsl:choose>
    <xsl:when test="contains($gids, ' ')">
      <xsl:variable name="gid" select="substring-before($gids, ' ')"/>
      <xsl:apply-templates select="key('gid', $gid)" mode="annotation-inline"/>
      <xsl:call-template name="apply-annotations-by-gid">
        <xsl:with-param name="gids" select="substring-after($gids, ' ')"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="key('gid', $gids)" mode="annotation-inline"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="annotation" mode="annotation-inline">
  <xsl:variable name="title">
    <xsl:choose>
      <xsl:when test="title">
        <xsl:value-of select="title"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>[Annotation #</xsl:text>
        <xsl:number count="annotation" level="any" format="1"/>
        <xsl:text>]</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <a id="anch-{generate-id(.)}" href="#annot-{generate-id(.)}" title="{$title}">
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:attribute name="onClick">
      <xsl:text>popup_</xsl:text>
      <xsl:value-of select="generate-id(.)"/>
      <xsl:text>.showPopup('anch-</xsl:text>
      <xsl:value-of select="generate-id(.)"/>
      <xsl:text>'); return false;</xsl:text>
    </xsl:attribute>
    <img src="{$annotation.graphic.open}" border="0" alt="{$title}"/>
  </a>
</xsl:template><xsl:template match="annotation" mode="annotation-popup">
  <div class="annotation-nocss">
    <p>
      <a id="annot-{generate-id(.)}"/>
      <xsl:text>Annotation #</xsl:text>
      <xsl:number count="annotation" level="any" format="1"/>
      <xsl:text>:</xsl:text>
    </p>
  </div>

  <div id="popup-{generate-id(.)}" class="annotation-popup">
    <xsl:if test="string-length(.) &gt; 300">
      <xsl:attribute name="style">width:400px</xsl:attribute>
    </xsl:if>

    <xsl:call-template name="annotation-title"/>
    <div class="annotation-body">
      <xsl:apply-templates select="*[local-name(.) != 'title']"/>
    </div>
    <div class="annotation-close">
      <a href="#" onclick="popup_{generate-id(.)}.hidePopup();return false;">
        <xsl:apply-templates select="." mode="class.attribute"/>
        <img src="{$annotation.graphic.close}" alt="X" border="0"/>
      </a>
    </div>
  </div>
</xsl:template><xsl:template name="annotation-title">
  <div class="annotation-title">
    <xsl:choose>
      <xsl:when test="title">
        <xsl:apply-templates select="title/node()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>Annotation</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </div>
</xsl:template>
<xsl:template match="/*" mode="stripNS">
  <xsl:choose>
    <xsl:when test="self::ng:* or self::db:*">
      <xsl:element name="{local-name(.)}">
        <xsl:copy-of select="@*[not(name(.) = 'xml:id')                                 and not(name(.) = 'version')]"/>
        <xsl:if test="@xml:id">
          <xsl:attribute name="id">
            <xsl:value-of select="@xml:id"/>
          </xsl:attribute>
        </xsl:if>

        <xsl:call-template name="add-xml-base"/>

        <xsl:apply-templates mode="stripNS"/>
      </xsl:element>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy>
        <xsl:copy-of select="@*[not(name(.) = 'xml:id')                                 and not(name(.) = 'version')]"/>
        <xsl:if test="@xml:id">
          <xsl:attribute name="id">
            <xsl:value-of select="@xml:id"/>
          </xsl:attribute>
        </xsl:if>

        <xsl:call-template name="add-xml-base"/>

        <xsl:apply-templates mode="stripNS"/>
      </xsl:copy>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="*" mode="stripNS">
  <xsl:choose>
    <xsl:when test="self::ng:* or self::db:*">
      <xsl:element name="{local-name(.)}">
        <xsl:copy-of select="@*[not(name(.) = 'xml:id')                                 and not(name(.) = 'version')]"/>
        <xsl:if test="@xml:id">
          <xsl:attribute name="id">
            <xsl:value-of select="@xml:id"/>
          </xsl:attribute>
        </xsl:if>
        <xsl:apply-templates mode="stripNS"/>
      </xsl:element>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy>
        <xsl:copy-of select="@*[not(name(.) = 'xml:id')                                 and not(name(.) = 'version')]"/>
        <xsl:if test="@xml:id">
          <xsl:attribute name="id">
            <xsl:value-of select="@xml:id"/>
          </xsl:attribute>
        </xsl:if>
        <xsl:apply-templates mode="stripNS"/>
      </xsl:copy>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="db:info" mode="stripNS">
  <xsl:variable name="info">
    <xsl:choose>
      <xsl:when test="parent::db:article                       |parent::db:appendix                       |parent::db:bibliography                       |parent::db:book                       |parent::db:chapter                       |parent::db:glossary                       |parent::db:index                       |parent::db:part                       |parent::db:preface                       |parent::db:refentry                       |parent::db:reference                       |parent::db:refsect1                       |parent::db:refsect2                       |parent::db:refsect3                       |parent::db:refsection                       |parent::db:refsynopsisdiv                       |parent::db:sect1                       |parent::db:sect2                       |parent::db:sect3                       |parent::db:sect4                       |parent::db:sect5                       |parent::db:section                       |parent::db:setindex                       |parent::db:set                       |parent::db:slides                       |parent::db:sidebar">
        <xsl:value-of select="local-name(parent::*)"/>
        <xsl:text>info</xsl:text>
      </xsl:when>
      <xsl:when test="parent::db:audioobject                       |parent::db:imageobject                       |parent::db:inlinemediaobject                       |parent::db:mediaobject                       |parent::db:mediaobjectco                       |parent::db:textobject                       |parent::db:videoobject">
        <xsl:text>objectinfo</xsl:text>
      </xsl:when>
      <xsl:otherwise>blockinfo</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:element name="{$info}">
    <xsl:copy-of select="@*[not(name(.) = 'xml:id')                          and not(name(.) = 'version')]"/>
    <xsl:if test="@xml:id">
      <xsl:attribute name="id">
        <xsl:value-of select="@xml:id"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:apply-templates mode="stripNS"/>
  </xsl:element>

  <xsl:if test="(not(../db:title) and not(../ng:title))                 and ($info = 'prefaceinfo'                      or $info = 'chapterinfo'                      or $info = 'sectioninfo'                      or $info = 'sect1info'                      or $info = 'sect2info'                      or $info = 'sect3info'                      or $info = 'sect4info'                      or $info = 'sect5info'                      or $info = 'refsectioninfo'                      or $info = 'refsect1info'                      or $info = 'refsect2info'                      or $info = 'refsect3info'                      or $info = 'blockinfo'                      or $info = 'appendixinfo')">
    <xsl:apply-templates select="db:title|ng:title" mode="stripNS"/>
  </xsl:if>

</xsl:template><xsl:template match="ng:tag|db:tag" mode="stripNS">
  <xsl:choose>
    <xsl:when test="@xlink:href">
      <ulink xmlns="" url="{@xlink:href}">
	<sgmltag>
	  <xsl:copy-of select="@*[not(name(.) = 'xml:id')           and not(name(.) = 'version')           and not(local-name(.) = 'href')]"/>
          <xsl:if test="@xml:id">
            <xsl:attribute name="id">
              <xsl:value-of select="@xml:id"/>
            </xsl:attribute>
          </xsl:if>
	  <xsl:apply-templates mode="stripNS"/>
	</sgmltag>
      </ulink>
    </xsl:when>
    <xsl:otherwise>
      <sgmltag xmlns="">
	<xsl:copy-of select="@*[not(name(.) = 'xml:id')                                 and not(name(.) = 'version')]"/>
          <xsl:if test="@xml:id">
            <xsl:attribute name="id">
              <xsl:value-of select="@xml:id"/>
            </xsl:attribute>
          </xsl:if>
	<xsl:apply-templates mode="stripNS"/>
      </sgmltag>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="db:link[@xlink:href]" mode="stripNS">
  <ulink xmlns="" url="{@xlink:href}">
    <xsl:if test="@role">
      <xsl:attribute name="role">
        <xsl:value-of select="@role"/>
      </xsl:attribute>
    </xsl:if>
    <xsl:apply-templates mode="stripNS"/>
  </ulink>
</xsl:template><xsl:template match="db:citetitle[@xlink:href]" mode="stripNS">
  <ulink xmlns="" url="{@xlink:href}">
    <citetitle>
      <xsl:copy-of select="@*[not(name(.) = 'xml:id')       and not(name(.) = 'version')       and not(local-name(.) = 'href')]"/>
      <xsl:if test="@xml:id">
        <xsl:attribute name="id">
          <xsl:value-of select="@xml:id"/>
        </xsl:attribute>
      </xsl:if>
      <xsl:apply-templates mode="stripNS"/>
    </citetitle>
  </ulink>
</xsl:template><xsl:template match="db:citetitle[@linkend]" mode="stripNS">
  <citetitle xmlns="">
    <xsl:copy-of select="@*[not(name(.) = 'xml:id')     and not(name(.) = 'version')     and not(name(.) = 'linkend')     and not(local-name(.) = 'href')]"/>
    <xsl:if test="@xml:id">
      <xsl:attribute name="id">
        <xsl:value-of select="@xml:id"/>
      </xsl:attribute>
    </xsl:if>
      <xsl:apply-templates mode="stripNS"/>
  </citetitle>
</xsl:template><xsl:template match="db:alt" mode="stripNS"/><xsl:template match="ng:textdata|db:textdata                      |ng:imagedata|db:imagedata                      |ng:videodata|db:videodata                      |ng:audiodata|db:audiodata" mode="stripNS">
  <xsl:element name="{local-name(.)}">
    <xsl:copy-of select="@*[not(name(.) = 'xml:id')                             and not(name(.) = 'version')                             and not(name(.) = 'entityref')]"/>
    <xsl:if test="@xml:id">
      <xsl:attribute name="id">
        <xsl:value-of select="@xml:id"/>
      </xsl:attribute>
    </xsl:if>

    <xsl:choose>
      <xsl:when test="@entityref">
        <xsl:attribute name="fileref">
          <xsl:value-of select="unparsed-entity-uri(@entityref)"/>
        </xsl:attribute>
      </xsl:when>
    </xsl:choose>

    <xsl:apply-templates mode="stripNS"/>
  </xsl:element>
</xsl:template><xsl:template name="add-xml-base">
  <xsl:if test="not(@xml:base)">
    <xsl:variable name="base">
      <xsl:choose>
        <xsl:when test="function-available('saxon:systemId')">
          <xsl:value-of select="saxon:systemId()"/>
        </xsl:when>
        <xsl:when test="function-available('NodeInfo:systemId')">
          <xsl:value-of select="NodeInfo:systemId()"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message>
            <xsl:text>WARNING: cannot add @xml:base to node </xsl:text>
            <xsl:text>set root element.  </xsl:text>
            <xsl:text>Relative paths may not work.</xsl:text>
          </xsl:message>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <!-- debug
    <xsl:message>base is <xsl:value-of select="$base"/></xsl:message>
    -->
    <xsl:if test="$base != ''">
      <xsl:attribute name="xml:base">
        <xsl:call-template name="systemIdToBaseURI">
          <xsl:with-param name="systemId">
            <!-- file: seems to confuse some processors. -->
            <xsl:choose>
              <!-- however, windows paths must use file:///c:/path -->
              <xsl:when test="starts-with($base, 'file:///') and                               substring($base, 10, 1) = ':'">
                <xsl:value-of select="$base"/>
              </xsl:when>
              <xsl:when test="starts-with($base, 'file:/')                               and substring($base, 8, 1) = ':'">
                <xsl:value-of select="concat('file:///',                                        substring-after($base,'file:/'))"/>
              </xsl:when>
              <xsl:when test="starts-with($base, 'file:///')">
                <xsl:value-of select="substring-after($base,'file://')"/>
              </xsl:when>
              <xsl:when test="starts-with($base, 'file://')">
                <xsl:value-of select="substring-after($base,'file:/')"/>
              </xsl:when>
              <xsl:when test="starts-with($base, 'file:/')">
                <xsl:value-of select="substring-after($base,'file:')"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="$base"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
        </xsl:call-template>
      </xsl:attribute>
    </xsl:if>
  </xsl:if>
</xsl:template><xsl:template name="systemIdToBaseURI">
  <xsl:param name="systemId" select="''"/>
  <xsl:if test="contains($systemId,'/')">
    <xsl:value-of select="substring-before($systemId,'/')"/>
    <xsl:text>/</xsl:text>
    <xsl:call-template name="systemIdToBaseURI">
      <xsl:with-param name="systemId" select="substring-after($systemId,'/')"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template><xsl:template match="comment()|processing-instruction()|text()" mode="stripNS">
  <xsl:copy/>
</xsl:template><xsl:template match="/" priority="-1">
  <!-- need a local version of this variable because this module imported many places-->
  <xsl:variable name="local.exsl.node.set.available">
    <xsl:choose>
      <xsl:when exsl:foo="" test="function-available('exsl:node-set') or                          contains(system-property('xsl:vendor'),                            'Apache Software Foundation')">1</xsl:when>
      <xsl:otherwise>0</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:choose>
    <xsl:when test="$local.exsl.node.set.available != 0                     and (*/self::ng:* or */self::db:*)">
      <xsl:message>
        <xsl:text>Stripping namespace from DocBook 5 document. </xsl:text>
        <xsl:text>It is suggested to use namespaced version of the stylesheets </xsl:text>
        <xsl:text>available in distribution file 'docbook-xsl-ns' </xsl:text>
        <xsl:text>at //http://sourceforge.net/projects/docbook/files/</xsl:text>
        <xsl:text> which does not require namespace stripping step.</xsl:text>
      </xsl:message>
      <xsl:variable name="nons">
        <xsl:apply-templates mode="stripNS"/>
      </xsl:variable>
      <xsl:message>Processing stripped document.</xsl:message>
      <xsl:apply-templates select="exsl:node-set($nons)"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="node()"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:param name="stylesheet.result.type" select="'xhtml'"/>
<xsl:param name="htmlhelp.output" select="0"/>

<!-- ================================== -->

<xsl:key name="id" match="*" use="@id|@xml:id"/>
<xsl:key name="gid" match="*" use="generate-id()"/>

<!-- ================================== -->

<xsl:template match="*">
  <xsl:message>
    <xsl:text>Element </xsl:text>
    <xsl:value-of select="local-name(.)"/>
    <xsl:text> in namespace '</xsl:text>
    <xsl:value-of select="namespace-uri(.)"/>
    <xsl:text>' encountered</xsl:text>
    <xsl:if test="parent::*">
      <xsl:text> in </xsl:text>
      <xsl:value-of select="name(parent::*)"/>
    </xsl:if>
    <xsl:text>, but no template matches.</xsl:text>
  </xsl:message>

  <span style="color: red">
    <xsl:text>&lt;</xsl:text>
    <xsl:value-of select="name(.)"/>
    <xsl:text>&gt;</xsl:text>
    <xsl:apply-templates/>
    <xsl:text>&lt;/</xsl:text>
    <xsl:value-of select="name(.)"/>
    <xsl:text>&gt;</xsl:text>
  </span>
</xsl:template>

<xsl:template match="text()">
  <xsl:value-of select="."/>
</xsl:template>
<xsl:template name="head.content.base">
  <xsl:param name="node" select="."/>
  <base href="{$html.base}"/>
</xsl:template>

<xsl:template name="head.content.abstract">
  <xsl:param name="node" select="."/>
  <xsl:variable name="info" select="(articleinfo     |bookinfo     |prefaceinfo     |chapterinfo     |appendixinfo     |sectioninfo     |sect1info     |sect2info     |sect3info     |sect4info     |sect5info     |referenceinfo     |refentryinfo     |partinfo     |info     |docinfo)[1]"/>
  <xsl:if test="$info and $info/abstract">
    <meta name="description">
      <xsl:attribute name="content">
        <xsl:for-each select="$info/abstract[1]/*">
          <xsl:value-of select="normalize-space(.)"/>
          <xsl:if test="position() &lt; last()">
            <xsl:text> </xsl:text>
          </xsl:if>
        </xsl:for-each>
      </xsl:attribute>
    </meta>
  </xsl:if>
</xsl:template>

<xsl:template name="head.content.link.made">
  <xsl:param name="node" select="."/>
  
  <link rev="made" href="{$link.mailto.url}"/>
</xsl:template>

<xsl:template name="head.content.generator">
  <xsl:param name="node" select="."/>
  <meta name="generator" content="DocBook {$DistroTitle} V{$VERSION}"/>
</xsl:template>

<xsl:template name="head.content.style">
  <xsl:param name="node" select="."/>
  <style type="text/css"><xsl:text>
body { background-image: url('</xsl:text>
<xsl:value-of select="$draft.watermark.image"/><xsl:text>');
       background-repeat: no-repeat;
       background-position: top left;
       /* The following properties make the watermark "fixed" on the page. */
       /* I think that's just a bit too distracting for the reader... */
       /* background-attachment: fixed; */
       /* background-position: center center; */
     }</xsl:text>
    </style>
</xsl:template>
<xsl:template name="output.html.stylesheets">
  <xsl:param name="stylesheets" select="''"/>

  <xsl:choose>
    <xsl:when test="contains($stylesheets, ' ')">
      <xsl:variable name="css.filename" select="substring-before($stylesheets, ' ')"/>

      <xsl:call-template name="make.css.link">
        <xsl:with-param name="css.filename" select="$css.filename"/>
      </xsl:call-template>

      <xsl:call-template name="output.html.stylesheets">
        <xsl:with-param name="stylesheets" select="substring-after($stylesheets, ' ')"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$stylesheets != ''">
      <xsl:call-template name="make.css.link">
        <xsl:with-param name="css.filename" select="$stylesheets"/>
      </xsl:call-template>
    </xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template name="output.html.scripts">
  <xsl:param name="scripts" select="''"/>

  <xsl:choose>
    <xsl:when test="contains($scripts, ' ')">
      <xsl:variable name="script.filename" select="substring-before($scripts, ' ')"/>

      <xsl:call-template name="make.script.link">
        <xsl:with-param name="script.filename" select="$script.filename"/>
      </xsl:call-template>

      <xsl:call-template name="output.html.scripts">
        <xsl:with-param name="scripts" select="substring-after($scripts, ' ')"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:when test="$scripts != ''">
      <xsl:call-template name="make.script.link">
        <xsl:with-param name="script.filename" select="$scripts"/>
      </xsl:call-template>
    </xsl:when>
  </xsl:choose>
</xsl:template>

<!-- ============================== -->

<xsl:template match="*" mode="head.keywords.content">
  <xsl:apply-templates select="chapterinfo/keywordset" mode="html.header"/>
  <xsl:apply-templates select="appendixinfo/keywordset" mode="html.header"/>
  <xsl:apply-templates select="prefaceinfo/keywordset" mode="html.header"/>
  <xsl:apply-templates select="bookinfo/keywordset" mode="html.header"/>
  <xsl:apply-templates select="setinfo/keywordset" mode="html.header"/>
  <xsl:apply-templates select="articleinfo/keywordset" mode="html.header"/>
  <xsl:apply-templates select="artheader/keywordset" mode="html.header"/>
  <xsl:apply-templates select="sect1info/keywordset" mode="html.header"/>
  <xsl:apply-templates select="sect2info/keywordset" mode="html.header"/>
  <xsl:apply-templates select="sect3info/keywordset" mode="html.header"/>
  <xsl:apply-templates select="sect4info/keywordset" mode="html.header"/>
  <xsl:apply-templates select="sect5info/keywordset" mode="html.header"/>
  <xsl:apply-templates select="sectioninfo/keywordset" mode="html.header"/>
  <xsl:apply-templates select="refsect1info/keywordset" mode="html.header"/>
  <xsl:apply-templates select="refsect2info/keywordset" mode="html.header"/>
  <xsl:apply-templates select="refsect3info/keywordset" mode="html.header"/>
  <xsl:apply-templates select="bibliographyinfo/keywordset" mode="html.header"/>
  <xsl:apply-templates select="glossaryinfo/keywordset" mode="html.header"/>
  <xsl:apply-templates select="indexinfo/keywordset" mode="html.header"/>
  <xsl:apply-templates select="refentryinfo/keywordset" mode="html.header"/>
  <xsl:apply-templates select="partinfo/keywordset" mode="html.header"/>
  <xsl:apply-templates select="referenceinfo/keywordset" mode="html.header"/>
  <xsl:apply-templates select="docinfo/keywordset" mode="html.header"/>
  <xsl:apply-templates select="info/keywordset" mode="html.header"/>

  <xsl:if test="$inherit.keywords != 0                 and parent::*">
    <xsl:apply-templates select="parent::*" mode="head.keywords.content"/>
  </xsl:if>
</xsl:template>

<!-- ============================== -->

<xsl:template name="system.head.content">
  <xsl:param name="node" select="."/>

  <!-- FIXME: When chunking, only the annotations actually used
              in this chunk should be referenced. I don't think it
              does any harm to reference them all, but it adds
              unnecessary bloat to each chunk. -->
  <xsl:if test="$annotation.support != 0 and //annotation">
    <xsl:call-template name="add.annotation.links"/>
    <script type="text/javascript">
      <xsl:text>
// Create PopupWindow objects</xsl:text>
      <xsl:for-each select="//annotation">
        <xsl:text>
var popup_</xsl:text>
        <xsl:value-of select="generate-id(.)"/>
        <xsl:text> = new PopupWindow("popup-</xsl:text>
        <xsl:value-of select="generate-id(.)"/>
        <xsl:text>");
</xsl:text>
        <xsl:text>popup_</xsl:text>
        <xsl:value-of select="generate-id(.)"/>
        <xsl:text>.offsetY = 15;
</xsl:text>
        <xsl:text>popup_</xsl:text>
        <xsl:value-of select="generate-id(.)"/>
        <xsl:text>.autoHide();
</xsl:text>
      </xsl:for-each>
    </script>

    <style type="text/css">
      <xsl:value-of select="$annotation.css"/>
    </style>
  </xsl:if>

  <!-- system.head.content is like user.head.content, except that
       it is called before head.content. This is important because it
       means, for example, that <style> elements output by system.head.content
       have a lower CSS precedence than the users stylesheet. -->
</xsl:template>

<!-- ============================== -->

<xsl:template name="user.preroot">
  <!-- Pre-root output, can be used to output comments and PIs. -->
  <!-- This must not output any element content! -->
</xsl:template>

<xsl:template name="user.head.title">
  <xsl:param name="node" select="."/>
  <xsl:param name="title"/>

  <title>
    <xsl:copy-of select="$title"/>
  </title>
</xsl:template>

<xsl:template name="user.head.content">
  <xsl:param name="node" select="."/>
</xsl:template>

<xsl:template name="user.header.navigation">
  <xsl:param name="node" select="."/>
  <xsl:param name="prev" select="/foo"/>
  <xsl:param name="next" select="/foo"/>
  <xsl:param name="nav.context"/>
</xsl:template>

<xsl:template name="user.header.content">
  <xsl:param name="node" select="."/>
</xsl:template>

<xsl:template name="user.footer.navigation">
  <xsl:param name="node" select="."/>
  <xsl:param name="prev" select="/foo"/>
  <xsl:param name="next" select="/foo"/>
  <xsl:param name="nav.context"/>
</xsl:template>

<!-- To use the same stripped nodeset everywhere, it should
be created as a global variable here.
Used by docbook.xsl, chunk-code.xsl and chunkfast.xsl -->
<xsl:variable name="no.namespace">
  <xsl:if test="$exsl.node.set.available != 0                     and (*/self::ng:* or */self::db:*)">
    <xsl:apply-templates select="/*" mode="stripNS"/>
  </xsl:if>
</xsl:variable>

<xsl:template match="/">
  <!-- * Get a title for current doc so that we let the user -->
  <!-- * know what document we are processing at this point. -->
  <xsl:variable name="doc.title">
    <xsl:call-template name="get.doc.title"/>
  </xsl:variable>
  <xsl:choose>
    <!-- Hack! If someone hands us a DocBook V5.x or DocBook NG document,
         toss the namespace and continue.  Use the docbook5 namespaced
         stylesheets for DocBook5 if you don't want to use this feature.-->
    <!-- include extra test for Xalan quirk -->
    <xsl:when test="$exsl.node.set.available != 0                     and (*/self::ng:* or */self::db:*)">
      <xsl:call-template name="log.message">
        <xsl:with-param name="level">Note</xsl:with-param>
        <xsl:with-param name="source" select="$doc.title"/>
        <xsl:with-param name="context-desc">
          <xsl:text>namesp. cut</xsl:text>
        </xsl:with-param>
        <xsl:with-param name="message">
          <xsl:text>stripped namespace before processing</xsl:text>
        </xsl:with-param>
      </xsl:call-template>
      <!-- DEBUG: to save stripped document.
      <xsl:message>Saving stripped document.</xsl:message>
      <xsl:call-template name="write.chunk">
        <xsl:with-param name="filename" select="'/tmp/stripped.xml'"/>
        <xsl:with-param name="method" select="'xml'"/>
        <xsl:with-param name="content">
          <xsl:copy-of select="exsl:node-set($no.namespace)"/>
        </xsl:with-param>
      </xsl:call-template>
      -->
      <xsl:call-template name="log.message">
        <xsl:with-param name="level">Note</xsl:with-param>
        <xsl:with-param name="source" select="$doc.title"/>
        <xsl:with-param name="context-desc">
          <xsl:text>namesp. cut</xsl:text>
        </xsl:with-param>
        <xsl:with-param name="message">
          <xsl:text>processing stripped document</xsl:text>
        </xsl:with-param>
      </xsl:call-template>
      <xsl:apply-templates select="exsl:node-set($no.namespace)"/>
    </xsl:when>
    <!-- Can't process unless namespace removed -->
    <xsl:when test="*/self::ng:* or */self::db:*">
      <xsl:message terminate="yes">
        <xsl:text>Unable to strip the namespace from DB5 document,</xsl:text>
        <xsl:text> cannot proceed.</xsl:text>
      </xsl:message>
    </xsl:when>
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="$rootid != ''">
          <xsl:choose>
            <xsl:when test="count(key('id',$rootid)) = 0">
              <xsl:message terminate="yes">
                <xsl:text>ID '</xsl:text>
                <xsl:value-of select="$rootid"/>
                <xsl:text>' not found in document.</xsl:text>
              </xsl:message>
            </xsl:when>
            <xsl:otherwise>
              <xsl:if test="$collect.xref.targets = 'yes' or                             $collect.xref.targets = 'only'">
                <xsl:apply-templates select="key('id', $rootid)" mode="collect.targets"/>
              </xsl:if>
              <xsl:if test="$collect.xref.targets != 'only'">
                <xsl:apply-templates select="key('id',$rootid)" mode="process.root"/>
                <xsl:if test="$tex.math.in.alt != ''">
                  <xsl:apply-templates select="key('id',$rootid)" mode="collect.tex.math"/>
                </xsl:if>
              </xsl:if>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:if test="$collect.xref.targets = 'yes' or                         $collect.xref.targets = 'only'">
            <xsl:apply-templates select="/" mode="collect.targets"/>
          </xsl:if>
          <xsl:if test="$collect.xref.targets != 'only'">
            <xsl:apply-templates select="/" mode="process.root"/>
            <xsl:if test="$tex.math.in.alt != ''">
              <xsl:apply-templates select="/" mode="collect.tex.math"/>
            </xsl:if>
          </xsl:if>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<xsl:template name="root.attributes">
  <!-- customize to add attributes to <html> element  -->
</xsl:template>
<xsl:template name="root.messages">
  <!-- redefine this any way you'd like to output messages -->
  <!-- DO NOT OUTPUT ANYTHING FROM THIS TEMPLATE -->
</xsl:template>

<!-- ================================== -->

<xsl:template name="chunk">
  <xsl:param name="node" select="."/>

  <!-- The default is that we are not chunking... -->
  <xsl:text>0</xsl:text>
</xsl:template>

<!-- publican templates -->
<xsl:template name="language.to.xslthl">
  <xsl:param name="context"/>

  <xsl:choose>
    <xsl:when test="$context/@language != ''">
      <xsl:value-of select="$context/@language"/>
    </xsl:when>
    <xsl:when test="$highlight.default.language != ''">
      <xsl:value-of select="$highlight.default.language"/>
    </xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template name="apply-highlighting">
  <xsl:choose>
    <!-- Do we want syntax highlighting -->
    <xsl:when test="$highlight.source != 0 and function-available('perl:highlight')">
      <xsl:variable name="language">
	<xsl:call-template name="language.to.xslthl">
	  <xsl:with-param name="context" select="."/>
	</xsl:call-template>
      </xsl:variable>
      <xsl:choose>
	<xsl:when test="$language != ''">
	  <xsl:variable name="content">
	    <xsl:apply-templates/>
	  </xsl:variable>
	  <xsl:apply-templates select="perl:highlight($language, exsl:node-set($content))"/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:apply-templates/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <!-- No syntax highlighting -->
    <xsl:otherwise>
      <xsl:apply-templates/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<xsl:template name="graphical.admonition">
	<xsl:variable name="admon.type">
		<xsl:choose>
			<xsl:when test="local-name(.)='note'">Note</xsl:when>
			<xsl:when test="local-name(.)='warning'">Warning</xsl:when>
			<xsl:when test="local-name(.)='important'">Important</xsl:when>
			<xsl:otherwise>Note</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>

	<xsl:variable name="alt">
		<xsl:call-template name="gentext">
			<xsl:with-param name="key" select="$admon.type"/>
		</xsl:call-template>
	</xsl:variable>

	<div>
		<xsl:apply-templates select="." mode="class.attribute"/>
			<xsl:if test="$admon.style != ''">
				<xsl:attribute name="style">
					<xsl:value-of select="$admon.style"/>
				</xsl:attribute>
			</xsl:if>

	                <xsl:call-template name="common.html.attributes"/>
			<xsl:if test="$admon.textlabel != 0 or title">
				<div class="admonition_header">
					<p>
						<strong><xsl:apply-templates select="." mode="object.title.markup"/></strong>
					</p>
				</div>
			</xsl:if>
		<div class="admonition">
		<xsl:apply-templates/>
		</div>
	</div>
</xsl:template>
<xsl:template match="substeps">
	<xsl:variable name="numeration">
		<xsl:call-template name="procedure.step.numeration"/>
	</xsl:variable>
	<ol class="{$numeration}">
		<xsl:call-template name="anchor"/>
		<xsl:apply-templates/>
	</ol>
</xsl:template>
<xsl:template match="orderedlist">
	<div>
		<xsl:call-template name="common.html.attributes"/>
		<xsl:apply-templates select="." mode="class.attribute"/>
		<xsl:call-template name="anchor"/>
		<xsl:if test="title">
			<xsl:call-template name="formal.object.heading"/>
		</xsl:if>
<!-- Preserve order of PIs and comments -->
		<xsl:apply-templates select="*[not(self::listitem or self::title or self::titleabbrev)] |                                       comment()[not(preceding-sibling::listitem)] |            processing-instruction()[not(preceding-sibling::listitem)]"/>
		<ol>
          <xsl:if test="@role">
            <xsl:apply-templates select="." mode="class.attribute">
              <xsl:with-param name="class" select="@role"/>
            </xsl:apply-templates>
          </xsl:if>
          <xsl:if test="@numeration">
            <xsl:apply-templates select="." mode="class.attribute">
              <xsl:with-param name="class" select="@numeration"/>
            </xsl:apply-templates>
          </xsl:if>
          <xsl:apply-templates select="listitem | comment()[preceding-sibling::listitem] | processing-instruction()[preceding-sibling::listitem]"/>
		</ol>
	</div>
</xsl:template>
<xsl:template match="procedure">
	<xsl:variable name="param.placement" select="substring-after(normalize-space($formal.title.placement), concat(local-name(.), ' '))"/>

	<xsl:variable name="placement">
		<xsl:choose>
			<xsl:when test="contains($param.placement, ' ')">
				<xsl:value-of select="substring-before($param.placement, ' ')"/>
			</xsl:when>
			<xsl:when test="$param.placement = ''">before</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$param.placement"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:variable>

<!-- Preserve order of PIs and comments -->
	<xsl:variable name="preamble" select="*[not(self::step or self::title or self::titleabbrev)] |comment()[not(preceding-sibling::step)] |processing-instruction()[not(preceding-sibling::step)]"/>
	<div>
		<xsl:apply-templates select="." mode="class.attribute"/>
		<xsl:call-template name="common.html.attributes"/>
		<xsl:call-template name="anchor">
			<xsl:with-param name="conditional">
				<xsl:choose>
					<xsl:when test="title">0</xsl:when>
					<xsl:otherwise>1</xsl:otherwise>
				</xsl:choose>
			</xsl:with-param>
		</xsl:call-template>
		<xsl:if test="title and $placement = 'before'">
			<xsl:call-template name="formal.object.heading"/>
		</xsl:if>
		<xsl:apply-templates select="$preamble"/>
		<xsl:choose>
			<xsl:when test="count(step) = 1">
				<ul>
					<xsl:apply-templates select="step |comment()[preceding-sibling::step] |processing-instruction()[preceding-sibling::step]"/>
				</ul>
			</xsl:when>
			<xsl:otherwise>
				<ol>
					<xsl:attribute name="class">
						<xsl:value-of select="substring($procedure.step.numeration.formats,1,1)"/>
					</xsl:attribute>
					<xsl:apply-templates select="step |comment()[preceding-sibling::step] |processing-instruction()[preceding-sibling::step]"/>
				</ol>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:if test="title and $placement != 'before'">
			<xsl:call-template name="formal.object.heading"/>
		</xsl:if>
	</div>
</xsl:template>
<xsl:template name="longdesc.link">
	<xsl:param name="longdesc.uri" select="''"/>

	<xsl:variable name="this.uri">
	<xsl:call-template name="make-relative-filename">
		<xsl:with-param name="base.dir" select="$base.dir"/>
			<xsl:with-param name="base.name">
				<xsl:call-template name="href.target.uri"/>
			</xsl:with-param>
		</xsl:call-template>
	</xsl:variable>
	<xsl:variable name="href.to">
		<xsl:call-template name="trim.common.uri.paths">
			<xsl:with-param name="uriA" select="$longdesc.uri"/>
			<xsl:with-param name="uriB" select="$this.uri"/>
			<xsl:with-param name="return" select="'A'"/>
		</xsl:call-template>
	</xsl:variable>
	<div class="longdesc-link">
		<br/>
		<span class="longdesc-link">
			<xsl:text>[</xsl:text>
			<a href="{$href.to}">D</a>
			<xsl:text>]</xsl:text>
		</span>
	</div>
</xsl:template>

<xsl:template name="head.content">
	<xsl:param name="node" select="."/>
	<xsl:param name="title">
		<xsl:apply-templates select="$node" mode="object.title.markup.textonly"/>
	</xsl:param>

	<title>
		<xsl:copy-of select="$title"/>
	</title>

	<xsl:if test="$html.stylesheet != ''">
		<xsl:call-template name="output.html.stylesheets">
			<xsl:with-param name="stylesheets" select="normalize-space($html.stylesheet)"/>
		</xsl:call-template>
	</xsl:if>
	<xsl:if test="$html.stylesheet.print != ''">
         <link rel="stylesheet" media="print">
            <xsl:attribute name="href">
              <xsl:value-of select="$html.stylesheet.print"/>
            </xsl:attribute>
            <xsl:if test="$html.stylesheet.type != ''">
              <xsl:attribute name="type">
                <xsl:value-of select="$html.stylesheet.type"/>
              </xsl:attribute>
           </xsl:if>
         </link>
        </xsl:if>

	<xsl:if test="$link.mailto.url != ''">
		<link rev="made" href="{$link.mailto.url}"/>
	</xsl:if>

	<xsl:if test="$html.base != ''">
		<base href="{$html.base}"/>
	</xsl:if>

	<meta name="generator">
		<xsl:attribute name="content">
			<xsl:text>publican </xsl:text><xsl:value-of select="$publican.version"/>
		</xsl:attribute>
	</meta>

	<meta name="package">
		<xsl:attribute name="content">
			<xsl:copy-of select="$package"/>
		</xsl:attribute>
	</meta>
	<xsl:if test="$generate.meta.abstract != 0">
		<xsl:variable name="info" select="(articleinfo |bookinfo |prefaceinfo |chapterinfo |appendixinfo |sectioninfo |sect1info |sect2info |sect3info |sect4info |sect5info |referenceinfo |refentryinfo |partinfo |info |docinfo)[1]"/>
		<xsl:if test="$info and $info/abstract">
			<meta name="description">
				<xsl:attribute name="content">
					<xsl:for-each select="$info/abstract[1]/*">
						<xsl:value-of select="normalize-space(.)"/>
						<xsl:if test="position() &lt; last()">
							<xsl:text> </xsl:text>
						</xsl:if>
					</xsl:for-each>
				</xsl:attribute>
			</meta>
		</xsl:if>
	</xsl:if>
      <xsl:if test="$embedtoc != 0 ">
          <link rel="stylesheet" type="text/css"><xsl:attribute name="href"><xsl:value-of select="$tocpath"/>/../common/<xsl:value-of select="$langpath"/>/css/menu.css</xsl:attribute></link>
          <link rel="stylesheet" type="text/css"><xsl:attribute name="href"><xsl:value-of select="$tocpath"/>/../menu.css</xsl:attribute></link>
          <link rel="stylesheet" type="text/css"><xsl:attribute name="href"><xsl:value-of select="$tocpath"/>/../print.css</xsl:attribute><xsl:attribute name="media">print</xsl:attribute></link>
        <xsl:if test="$brand != 'common'">
          <link rel="stylesheet" type="text/css"><xsl:attribute name="href"><xsl:value-of select="$tocpath"/>/../<xsl:value-of select="$brand"/>/<xsl:value-of select="$langpath"/>/css/menu.css</xsl:attribute></link>
	</xsl:if>
          <script type="text/javascript"><xsl:attribute name="src"><xsl:value-of select="$tocpath"/>/../jquery-1.7.1.min.js</xsl:attribute></script>
          <script type="text/javascript"><xsl:attribute name="src"><xsl:value-of select="$tocpath"/>/labels.js</xsl:attribute></script>
          <script type="text/javascript"><xsl:attribute name="src"><xsl:value-of select="$tocpath"/>/../toc.js</xsl:attribute></script>
          <script type="text/javascript">
          <xsl:if test="$web.type = ''">
		current_book = '<xsl:copy-of select="$pop_name"/>';
		current_version = '<xsl:copy-of select="$pop_ver"/>';
		current_product = '<xsl:copy-of select="$pop_prod"/>';
	   </xsl:if>
          <xsl:if test="$web.type != ''">
		current_book = '';
		current_version = '';
	   </xsl:if>
                toc_path = '<xsl:value-of select="$tocpath"/>';
		loadMenu();
          </script>
      </xsl:if>

	<xsl:apply-templates select="." mode="head.keywords.content"/>
</xsl:template>
<xsl:template name="body.attributes">
	<xsl:if test="starts-with($writing.mode, 'rl')">
		<xsl:attribute name="dir">rtl</xsl:attribute>
	</xsl:if>
	<xsl:variable name="class">
		<xsl:if test="($draft.mode = 'yes' or ($draft.mode = 'maybe' and (ancestor-or-self::set | ancestor-or-self::book | ancestor-or-self::article)[1]/@status = 'draft'))">
			<xsl:value-of select="ancestor-or-self::*[@status][1]/@status"/><xsl:text> </xsl:text>
		</xsl:if>
		<xsl:if test="$embedtoc != 0">
			<xsl:text>toc_embeded </xsl:text>
		</xsl:if>
       		<xsl:if test="$desktop != 0">
		  <xsl:text>desktop </xsl:text>
		</xsl:if>
	</xsl:variable>
        <xsl:if test="$class != ''">
	  <xsl:attribute name="class">
		<xsl:value-of select="$class"/>
	  </xsl:attribute>
	</xsl:if>
</xsl:template>
<xsl:template name="user.footer.content">
	<xsl:param name="node" select="."/>
	<xsl:if test="$confidential = '1'">
		<div class="confidential">
			<xsl:value-of select="$confidential.text"/>
		</div>
	</xsl:if>
	<xsl:if test="$embedtoc != 0">
		<div id="site_footer"/>
		<script type="text/javascript">
			$("#site_footer").load("<xsl:value-of select="$tocpath"/>/../footer.html");
		</script>
	</xsl:if>
</xsl:template>
<xsl:template match="formalpara">
	<xsl:call-template name="paragraph">
		<xsl:with-param name="class">
			<xsl:choose>
				<xsl:when test="@role and $para.propagates.style != 0">
					<xsl:value-of select="@role"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:text>formalpara</xsl:text>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:with-param>
		<xsl:with-param name="content">
			<xsl:apply-templates/>
		</xsl:with-param>
	</xsl:call-template>
	<!--xsl:apply-templates/-->
</xsl:template>
<xsl:template match="formalpara/title|formalpara/info/title">
	<xsl:variable name="titleStr">
			<xsl:apply-templates/>
	</xsl:variable>
	<div class="title">
		<xsl:copy-of select="$titleStr"/>
	</div>
</xsl:template>
<xsl:template match="itemizedlist">
  <div>
    <xsl:call-template name="common.html.attributes"/>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:call-template name="anchor"/>
    <xsl:if test="title">
      <xsl:call-template name="formal.object.heading"/>
    </xsl:if>

    <!-- Preserve order of PIs and comments -->
    <xsl:apply-templates select="*[not(self::listitem or self::title or self::titleabbrev)] |           comment()[not(preceding-sibling::listitem)] |           processing-instruction()[not(preceding-sibling::listitem)]"/>
    <ul>
      <xsl:if test="@role">
        <xsl:apply-templates select="." mode="class.attribute">
          <xsl:with-param name="class" select="@role"/>
        </xsl:apply-templates>
      </xsl:if>
      <xsl:if test="$css.decoration != 0">
        <xsl:attribute name="type">
          <xsl:call-template name="list.itemsymbol"/>
        </xsl:attribute>
      </xsl:if>

      <xsl:if test="@spacing='compact'">
        <xsl:attribute name="compact">
          <xsl:value-of select="@spacing"/>
        </xsl:attribute>
      </xsl:if>
      <xsl:apply-templates select="listitem | comment()[preceding-sibling::listitem] | processing-instruction()[preceding-sibling::listitem]"/>
    </ul>
  </div>
</xsl:template>
<xsl:template match="ulink" name="ulink">
  <xsl:param name="url" select="@url"/>
  <xsl:variable name="link">
    <a>
      <xsl:if test="@id or @xml:id">
        <xsl:attribute name="id">
          <xsl:value-of select="(@id|@xml:id)[1]"/>
        </xsl:attribute>
      </xsl:if>
      <xsl:attribute name="href"><xsl:value-of select="$url"/></xsl:attribute>
      <xsl:if test="$ulink.target != ''">
        <xsl:attribute name="target">
          <xsl:value-of select="$ulink.target"/>
        </xsl:attribute>
      </xsl:if>
      <xsl:if test="@role">
        <xsl:apply-templates select="." mode="class.attribute">
          <xsl:with-param name="class" select="@role"/>
        </xsl:apply-templates>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="count(child::node())=0">
          <xsl:value-of select="$url"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates/>
        </xsl:otherwise>
      </xsl:choose>
    </a>
  </xsl:variable>
  <xsl:copy-of select="$link"/>
</xsl:template>
<xsl:template match="*" mode="class.attribute">
  <xsl:param name="class" select="local-name(.)"/>
  <!-- permit customization of class attributes -->
  <!-- Use element name by default -->
  <xsl:attribute name="class">
    <!--xsl:value-of select="$class"/-->
    <xsl:apply-templates select="." mode="class.value">
      <xsl:with-param name="class" select="$class"/>
    </xsl:apply-templates>
    <xsl:if test="@role">
        <xsl:text> </xsl:text>
        <xsl:value-of select="@role"/>
    </xsl:if>
  </xsl:attribute>
</xsl:template>
<xsl:template match="imagedata">
  <xsl:variable name="filename">
    <xsl:call-template name="mediaobject.filename">
      <xsl:with-param name="object" select=".."/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="@format='linespecific'">
      <xsl:choose>
        <xsl:when test="$use.extensions != '0'                         and $textinsert.extension != '0'">
          <xsl:choose>
            <xsl:when test="element-available('stext:insertfile')">
              <stext:insertfile xmlns:stext="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.TextFactory" href="{$filename}" encoding="{$textdata.default.encoding}"/>
            </xsl:when>
            <xsl:when test="element-available('xtext:insertfile')">
              <xtext:insertfile xmlns:xtext="xalan://com.nwalsh.xalan.Text" href="{$filename}"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:message terminate="yes">
                <xsl:text>No insertfile extension available.</xsl:text>
              </xsl:message>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad" href="{$filename}"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="longdesc.uri">
        <xsl:call-template name="longdesc.uri">
          <xsl:with-param name="mediaobject" select="ancestor::imageobject/parent::*"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:variable name="phrases" select="ancestor::mediaobject/textobject[phrase]                             |ancestor::inlinemediaobject/textobject[phrase]                             |ancestor::mediaobjectco/textobject[phrase]"/>

      <xsl:call-template name="process.image">
        <xsl:with-param name="alt">
          <xsl:apply-templates select="$phrases[not(@role) or @role!='tex'][1]"/>
        </xsl:with-param>
        <xsl:with-param name="longdesc">
          <xsl:call-template name="write.longdesc">
            <xsl:with-param name="mediaobject" select="ancestor::imageobject/parent::*"/>
          </xsl:call-template>
        </xsl:with-param>
      </xsl:call-template>

      <xsl:if test="$html.longdesc != 0 and $html.longdesc.link != 0                     and ancestor::imageobject/parent::*/textobject[not(phrase)]">
        <xsl:call-template name="longdesc.link">
          <xsl:with-param name="longdesc.uri" select="$longdesc.uri"/>
        </xsl:call-template>
      </xsl:if>
      <xsl:if test="$html.longdesc.embed != 0 and ancestor::imageobject/parent::*/textobject[not(phrase)]">
        <div class="longdesc">
            <xsl:for-each select="ancestor::imageobject/parent::*/textobject[not(phrase)]">
              <xsl:apply-templates select="./*"/>
            </xsl:for-each>
        </div>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<xsl:template name="qandaset">
  <div class="qandaset">
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:apply-templates/>
  </div>
</xsl:template>
<xsl:template name="process.qandaset">
  <div class="qandaset">
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:apply-templates/>
  </div>
</xsl:template>
<xsl:template match="qandadiv">
  <xsl:variable name="preamble" select="*[local-name(.) != 'title'                                           and local-name(.) != 'titleabbrev'                                           and local-name(.) != 'qandadiv'                                           and local-name(.) != 'qandaentry']"/>

  <xsl:if test="blockinfo/title|info/title|title">
    <div class="qandadiv">
        <xsl:apply-templates select="(blockinfo/title|info/title|title)[1]"/>
    </div>
  </xsl:if>

  <xsl:variable name="toc">
    <xsl:call-template name="dbhtml-attribute">
      <xsl:with-param name="pis" select="processing-instruction('dbhtml')"/>
      <xsl:with-param name="attribute" select="'toc'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="toc.params">
    <xsl:call-template name="find.path.params">
      <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
    </xsl:call-template>
  </xsl:variable>
  <xsl:if test="(contains($toc.params, 'toc') and $toc != '0') or $toc = '1'">
    <div class="toc">
        <xsl:call-template name="process.qanda.toc"/>
    </div>
  </xsl:if>
  <xsl:if test="$preamble">
    <div class="preamble">
        <xsl:apply-templates select="$preamble"/>
    </div>
  </xsl:if>
  <div>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:apply-templates select="qandadiv|qandaentry"/>
  </div>
</xsl:template>
<xsl:template match="qandaentry">
  <div>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:apply-templates/>
  </div>
</xsl:template>
<xsl:template match="question">
  <xsl:variable name="deflabel">
    <xsl:choose>
      <xsl:when test="ancestor-or-self::*[@defaultlabel]">
        <xsl:value-of select="(ancestor-or-self::*[@defaultlabel])[last()] /@defaultlabel"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$qanda.defaultlabel"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:variable name="label.content">
    <xsl:apply-templates select="." mode="label.markup"/>
    <xsl:if test="$deflabel = 'number' and not(label)">
      <xsl:apply-templates select="." mode="intralabel.punctuation"/>
    </xsl:if>
  </xsl:variable>
  <div>
    <xsl:apply-templates select="." mode="class.attribute"/>
      <xsl:call-template name="anchor">
        <xsl:with-param name="node" select=".."/>
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>
      <!--xsl:call-template name="anchor">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template-->
      <xsl:if test="string-length($label.content) &gt; 0">
        <div class="label">
          <xsl:copy-of select="$label.content"/>
        </div>
      </xsl:if>
    <div class="data">
      <xsl:apply-templates/>
    </div>
  </div>
</xsl:template>
<xsl:template match="answer">
  <xsl:variable name="deflabel">
    <xsl:choose>
      <xsl:when test="ancestor-or-self::*[@defaultlabel]">
        <xsl:value-of select="(ancestor-or-self::*[@defaultlabel])[last()] /@defaultlabel"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$qanda.defaultlabel"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <div>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:variable name="answer.label">
      <xsl:apply-templates select="." mode="label.markup"/>
    </xsl:variable>
    <xsl:if test="string-length($answer.label) &gt; 0">
      <div class="label">
        <xsl:copy-of select="$answer.label"/>
      </div>
    </xsl:if>
     <div class="data">
       <xsl:apply-templates/>
     </div>
   </div>
</xsl:template>
<xsl:template match="perl_Alert | perl_BaseN | perl_BString | perl_Char | perl_Comment | perl_DataType | perl_DecVal | perl_Error | perl_Float | perl_Function | perl_IString | perl_Keyword | perl_Operator | perl_Others | perl_RegionMarker | perl_Reserved | perl_String | perl_Variable | perl_Warning ">
  <xsl:variable name="name">
    <xsl:value-of select="local-name(.)"/>
  </xsl:variable>
  <xsl:variable name="content">
    <xsl:apply-templates/>
  </xsl:variable>
  <xsl:choose>
    <xsl:when test="contains($content,'&#10;')">
      <span><xsl:attribute name="class"><xsl:value-of select="$name"/></xsl:attribute><xsl:value-of select="substring-before($content,'&#10;')"/></span><xsl:text>
</xsl:text>
      <span><xsl:attribute name="class"><xsl:value-of select="$name"/></xsl:attribute><xsl:value-of select="substring-after($content,'&#10;')"/></span>
    </xsl:when>
    <xsl:otherwise>
      <span><xsl:attribute name="class"><xsl:value-of select="$name"/></xsl:attribute><xsl:value-of select="$content"/></span>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<!--<xsl:template match="productnumber" mode="book.titlepage.recto.auto.mode">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</xsl:template>
<xsl:template match="productname" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </span>
</xsl:template>
<xsl:template match="productnumber" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </span>
</xsl:template>
<xsl:template match="productname" mode="book.titlepage.recto.auto.mode">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</xsl:template>
<xsl:template match="orgdiv" mode="titlepage.mode">
  <xsl:if test="preceding-sibling::*[1][self::orgname]">
    <xsl:text> </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </span>
</xsl:template>
<xsl:template match="orgname" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </span>
</xsl:template><xsl:template name="book.titlepage.recto">
  <xsl:choose>
    <xsl:when test="bookinfo/productname">
	<div class="producttitle" xsl:use-attribute-sets="book.titlepage.recto.style">
	  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/productname"/>
	  <xsl:text> </xsl:text>
	  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/productnumber"/>
	</div>
    </xsl:when>
  </xsl:choose>
  <xsl:choose>
    <xsl:when test="bookinfo/title">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="bookinfo/subtitle">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="titlepage.mode" select="bookinfo/edition"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/corpauthor"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/authorgroup"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/author"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/othercredit"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/releaseinfo"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/copyright"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/legalnotice"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/pubdate"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/revision"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/revhistory"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/abstract"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template match="legalnotice" mode="titlepage.mode">
  <xsl:variable name="id"><xsl:call-template name="object.id"/></xsl:variable>
  <xsl:choose>
    <xsl:when test="$generate.legalnotice.link != 0">
      <xsl:variable name="filename">
        <xsl:call-template name="make-relative-filename">
          <xsl:with-param name="base.dir" select="$base.dir"/>
	  <xsl:with-param name="base.name">
            <xsl:apply-templates mode="chunk-filename" select="."/>
	  </xsl:with-param>
        </xsl:call-template>
      </xsl:variable>

      <xsl:variable name="title">
        <xsl:apply-templates select="." mode="title.markup"/>
      </xsl:variable>

      <xsl:variable name="href">
        <xsl:apply-templates mode="chunk-filename" select="."/>
      </xsl:variable>

      <a href="{$href}"><xsl:copy-of select="$title"/></a>

      <xsl:call-template name="write.chunk">
        <xsl:with-param name="filename" select="$filename"/>
        <xsl:with-param name="quiet" select="$chunk.quietly"/>
        <xsl:with-param name="content">
        <xsl:call-template name="user.preroot"/>
          <html>
            <head>
              <xsl:call-template name="system.head.content"/>
              <xsl:call-template name="head.content"/>
              <xsl:call-template name="user.head.content"/>
            </head>
            <body>
              <xsl:call-template name="body.attributes"/>
              <div>
                <xsl:apply-templates select="." mode="class.attribute"/>
                <xsl:apply-templates mode="titlepage.mode"/>
              </div>
            </body>
          </html>
          <xsl:value-of select="$chunk.append"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <div>
        <xsl:apply-templates select="." mode="class.attribute"/>
        <a id="{$id}"/>
	<h1 class="legalnotice">
    <xsl:call-template name="gentext">
      <xsl:with-param name="key">LegalNotice</xsl:with-param>
    </xsl:call-template>
	</h1>
        <xsl:apply-templates mode="titlepage.mode"/>
      </div>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="chapter/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.title">
    <xsl:with-param name="node" select="ancestor::chapter[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="section/title|section/info/title|sectioninfo/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.title"/>
</xsl:template><xsl:template match="edition" mode="titlepage.mode">
  <p>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:call-template name="gentext">
      <xsl:with-param name="key" select="'Edition'"/>
    </xsl:call-template>
    <xsl:call-template name="gentext.space"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </p>
</xsl:template><xsl:template name="article.titlepage.recto">
  <xsl:choose>
    <xsl:when test="articleinfo/productname">
	<div class="producttitle" xsl:use-attribute-sets="book.titlepage.recto.style">
	  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="articleinfo/productname"/>
	  <xsl:text> </xsl:text>
	  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="articleinfo/productnumber"/>
	</div>
    </xsl:when>
  </xsl:choose>
  <xsl:choose>
    <xsl:when test="articleinfo/title">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/title"/>
    </xsl:when>
    <xsl:when test="artheader/title">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="articleinfo/subtitle">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="artheader/subtitle">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/corpauthor"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/corpauthor"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/authorgroup"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/authorgroup"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/author"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/author"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/othercredit"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/othercredit"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/releaseinfo"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/releaseinfo"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/copyright"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/copyright"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/legalnotice"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/legalnotice"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/pubdate"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/pubdate"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/revision"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/revision"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/revhistory"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/revhistory"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/abstract"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/abstract"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template>-->
<xsl:template name="paragraph">
  <xsl:param name="class" select="''"/>
  <xsl:param name="content"/>

  <xsl:variable name="p">
    <div class="para">
      <xsl:call-template name="dir"/>
      <xsl:if test="$class != ''">
        <xsl:apply-templates select="." mode="class.attribute">
          <xsl:with-param name="class" select="$class"/>
        </xsl:apply-templates>
      </xsl:if>
      <xsl:if test="@id or @xml:id">
        <xsl:attribute name="id">
          <xsl:value-of select="(@id|@xml:id)[1]"/>
        </xsl:attribute>
      </xsl:if>
      <xsl:copy-of select="$content"/>
    </div>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$html.cleanup != 0">
      <xsl:call-template name="unwrap.p">
        <xsl:with-param name="p" select="$p"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="$p"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<xsl:template match="simpara">
  <!-- see also listitem/simpara in lists.xsl -->
  <div class="para">
    <xsl:if test="@role and $para.propagates.style != 0">
      <xsl:apply-templates select="." mode="class.attribute">
        <xsl:with-param name="class" select="@role"/>
      </xsl:apply-templates>
    </xsl:if>

    <xsl:call-template name="anchor"/>
    <p/>
    <xsl:apply-templates/>
  </div>
</xsl:template>
<xsl:template match="collab" mode="titlepage.mode">
</xsl:template>
<xsl:template match="funcprototype">
  <xsl:variable name="html-style">
    <xsl:call-template name="dbhtml-attribute">
      <xsl:with-param name="pis" select="ancestor::funcsynopsis//processing-instruction('dbhtml')"/>
      <xsl:with-param name="attribute" select="'funcsynopsis-style'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="style">
    <xsl:choose>
      <xsl:when test="$html-style != ''">
        <xsl:value-of select="$html-style"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$funcsynopsis.style"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

<!--
  <xsl:variable name="tabular-p"
                select="$funcsynopsis.tabular.threshold &gt; 0
                        and string-length(.) &gt; $funcsynopsis.tabular.threshold"/>
-->

  <xsl:variable name="tabular-p" select="false()"/>

  <xsl:choose>
    <xsl:when test="$style = 'kr' and $tabular-p">
      <xsl:apply-templates select="." mode="kr-tabular"/>
    </xsl:when>
    <xsl:when test="$style = 'kr'">
      <xsl:apply-templates select="." mode="kr-nontabular"/>
    </xsl:when>
    <xsl:when test="$style = 'ansi' and $tabular-p">
      <xsl:apply-templates select="." mode="ansi-tabular"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="." mode="ansi-nontabular"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<xsl:template name="process.image">
  <!-- When this template is called, the current node should be  -->
  <!-- a graphic, inlinegraphic, imagedata, or videodata. All    -->
  <!-- those elements have the same set of attributes, so we can -->
  <!-- handle them all in one place.                             -->
  <xsl:param name="tag" select="'img'"/>
  <xsl:param name="alt"/>
  <xsl:param name="longdesc"/>

  <!-- The HTML img element only supports the notion of content-area
       scaling; it doesn't support the distinction between a
       content-area and a viewport-area, so we have to make some
       compromises.

       1. If only the content-area is specified, everything is fine.
          (If you ask for a three inch image, that's what you'll get.)

       2. If only the viewport-area is provided:
          - If scalefit=1, treat it as both the content-area and
            the viewport-area. (If you ask for an image in a five inch
            area, we'll make the image five inches to fill that area.)
          - If scalefit=0, ignore the viewport-area specification.

          Note: this is not quite the right semantic and has the additional
          problem that it can result in anamorphic scaling, which scalefit
          should never cause.

       3. If both the content-area and the viewport-area is specified
          on a graphic element, ignore the viewport-area.
          (If you ask for a three inch image in a five inch area, we'll assume
           it's better to give you a three inch image in an unspecified area
           than a five inch image in a five inch area.

       Relative units also cause problems. As a general rule, the stylesheets
       are operating too early and too loosely coupled with the rendering engine
       to know things like the current font size or the actual dimensions of
       an image. Therefore:

       1. We use a fixed size for pixels, $pixels.per.inch

       2. We use a fixed size for "em"s, $points.per.em

       Percentages are problematic. In the following discussion, we speak
       of width and contentwidth, but the same issues apply to depth and
       contentdepth

       1. A width of 50% means "half of the available space for the image."
          That's fine. But note that in HTML, this is a dynamic property and
          the image size will vary if the browser window is resized.

       2. A contentwidth of 50% means "half of the actual image width". But
          the stylesheets have no way to assess the image's actual size. Treating
          this as a width of 50% is one possibility, but it produces behavior
          (dynamic scaling) that seems entirely out of character with the
          meaning.

          Instead, the stylesheets define a $nominal.image.width
          and convert percentages to actual values based on that nominal size.

       Scale can be problematic. Scale applies to the contentwidth, so
       a scale of 50 when a contentwidth is not specified is analagous to a
       width of 50%. (If a contentwidth is specified, the scaling factor can
       be applied to that value and no problem exists.)

       If scale is specified but contentwidth is not supplied, the
       nominal.image.width is used to calculate a base size
       for scaling.

       Warning: as a consequence of these decisions, unless the aspect ratio
       of your image happens to be exactly the same as (nominal width / nominal height),
       specifying contentwidth="50%" and contentdepth="50%" is NOT going to
       scale the way you expect (or really, the way it should).

       Don't do that. In fact, a percentage value is not recommended for content
       size at all. Use scale instead.

       Finally, align and valign are troublesome. Horizontal alignment is now
       supported by wrapping the image in a <div align="{@align}"> (in block
       contexts!). I can't think of anything (practical) to do about vertical
       alignment.
  -->

  <xsl:variable name="width-units">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0"/>
      <xsl:when test="@width">
        <xsl:call-template name="length-units">
          <xsl:with-param name="length" select="@width"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="not(@depth) and $default.image.width != ''">
        <xsl:call-template name="length-units">
          <xsl:with-param name="length" select="$default.image.width"/>
        </xsl:call-template>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="width">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0"/>
      <xsl:when test="@width">
        <xsl:choose>
          <xsl:when test="$width-units = '%'">
            <xsl:value-of select="@width"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="length-spec">
              <xsl:with-param name="length" select="@width"/>
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:when test="not(@depth) and $default.image.width != ''">
        <xsl:value-of select="$default.image.width"/>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="scalefit">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0">0</xsl:when>
      <xsl:when test="@contentwidth or @contentdepth">0</xsl:when>
      <xsl:when test="@scale">0</xsl:when>
      <xsl:when test="@scalefit"><xsl:value-of select="@scalefit"/></xsl:when>
      <xsl:when test="$width != '' or @depth">1</xsl:when>
      <xsl:otherwise>0</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="scale">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0">1.0</xsl:when>
      <xsl:when test="@contentwidth or @contentdepth">1.0</xsl:when>
      <xsl:when test="@scale">
        <xsl:value-of select="@scale div 100.0"/>
      </xsl:when>
      <xsl:otherwise>1.0</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="filename">
    <xsl:choose>
      <xsl:when test="local-name(.) = 'graphic'                       or local-name(.) = 'inlinegraphic'">
        <!-- handle legacy graphic and inlinegraphic by new template --> 
        <xsl:call-template name="mediaobject.filename">
          <xsl:with-param name="object" select="."/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <!-- imagedata, videodata, audiodata -->
        <xsl:call-template name="mediaobject.filename">
          <xsl:with-param name="object" select=".."/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="output_filename">
    <xsl:choose>
      <xsl:when test="$embedtoc != 0 and contains($filename, 'Common_Content')">
        <xsl:value-of select=" concat($tocpath, '/../', $brand, '/',$langpath)"/>
        <xsl:value-of select="substring-after($filename, 'Common_Content')"/>
      </xsl:when>
      <xsl:when test="@entityref">
        <xsl:value-of select="$filename"/>
      </xsl:when>
      <!--
        Moved test for $keep.relative.image.uris to template below:
            <xsl:template match="@fileref">
      -->
      <xsl:otherwise>
        <xsl:value-of select="$filename"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="img.src.path.pi">
    <xsl:call-template name="dbhtml-attribute">
      <xsl:with-param name="pis" select="../processing-instruction('dbhtml')"/>
      <xsl:with-param name="attribute" select="'img.src.path'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="filename.for.graphicsize">
    <xsl:choose>
      <xsl:when test="$img.src.path.pi != ''">
        <xsl:value-of select="concat($img.src.path.pi, $filename)"/>
      </xsl:when>
      <xsl:when test="$img.src.path != '' and                       $graphicsize.use.img.src.path != 0 and                       $tag = 'img' and                       not(starts-with($filename, '/')) and                       not(contains($filename, '://'))">
        <xsl:value-of select="concat($img.src.path, $filename)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$filename"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="realintrinsicwidth">
    <!-- This funny compound test works around a bug in XSLTC -->
    <xsl:choose>
      <xsl:when test="$use.extensions != 0 and $graphicsize.extension != 0">
        <xsl:choose>
          <xsl:when test="function-available('simg:getWidth')">
            <xsl:value-of select="simg:getWidth(simg:new($filename.for.graphicsize),                                                 $nominal.image.width)"/>
          </xsl:when>
          <xsl:when test="function-available('ximg:getWidth')">
            <xsl:value-of select="ximg:getWidth(ximg:new($filename.for.graphicsize),                                                 $nominal.image.width)"/>
          </xsl:when>
          <xsl:otherwise>
           <xsl:value-of select="0"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="0"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="intrinsicwidth">
    <xsl:choose>
      <xsl:when test="$realintrinsicwidth = 0">
       <xsl:value-of select="$nominal.image.width"/>
      </xsl:when>
      <xsl:otherwise>
       <xsl:value-of select="$realintrinsicwidth"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="intrinsicdepth">
    <!-- This funny compound test works around a bug in XSLTC -->
    <xsl:choose>
      <xsl:when test="$use.extensions != 0 and $graphicsize.extension != 0">
        <xsl:choose>
          <xsl:when test="function-available('simg:getDepth')">
            <xsl:value-of select="simg:getDepth(simg:new($filename.for.graphicsize),                                                 $nominal.image.depth)"/>
          </xsl:when>
          <xsl:when test="function-available('ximg:getDepth')">
            <xsl:value-of select="ximg:getDepth(ximg:new($filename.for.graphicsize),                                                 $nominal.image.depth)"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$nominal.image.depth"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$nominal.image.depth"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="contentwidth">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0"/>
      <xsl:when test="@contentwidth">
        <xsl:variable name="units">
          <xsl:call-template name="length-units">
            <xsl:with-param name="length" select="@contentwidth"/>
          </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
          <xsl:when test="$units = '%'">
            <xsl:variable name="cmagnitude">
              <xsl:call-template name="length-magnitude">
                <xsl:with-param name="length" select="@contentwidth"/>
              </xsl:call-template>
            </xsl:variable>
            <xsl:value-of select="$intrinsicwidth * $cmagnitude div 100.0"/>
            <xsl:text>px</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="length-spec">
              <xsl:with-param name="length" select="@contentwidth"/>
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$intrinsicwidth"/>
        <xsl:text>px</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="scaled.contentwidth">
    <xsl:if test="$contentwidth != ''">
      <xsl:variable name="cwidth.in.points">
        <xsl:call-template name="length-in-points">
          <xsl:with-param name="length" select="$contentwidth"/>
          <xsl:with-param name="pixels.per.inch" select="$pixels.per.inch"/>
          <xsl:with-param name="em.size" select="$points.per.em"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:value-of select="$cwidth.in.points div 72.0 * $pixels.per.inch * $scale"/>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="html.width">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0"/>
      <xsl:when test="$width-units = '%'">
        <xsl:value-of select="$width"/>
      </xsl:when>
      <xsl:when test="$width != ''">
        <xsl:variable name="width.in.points">
          <xsl:call-template name="length-in-points">
            <xsl:with-param name="length" select="$width"/>
            <xsl:with-param name="pixels.per.inch" select="$pixels.per.inch"/>
            <xsl:with-param name="em.size" select="$points.per.em"/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="round($width.in.points div 72.0 * $pixels.per.inch)"/>
      </xsl:when>
      <xsl:otherwise/>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="contentdepth">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0"/>
      <xsl:when test="@contentdepth">
        <xsl:variable name="units">
          <xsl:call-template name="length-units">
            <xsl:with-param name="length" select="@contentdepth"/>
          </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
          <xsl:when test="$units = '%'">
            <xsl:variable name="cmagnitude">
              <xsl:call-template name="length-magnitude">
                <xsl:with-param name="length" select="@contentdepth"/>
              </xsl:call-template>
            </xsl:variable>
            <xsl:value-of select="$intrinsicdepth * $cmagnitude div 100.0"/>
            <xsl:text>px</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="length-spec">
              <xsl:with-param name="length" select="@contentdepth"/>
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$intrinsicdepth"/>
        <xsl:text>px</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="scaled.contentdepth">
    <xsl:if test="$contentdepth != ''">
      <xsl:variable name="cdepth.in.points">
        <xsl:call-template name="length-in-points">
          <xsl:with-param name="length" select="$contentdepth"/>
          <xsl:with-param name="pixels.per.inch" select="$pixels.per.inch"/>
          <xsl:with-param name="em.size" select="$points.per.em"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:value-of select="$cdepth.in.points div 72.0 * $pixels.per.inch * $scale"/>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="depth-units">
    <xsl:if test="@depth">
      <xsl:call-template name="length-units">
        <xsl:with-param name="length" select="@depth"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="depth">
    <xsl:if test="@depth">
      <xsl:choose>
        <xsl:when test="$depth-units = '%'">
          <xsl:value-of select="@depth"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="length-spec">
            <xsl:with-param name="length" select="@depth"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:variable>

  <xsl:variable name="html.depth">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0"/>
      <xsl:when test="$depth-units = '%'">
        <xsl:value-of select="$depth"/>
      </xsl:when>
      <xsl:when test="@depth and @depth != ''">
        <xsl:variable name="depth.in.points">
          <xsl:call-template name="length-in-points">
            <xsl:with-param name="length" select="$depth"/>
            <xsl:with-param name="pixels.per.inch" select="$pixels.per.inch"/>
            <xsl:with-param name="em.size" select="$points.per.em"/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="round($depth.in.points div 72.0 * $pixels.per.inch)"/>
      </xsl:when>
      <xsl:otherwise/>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="viewport">
    <xsl:choose>
      <xsl:when test="$ignore.image.scaling != 0">0</xsl:when>
      <xsl:when test="local-name(.) = 'inlinegraphic'                       or ancestor::inlinemediaobject                       or ancestor::inlineequation">0</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$make.graphic.viewport"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

<!--
  <xsl:message>=====================================
scale: <xsl:value-of select="$scale"/>, <xsl:value-of select="$scalefit"/>
@contentwidth <xsl:value-of select="@contentwidth"/>
$contentwidth <xsl:value-of select="$contentwidth"/>
scaled.contentwidth: <xsl:value-of select="$scaled.contentwidth"/>
@width: <xsl:value-of select="@width"/>
width: <xsl:value-of select="$width"/>
html.width: <xsl:value-of select="$html.width"/>
@contentdepth <xsl:value-of select="@contentdepth"/>
$contentdepth <xsl:value-of select="$contentdepth"/>
scaled.contentdepth: <xsl:value-of select="$scaled.contentdepth"/>
@depth: <xsl:value-of select="@depth"/>
depth: <xsl:value-of select="$depth"/>
html.depth: <xsl:value-of select="$html.depth"/>
align: <xsl:value-of select="@align"/>
valign: <xsl:value-of select="@valign"/></xsl:message>
-->

  <xsl:variable name="scaled" select="@width|@depth|@contentwidth|@contentdepth                         |@scale|@scalefit"/>

  <xsl:variable name="img">
    <xsl:choose>
      <xsl:when test="@format = 'SVG' and $svg.object != 0">
        <object data="{$output_filename}" type="image/svg+xml">
          <xsl:call-template name="process.image.attributes">
            <!--xsl:with-param name="alt" select="$alt"/ there's no alt here-->
            <xsl:with-param name="html.depth" select="$html.depth"/>
            <xsl:with-param name="html.width" select="$html.width"/>
            <xsl:with-param name="longdesc" select="$longdesc"/>
            <xsl:with-param name="scale" select="$scale"/>
            <xsl:with-param name="scalefit" select="$scalefit"/>
            <xsl:with-param name="scaled.contentdepth" select="$scaled.contentdepth"/>
            <xsl:with-param name="scaled.contentwidth" select="$scaled.contentwidth"/>
            <xsl:with-param name="viewport" select="$viewport"/>
          </xsl:call-template>
          <xsl:if test="@align">
            <xsl:attribute name="align">
                <xsl:choose>
                  <xsl:when test="@align = 'center'">middle</xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="@align"/>
                  </xsl:otherwise>
                </xsl:choose>
            </xsl:attribute>
          </xsl:if>
          <xsl:if test="$use.embed.for.svg != 0">
            <embed src="{$output_filename}" type="image/svg+xml">
              <xsl:call-template name="process.image.attributes">
                <!--xsl:with-param name="alt" select="$alt"/ there's no alt here -->
                <xsl:with-param name="html.depth" select="$html.depth"/>
                <xsl:with-param name="html.width" select="$html.width"/>
                <xsl:with-param name="longdesc" select="$longdesc"/>
                <xsl:with-param name="scale" select="$scale"/>
                <xsl:with-param name="scalefit" select="$scalefit"/>
                <xsl:with-param name="scaled.contentdepth" select="$scaled.contentdepth"/>
                <xsl:with-param name="scaled.contentwidth" select="$scaled.contentwidth"/>
                <xsl:with-param name="viewport" select="$viewport"/>
              </xsl:call-template>
            </embed>
          </xsl:if>
<!-- Added this line to fix object breaking IE7 BZ #486501 -->
          <xsl:text> </xsl:text><xsl:value-of select="$alt"/>
        </object>
      </xsl:when>
      <xsl:otherwise>
        <xsl:element name="{$tag}" namespace="http://www.w3.org/1999/xhtml">
         <xsl:if test="$tag = 'img' and ../../self::imageobjectco">
           <xsl:variable name="mapname">
             <xsl:call-template name="object.id">
               <xsl:with-param name="object" select="../../areaspec"/>
             </xsl:call-template>
           </xsl:variable>
           <xsl:choose>
             <xsl:when test="$scaled">
              <!-- It might be possible to handle some scaling; needs -->
              <!-- more investigation -->
              <xsl:message>
                <xsl:text>Warning: imagemaps not supported </xsl:text>
                <xsl:text>on scaled images</xsl:text>
              </xsl:message>
             </xsl:when>
             <xsl:otherwise>
              <xsl:attribute name="border">0</xsl:attribute>
              <xsl:attribute name="usemap">
                <xsl:value-of select="concat('#', $mapname)"/>
              </xsl:attribute>
             </xsl:otherwise>
           </xsl:choose>
         </xsl:if>

          <xsl:attribute name="src">
           <xsl:choose>
             <xsl:when test="$img.src.path != '' and                            $tag = 'img' and                              not(starts-with($output_filename, '/')) and                            not(contains($output_filename, '://'))">
               <xsl:value-of select="$img.src.path"/>
             </xsl:when>
           </xsl:choose>
            <xsl:value-of select="$output_filename"/>
          </xsl:attribute>

          <xsl:if test="@align">
            <xsl:attribute name="align">
              <xsl:choose>
                <xsl:when test="@align = 'center'">middle</xsl:when>
                <xsl:otherwise>
                  <xsl:value-of select="@align"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:attribute>
          </xsl:if>

          <xsl:call-template name="process.image.attributes">
            <xsl:with-param name="alt">
              <xsl:choose>
                <xsl:when test="$alt != ''">
                  <xsl:copy-of select="$alt"/>
                </xsl:when>
                <xsl:when test="ancestor::figure">
                  <xsl:value-of select="normalize-space(ancestor::figure/title)"/>
                </xsl:when>
              </xsl:choose>
            </xsl:with-param>
            <xsl:with-param name="html.depth" select="$html.depth"/>
            <xsl:with-param name="html.width" select="$html.width"/>
            <xsl:with-param name="longdesc" select="$longdesc"/>
            <xsl:with-param name="scale" select="$scale"/>
            <xsl:with-param name="scalefit" select="$scalefit"/>
            <xsl:with-param name="scaled.contentdepth" select="$scaled.contentdepth"/>
            <xsl:with-param name="scaled.contentwidth" select="$scaled.contentwidth"/>
            <xsl:with-param name="viewport" select="$viewport"/>
          </xsl:call-template>
        </xsl:element>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="bgcolor">
    <xsl:call-template name="dbhtml-attribute">
      <xsl:with-param name="pis" select="../processing-instruction('dbhtml')"/>
      <xsl:with-param name="attribute" select="'background-color'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="use.viewport" select="$viewport != 0                         and ($html.width != ''                              or ($html.depth != '' and $depth-units != '%')                              or $bgcolor != ''                              or @valign)"/>

  <xsl:choose>
    <xsl:when test="$use.viewport">
      <table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0">
        <xsl:if test="$html.width != ''">
          <xsl:attribute name="width">
            <xsl:value-of select="$html.width"/>
          </xsl:attribute>
        </xsl:if>
        <tr>
          <xsl:if test="$html.depth != '' and $depth-units != '%'">
            <!-- don't do this for percentages because browsers get confused -->
            <xsl:choose>
              <xsl:when test="$css.decoration != 0">
                <xsl:attribute name="style">
                  <xsl:text>height: </xsl:text>
                  <xsl:value-of select="$html.depth"/>
                  <xsl:text>px</xsl:text>
                </xsl:attribute>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="height">
                  <xsl:value-of select="$html.depth"/>
                </xsl:attribute>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:if>
          <td>
            <xsl:if test="$bgcolor != ''">
              <xsl:choose>
                <xsl:when test="$css.decoration != 0">
                  <xsl:attribute name="style">
                    <xsl:text>background-color: </xsl:text>
                    <xsl:value-of select="$bgcolor"/>
                  </xsl:attribute>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:attribute name="bgcolor">
                    <xsl:value-of select="$bgcolor"/>
                  </xsl:attribute>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:if>
            <xsl:if test="@align">
              <xsl:attribute name="align">
                <xsl:value-of select="@align"/>
              </xsl:attribute>
            </xsl:if>
            <xsl:if test="@valign">
              <xsl:attribute name="valign">
                <xsl:value-of select="@valign"/>
              </xsl:attribute>
            </xsl:if>
            <xsl:copy-of select="$img"/>
          </td>
        </tr>
      </table>
    </xsl:when>
    <xsl:otherwise>
      <xsl:copy-of select="$img"/>
    </xsl:otherwise>
  </xsl:choose>

  <xsl:if test="$tag = 'img' and ../../self::imageobjectco and not($scaled)">
    <xsl:variable name="mapname">
      <xsl:call-template name="object.id">
        <xsl:with-param name="object" select="../../areaspec"/>
      </xsl:call-template>
    </xsl:variable>

    <map name="{$mapname}">
      <xsl:for-each select="../../areaspec//area">
        <xsl:variable name="units">
          <xsl:choose>
            <xsl:when test="@units = 'other' and @otherunits">
              <xsl:value-of select="@otherunits"/>
            </xsl:when>
            <xsl:when test="@units">
              <xsl:value-of select="@units"/>
            </xsl:when>
            <!-- areaspec|areaset/area -->
            <xsl:when test="../@units = 'other' and ../@otherunits">
              <xsl:value-of select="../@otherunits"/>
            </xsl:when>
            <xsl:when test="../@units">
              <xsl:value-of select="../@units"/>
            </xsl:when>
            <!-- areaspec/areaset/area -->
            <xsl:when test="../../@units = 'other' and ../../@otherunits">
              <xsl:value-of select="../@otherunits"/>
            </xsl:when>
            <xsl:when test="../../@units">
              <xsl:value-of select="../../@units"/>
            </xsl:when>
            <xsl:otherwise>calspair</xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
 
        <xsl:choose>
          <xsl:when test="$units = 'calspair' or                           $units = 'imagemap'">
            <xsl:variable name="coords" select="normalize-space(@coords)"/>

            <area shape="rect">
              <xsl:variable name="linkends">
                <xsl:choose>
                  <xsl:when test="@linkends">
                    <xsl:value-of select="normalize-space(@linkends)"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="normalize-space(../@linkends)"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
 
              <xsl:variable name="href">
                <xsl:choose>
                  <xsl:when test="@xlink:href">
                    <xsl:value-of select="@xlink:href"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="../@xlink:href"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
 
              <xsl:choose>
                <xsl:when test="$linkends != ''">
                  <xsl:variable name="linkend">
                    <xsl:choose>
                      <xsl:when test="contains($linkends, ' ')">
                        <xsl:value-of select="substring-before($linkends, ' ')"/>
                      </xsl:when>
                      <xsl:otherwise>
                        <xsl:value-of select="$linkends"/>
                      </xsl:otherwise>
                    </xsl:choose>
                  </xsl:variable>
                  <xsl:variable name="target" select="key('id', $linkend)[1]"/>
                 
                  <xsl:if test="$target">
                    <xsl:attribute name="href">
                      <xsl:call-template name="href.target">
                        <xsl:with-param name="object" select="$target"/>
                      </xsl:call-template>
                    </xsl:attribute>
                  </xsl:if>
                </xsl:when>
                <xsl:when test="$href != ''">
                  <xsl:attribute name="href">
                    <xsl:value-of select="$href"/>
                  </xsl:attribute>
                </xsl:when>
              </xsl:choose>
 
              <xsl:if test="alt">
                <xsl:attribute name="alt">
                  <xsl:value-of select="alt[1]"/>
                </xsl:attribute>
              </xsl:if>
 
              <xsl:attribute name="coords">
                <xsl:choose>
                  <xsl:when test="$units = 'calspair'">

                    <xsl:variable name="p1" select="substring-before($coords, ' ')"/>
                    <xsl:variable name="p2" select="substring-after($coords, ' ')"/>
         
                    <xsl:variable name="x1" select="substring-before($p1,',')"/>
                    <xsl:variable name="y1" select="substring-after($p1,',')"/>
                    <xsl:variable name="x2" select="substring-before($p2,',')"/>
                    <xsl:variable name="y2" select="substring-after($p2,',')"/>
         
                    <xsl:variable name="x1p" select="$x1 div 100.0"/>
                    <xsl:variable name="y1p" select="$y1 div 100.0"/>
                    <xsl:variable name="x2p" select="$x2 div 100.0"/>
                    <xsl:variable name="y2p" select="$y2 div 100.0"/>
         
         <!--
                    <xsl:message>
                      <xsl:text>units: </xsl:text>
                      <xsl:value-of select="$units"/>
                      <xsl:text> </xsl:text>
                      <xsl:value-of select="$x1p"/><xsl:text>, </xsl:text>
                      <xsl:value-of select="$y1p"/><xsl:text>, </xsl:text>
                      <xsl:value-of select="$x2p"/><xsl:text>, </xsl:text>
                      <xsl:value-of select="$y2p"/><xsl:text>, </xsl:text>
                    </xsl:message>
         
                    <xsl:message>
                      <xsl:text>      </xsl:text>
                      <xsl:value-of select="$intrinsicwidth"/>
                      <xsl:text>, </xsl:text>
                      <xsl:value-of select="$intrinsicdepth"/>
                    </xsl:message>
         
                    <xsl:message>
                      <xsl:text>      </xsl:text>
                      <xsl:value-of select="$units"/>
                      <xsl:text> </xsl:text>
                      <xsl:value-of 
                            select="round($x1p * $intrinsicwidth div 100.0)"/>
                      <xsl:text>,</xsl:text>
                      <xsl:value-of select="round($intrinsicdepth
                                       - ($y2p * $intrinsicdepth div 100.0))"/>
                      <xsl:text>,</xsl:text>
                      <xsl:value-of select="round($x2p * 
                                            $intrinsicwidth div 100.0)"/>
                      <xsl:text>,</xsl:text>
                      <xsl:value-of select="round($intrinsicdepth
                                       - ($y1p * $intrinsicdepth div 100.0))"/>
                    </xsl:message>
         -->
                    <xsl:value-of select="round($x1p * $intrinsicwidth div 100.0)"/>
                    <xsl:text>,</xsl:text>
                    <xsl:value-of select="round($intrinsicdepth                                         - ($y2p * $intrinsicdepth div 100.0))"/>
                    <xsl:text>,</xsl:text>
                    <xsl:value-of select="round($x2p * $intrinsicwidth div 100.0)"/>
                    <xsl:text>,</xsl:text>
                    <xsl:value-of select="round($intrinsicdepth                                       - ($y1p * $intrinsicdepth div 100.0))"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:copy-of select="$coords"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:attribute>
            </area>
          </xsl:when>
          <xsl:otherwise>
            <xsl:message>
              <xsl:text>Warning: only calspair or </xsl:text>
              <xsl:text>otherunits='imagemap' supported </xsl:text>
              <xsl:text>in imageobjectco</xsl:text>
            </xsl:message>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:for-each>
    </map>
  </xsl:if>
</xsl:template>
<xsl:template match="tgroup" name="tgroup">
  <xsl:if test="not(@cols) or @cols = '' or string(number(@cols)) = 'NaN'">
    <xsl:message terminate="yes">
      <xsl:text>Error: CALS tables must specify the number of columns.</xsl:text>
    </xsl:message>
  </xsl:if>

  <xsl:variable name="summary">
    <xsl:call-template name="dbhtml-attribute">
      <xsl:with-param name="pis" select="processing-instruction('dbhtml')"/>
      <xsl:with-param name="attribute" select="'table-summary'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="cellspacing">
    <xsl:call-template name="dbhtml-attribute">
      <xsl:with-param name="pis" select="processing-instruction('dbhtml')"/>
      <xsl:with-param name="attribute" select="'cellspacing'"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="cellpadding">
    <xsl:call-template name="dbhtml-attribute">
      <xsl:with-param name="pis" select="processing-instruction('dbhtml')[1]"/>
      <xsl:with-param name="attribute" select="'cellpadding'"/>
    </xsl:call-template>
  </xsl:variable>

  <table>
    <xsl:choose>
      <!-- If there's a textobject/phrase for the table summary, use it -->
      <xsl:when test="../textobject/phrase">
        <xsl:attribute name="summary">
          <xsl:value-of select="../textobject/phrase"/>
        </xsl:attribute>
      </xsl:when>

      <!-- If there's a <?dbhtml table-summary="foo"?> PI, use it for
           the HTML table summary attribute -->
      <xsl:when test="$summary != ''">
        <xsl:attribute name="summary">
          <xsl:value-of select="$summary"/>
        </xsl:attribute>
      </xsl:when>

      <!-- Otherwise, if there's a title, use that -->
      <xsl:when test="../title">
        <xsl:attribute name="summary">
          <xsl:value-of select="string(../title)"/>
        </xsl:attribute>
      </xsl:when>

      <!-- Otherwise, forget the whole idea -->
      <xsl:otherwise><!-- nevermind --></xsl:otherwise>
    </xsl:choose>

    <xsl:if test="$cellspacing != '' or $html.cellspacing != ''">
      <xsl:attribute name="cellspacing">
        <xsl:choose>
          <xsl:when test="$cellspacing != ''">
            <xsl:value-of select="$cellspacing"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$html.cellspacing"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
    </xsl:if>

    <xsl:if test="$cellpadding != '' or $html.cellpadding != ''">
      <xsl:attribute name="cellpadding">
        <xsl:choose>
          <xsl:when test="$cellpadding != ''">
            <xsl:value-of select="$cellpadding"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$html.cellpadding"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
    </xsl:if>

    <xsl:if test="../@pgwide=1 or local-name(.) = 'entrytbl'">
      <xsl:attribute name="width">100%</xsl:attribute>
    </xsl:if>
<!--
snip border rubbish. BZ #875967
-->
    <xsl:variable name="colgroup">
      <colgroup>
        <xsl:call-template name="generate.colgroup">
          <xsl:with-param name="cols" select="@cols"/>
        </xsl:call-template>
      </colgroup>
    </xsl:variable>

    <xsl:variable name="explicit.table.width">
      <xsl:call-template name="dbhtml-attribute">
        <xsl:with-param name="pis" select="../processing-instruction('dbhtml')[1]"/>
        <xsl:with-param name="attribute" select="'table-width'"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:variable name="table.width">
      <xsl:choose>
        <xsl:when test="$explicit.table.width != ''">
          <xsl:value-of select="$explicit.table.width"/>
        </xsl:when>
        <xsl:when test="$default.table.width = ''">
          <xsl:text>100%</xsl:text>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$default.table.width"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>

    <xsl:if test="$default.table.width != ''                   or $explicit.table.width != ''">
      <xsl:attribute name="width">
        <xsl:choose>
          <xsl:when test="contains($table.width, '%')">
            <xsl:value-of select="$table.width"/>
          </xsl:when>
          <xsl:when test="$use.extensions != 0                           and $tablecolumns.extension != 0">
            <xsl:choose>
              <xsl:when test="function-available('stbl:convertLength')">
                <xsl:value-of select="stbl:convertLength($table.width)"/>
              </xsl:when>
              <xsl:when test="function-available('xtbl:convertLength')">
                <xsl:value-of select="xtbl:convertLength($table.width)"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:message terminate="yes">
                  <xsl:text>No convertLength function available.</xsl:text>
                </xsl:message>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$table.width"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
    </xsl:if>

    <xsl:choose>
      <xsl:when test="$use.extensions != 0                       and $tablecolumns.extension != 0">
        <xsl:choose>
          <xsl:when test="function-available('stbl:adjustColumnWidths')">
            <xsl:copy-of select="stbl:adjustColumnWidths($colgroup)"/>
          </xsl:when>
          <xsl:when test="function-available('xtbl:adjustColumnWidths')">
            <xsl:copy-of select="xtbl:adjustColumnWidths($colgroup)"/>
          </xsl:when>
          <xsl:when test="function-available('ptbl:adjustColumnWidths')">
            <xsl:copy-of select="ptbl:adjustColumnWidths($colgroup)"/>
          </xsl:when>
        <xsl:when test="function-available('perl:adjustColumnWidths')">
          <xsl:copy-of select="perl:adjustColumnWidths($table.width, $colgroup)"/>
        </xsl:when>
          <xsl:otherwise>
            <xsl:message terminate="yes">
              <xsl:text>No adjustColumnWidths function available.</xsl:text>
            </xsl:message>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:copy-of select="$colgroup"/>
      </xsl:otherwise>
    </xsl:choose>

    <xsl:apply-templates select="thead"/>
    <xsl:apply-templates select="tfoot"/>
    <xsl:apply-templates select="tbody"/>

    <xsl:if test=".//footnote">
      <tbody class="footnotes">
        <tr>
          <td colspan="{@cols}">
            <xsl:apply-templates select=".//footnote" mode="table.footnote.mode"/>
          </td>
        </tr>
      </tbody>
    </xsl:if>
  </table>
</xsl:template>
<xsl:template match="programlistingco|screenco">
  <xsl:variable name="verbatim" select="programlisting|screen"/>

  <xsl:choose>
    <xsl:when test="$use.extensions != '0' and $callouts.extension != '0'">
      <xsl:variable name="rtf">
        <xsl:apply-templates select="$verbatim">
          <xsl:with-param name="suppress-numbers" select="'1'"/>
        </xsl:apply-templates>
      </xsl:variable>

      <xsl:variable name="rtf-with-callouts">
        <xsl:choose>
          <xsl:when test="function-available('sverb:insertCallouts')">
            <xsl:copy-of select="sverb:insertCallouts(areaspec,$rtf)"/>
          </xsl:when>
          <xsl:when test="function-available('xverb:insertCallouts')">
            <xsl:copy-of select="xverb:insertCallouts(areaspec,$rtf)"/>
          </xsl:when>
          <xsl:when test="function-available('perl:insertCallouts')">
            <xsl:copy-of select="perl:insertCallouts(areaspec,exsl:node-set($rtf))"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:message terminate="yes">
              <xsl:text>No insertCallouts function is available.</xsl:text>
            </xsl:message>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>

      <xsl:choose>
        <xsl:when test="$verbatim/@linenumbering = 'numbered'                         and $linenumbering.extension != '0'">
          <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="number.rtf.lines">
              <xsl:with-param name="rtf" select="$rtf-with-callouts"/>
              <xsl:with-param name="pi.context" select="programlisting|screen"/>
            </xsl:call-template>
            <xsl:apply-templates select="calloutlist"/>
          </div>
        </xsl:when>
        <xsl:otherwise>
          <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:copy-of select="$rtf-with-callouts"/>
            <xsl:apply-templates select="calloutlist"/>
          </div>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <div>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:apply-templates/>
      </div>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<xsl:template match="co" name="co">
  <!-- Support a single linkend in HTML -->
  <xsl:variable name="targets" select="key('id', @linkends)"/>
  <xsl:variable name="target" select="$targets[1]"/>
  <xsl:choose>
    <xsl:when test="$target">
      <a>
        <xsl:apply-templates select="." mode="common.html.attributes"/>
        <xsl:if test="@id or @xml:id">
          <xsl:attribute name="id">
            <xsl:value-of select="(@id|@xml:id)[1]"/>
          </xsl:attribute>
        </xsl:if>
        <xsl:attribute name="href">
          <xsl:call-template name="href.target">
            <xsl:with-param name="object" select="$target"/>
          </xsl:call-template>
        </xsl:attribute>
        <xsl:apply-templates select="." mode="callout-bug"/>
      </a>
    </xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="." mode="callout-bug"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<xsl:template match="co" mode="callout-bug">
  <xsl:call-template name="callout-bug">
    <xsl:with-param name="conum">
      <xsl:number count="co" level="any" from="programlisting|screen|literallayout|synopsis" format="1"/>
    </xsl:with-param>
  </xsl:call-template>
</xsl:template>
<xsl:template name="callout-bug">
  <xsl:param name="conum" select="1"/>

  <xsl:choose>
    <xsl:when test="$callout.graphics != 0                     and $conum &lt;= $callout.graphics.number.limit">
      <img class="callout" src="{$callout.graphics.path}{$conum}{$callout.graphics.extension}" alt="{$conum}" border="0">
        <xsl:if test="@id or @xml:id">
          <xsl:attribute name="id">
            <xsl:value-of select="(@id|@xml:id)[1]"/>
          </xsl:attribute>
        </xsl:if>
      </img>
    </xsl:when>
    <xsl:when test="$callout.unicode != 0                     and $conum &lt;= $callout.unicode.number.limit">
      <xsl:choose>
        <xsl:when test="$callout.unicode.start.character = 10102">
          <xsl:choose>
            <xsl:when test="$conum = 1">â¶</xsl:when>
            <xsl:when test="$conum = 2">â·</xsl:when>
            <xsl:when test="$conum = 3">â¸</xsl:when>
            <xsl:when test="$conum = 4">â¹</xsl:when>
            <xsl:when test="$conum = 5">âº</xsl:when>
            <xsl:when test="$conum = 6">â»</xsl:when>
            <xsl:when test="$conum = 7">â¼</xsl:when>
            <xsl:when test="$conum = 8">â½</xsl:when>
            <xsl:when test="$conum = 9">â¾</xsl:when>
            <xsl:when test="$conum = 10">â¿</xsl:when>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:message>
            <xsl:text>Don't know how to generate Unicode callouts </xsl:text>
            <xsl:text>when $callout.unicode.start.character is </xsl:text>
            <xsl:value-of select="$callout.unicode.start.character"/>
          </xsl:message>
          <xsl:text>(</xsl:text>
          <xsl:value-of select="$conum"/>
          <xsl:text>)</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>(</xsl:text>
      <xsl:value-of select="$conum"/>
      <xsl:text>)</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<xsl:template name="number.rtf.lines">
  <xsl:param name="rtf" select="''"/>
  <xsl:param name="pi.context" select="."/>

  <!-- Save the global values -->
  <xsl:variable name="global.linenumbering.everyNth" select="$linenumbering.everyNth"/>

  <xsl:variable name="global.linenumbering.separator" select="$linenumbering.separator"/>

  <xsl:variable name="global.linenumbering.width" select="$linenumbering.width"/>

  <!-- Extract the <?dbhtml linenumbering.*?> PI values -->
  <xsl:variable name="pi.linenumbering.everyNth">
    <xsl:call-template name="pi.dbhtml_linenumbering.everyNth">
      <xsl:with-param name="node" select="$pi.context"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="pi.linenumbering.separator">
    <xsl:call-template name="pi.dbhtml_linenumbering.separator">
      <xsl:with-param name="node" select="$pi.context"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="pi.linenumbering.width">
    <xsl:call-template name="pi.dbhtml_linenumbering.width">
      <xsl:with-param name="node" select="$pi.context"/>
    </xsl:call-template>
  </xsl:variable>

  <!-- Construct the 'in-context' values -->
  <xsl:variable name="linenumbering.everyNth">
    <xsl:choose>
      <xsl:when test="$pi.linenumbering.everyNth != ''">
        <xsl:value-of select="$pi.linenumbering.everyNth"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$global.linenumbering.everyNth"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="linenumbering.separator">
    <xsl:choose>
      <xsl:when test="$pi.linenumbering.separator != ''">
        <xsl:value-of select="$pi.linenumbering.separator"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$global.linenumbering.separator"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="linenumbering.width">
    <xsl:choose>
      <xsl:when test="$pi.linenumbering.width != ''">
        <xsl:value-of select="$pi.linenumbering.width"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$global.linenumbering.width"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="linenumbering.startinglinenumber">
    <xsl:choose>
      <xsl:when test="$pi.context/@startinglinenumber">
        <xsl:value-of select="$pi.context/@startinglinenumber"/>
      </xsl:when>
      <xsl:when test="$pi.context/@continuation='continues'">
        <xsl:variable name="lastLine">
          <xsl:choose>
            <xsl:when test="$pi.context/self::programlisting">
              <xsl:call-template name="lastLineNumber">
                <xsl:with-param name="listings" select="preceding::programlisting[@linenumbering='numbered']"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:when test="$pi.context/self::screen">
              <xsl:call-template name="lastLineNumber">
                <xsl:with-param name="listings" select="preceding::screen[@linenumbering='numbered']"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:when test="$pi.context/self::literallayout">
              <xsl:call-template name="lastLineNumber">
                <xsl:with-param name="listings" select="preceding::literallayout[@linenumbering='numbered']"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:when test="$pi.context/self::address">
              <xsl:call-template name="lastLineNumber">
                <xsl:with-param name="listings" select="preceding::address[@linenumbering='numbered']"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:when test="$pi.context/self::synopsis">
              <xsl:call-template name="lastLineNumber">
                <xsl:with-param name="listings" select="preceding::synopsis[@linenumbering='numbered']"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:message>
                <xsl:text>Unexpected verbatim environment: </xsl:text>
                <xsl:value-of select="local-name($pi.context)"/>
              </xsl:message>
              <xsl:value-of select="0"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>

        <xsl:value-of select="$lastLine + 1"/>
      </xsl:when>
      <xsl:otherwise>1</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="function-available('sverb:numberLines')">
      <xsl:copy-of select="sverb:numberLines($rtf)"/>
    </xsl:when>
    <xsl:when test="function-available('xverb:numberLines')">
      <xsl:copy-of select="xverb:numberLines($rtf)"/>
    </xsl:when>
    <xsl:when test="function-available('perl:numberLines')">
      <xsl:copy-of select="perl:numberLines($linenumbering.startinglinenumber, $rtf)"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:message terminate="yes">
        <xsl:text>No numberLines function available.</xsl:text>
      </xsl:message>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
<xsl:template match="*" mode="html.title.attribute">
  <xsl:variable name="is.title">
    <xsl:call-template name="gentext.template.exists">
      <xsl:with-param name="context" select="'title'"/>
      <xsl:with-param name="name" select="local-name(.)"/>
      <xsl:with-param name="lang">
        <xsl:call-template name="l10n.language"/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="is.title-numbered">
    <xsl:call-template name="gentext.template.exists">
      <xsl:with-param name="context" select="'title-numbered'"/>
      <xsl:with-param name="name" select="local-name(.)"/>
      <xsl:with-param name="lang">
        <xsl:call-template name="l10n.language"/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="is.title-unnumbered">
    <xsl:call-template name="gentext.template.exists">
      <xsl:with-param name="context" select="'title-unnumbered'"/>
      <xsl:with-param name="name" select="local-name(.)"/>
      <xsl:with-param name="lang">
        <xsl:call-template name="l10n.language"/>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="has.title.markup">
    <xsl:apply-templates select="." mode="title.markup">
      <xsl:with-param name="verbose" select="0"/>
    </xsl:apply-templates>
  </xsl:variable>

  <xsl:variable name="gentext.title">
    <xsl:if test="$has.title.markup != '???TITLE???' and                   ($is.title != 0 or                   $is.title-numbered != 0 or                   $is.title-unnumbered != 0)">
      <xsl:apply-templates select="." mode="object.title.markup.textonly"/>
    </xsl:if>
  </xsl:variable>

  <xsl:choose>
    <!--xsl:when test="string-length($gentext.title) != 0">
      <xsl:attribute name="title">
        <xsl:value-of select="$gentext.title"/>
      </xsl:attribute>
    </xsl:when-->
    <!-- Fall back to alt if available -->
    <xsl:when test="alt">
      <xsl:attribute name="title">
        <xsl:value-of select="normalize-space(alt)"/>
      </xsl:attribute>
    </xsl:when>
  </xsl:choose>
</xsl:template>
<xsl:template match="footnote">
  <xsl:variable name="href">
    <xsl:text>#ftn.</xsl:text>
    <xsl:call-template name="object.id">
      <xsl:with-param name="conditional" select="0"/>
    </xsl:call-template>
  </xsl:variable>

      <xsl:call-template name="anchor">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>
  <a href="{$href}">
    <xsl:apply-templates select="." mode="class.attribute"/>
    <sup>
      <xsl:apply-templates select="." mode="class.attribute"/>
      <xsl:call-template name="id.attribute">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>
<!-- MOVED UP BZ #
      <xsl:call-template name="anchor">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>
-->
      <xsl:text>[</xsl:text>
      <xsl:apply-templates select="." mode="footnote.number"/>
      <xsl:text>]</xsl:text>
    </sup>
  </a>
</xsl:template>
<xsl:template match="*" mode="process.root">
  <xsl:variable name="doc" select="self::*"/>

  <xsl:call-template name="user.preroot"/>
  <xsl:call-template name="root.messages"/>
  
  <xsl:choose>
    <xsl:when test="$body.only != 0">
      <xsl:apply-templates select="."/>
    </xsl:when>
    <xsl:otherwise>
      <html>
        <xsl:call-template name="root.attributes"/>
        <head>
          <xsl:call-template name="system.head.content">
            <xsl:with-param name="node" select="$doc"/>
          </xsl:call-template>
          <xsl:call-template name="head.content">
            <xsl:with-param name="node" select="$doc"/>
          </xsl:call-template>
          <xsl:call-template name="user.head.content">
            <xsl:with-param name="node" select="$doc"/>
          </xsl:call-template>
        </head>
        <body>
          <xsl:call-template name="body.attributes"/>
          <xsl:call-template name="user.header.content">
            <xsl:with-param name="node" select="$doc"/>
          </xsl:call-template>
          <xsl:apply-templates select="."/>
          <xsl:call-template name="user.footer.content">
            <xsl:with-param name="node" select="$doc"/>
          </xsl:call-template>
        </body>
      </html>
      <xsl:value-of select="$html.append"/>
    
      <!-- Generate any css files only once, not once per chunk -->
      <xsl:call-template name="generate.css.files"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
</xsl:stylesheet>
